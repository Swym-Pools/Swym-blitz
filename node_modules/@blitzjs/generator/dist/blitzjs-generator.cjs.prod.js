'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var display = require('@blitzjs/display');
var chalk = require('chalk');
var spawn = require('cross-spawn');
var fs = require('fs-extra');
var path = require('path');
var username = require('username');
var babel = require('@babel/core');
var babelTransformTypescript = require('@babel/plugin-transform-typescript');
var enquirer = require('enquirer');
var events = require('events');
var j = require('jscodeshift');
var memFs = require('mem-fs');
var memFsEditor = require('mem-fs-editor');
var getBabelOptions = require('recast/parsers/_babel_options');
var babelParser = require('recast/parsers/babel');
var diff = require('diff');
var stream = require('stream');
var fs$1 = require('fs');
var got = require('got');
var ast = require('@mrleebo/prisma-ast');
var which = require('npm-which');
var pluralize = require('pluralize');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var chalk__default = /*#__PURE__*/_interopDefault(chalk);
var spawn__default = /*#__PURE__*/_interopDefault(spawn);
var path__namespace = /*#__PURE__*/_interopNamespace(path);
var username__default = /*#__PURE__*/_interopDefault(username);
var babelTransformTypescript__default = /*#__PURE__*/_interopDefault(babelTransformTypescript);
var enquirer__default = /*#__PURE__*/_interopDefault(enquirer);
var j__default = /*#__PURE__*/_interopDefault(j);
var getBabelOptions__default = /*#__PURE__*/_interopDefault(getBabelOptions);
var got__default = /*#__PURE__*/_interopDefault(got);
var which__default = /*#__PURE__*/_interopDefault(which);
var pluralize__default = /*#__PURE__*/_interopDefault(pluralize);

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

var PromptAbortedError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(PromptAbortedError, _Error);

  function PromptAbortedError() {
    return _Error.call(this, "Prompt aborted") || this;
  }

  return PromptAbortedError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var ConflictChecker = /*#__PURE__*/function (_Transform) {
  _inheritsLoose(ConflictChecker, _Transform);

  function ConflictChecker(options) {
    var _this;

    _this = _Transform.call(this, {
      objectMode: true
    }) || this;
    _this._destroyed = false;
    return _this;
  }

  var _proto = ConflictChecker.prototype;

  _proto._transform = function _transform(file, _encoding, cb) {
    var _this2 = this;

    if (file.state === null) {
      cb();
      return;
    } // If the file doesn't exists yet there isn't any diff to perform


    var filePath = path.resolve(file.path);

    if (!fs.existsSync(filePath)) {
      this.handlePush(file, "create");
      cb();
      return;
    }

    this.checkDiff(file).then(function (status) {
      if (status !== "skip") {
        _this2.handlePush(file, status);
      } else {
        var _this2$options;

        _this2.fileStatusString(file, status, (_this2$options = _this2.options) == null ? void 0 : _this2$options.dryRun);
      }

      cb();
    })["catch"](function (err) {
      // If the error is an empty string, it means that the user has
      // stopped the prompt with ctrl-c so we return PromptAbortedError
      // to end the program without writing anything to disk
      cb(err || new PromptAbortedError());
    });
  };

  _proto.destroy = function destroy(err) {
    var _this3 = this;

    if (this._destroyed) return;
    this._destroyed = true;
    process.nextTick(function () {
      if (err) _this3.emit("err", err);

      _this3.emit("close");
    });
  };

  _proto.handlePush = function handlePush(file, status) {
    var _this$options, _this$options2;

    if (!((_this$options = this.options) != null && _this$options.dryRun)) this.push(file);
    this.emit("fileStatus", this.fileStatusString(file, status, (_this$options2 = this.options) == null ? void 0 : _this$options2.dryRun));
  };

  _proto.checkDiff = async function checkDiff(file) {
    var _file$contents$toStri, _file$contents;

    var newFileContents = (_file$contents$toStri = (_file$contents = file.contents) == null ? void 0 : _file$contents.toString()) != null ? _file$contents$toStri : "";
    var oldFileContents = fs.readFileSync(path.resolve(file.path)).toString();
    var diff$1 = diff.diffLines(oldFileContents, newFileContents);
    var conflict = diff$1.some(function (line) {
      return line.added || line.removed;
    });

    if (conflict) {
      var answer = null;

      do {
        var _answer, _answer2;

        answer = await enquirer__default['default'].prompt({
          type: "select",
          name: "action",
          message: "The file \"" + file.path + "\" has conflicts. What do you want to do?",
          // Maybe color file.path
          choices: [{
            name: "overwrite",
            message: "Overwrite",
            value: "overwrite"
          }, {
            name: "skip",
            message: "Skip",
            value: "skip"
          }, {
            name: "show",
            message: "Show changes",
            value: "show"
          }]
        });
        if (((_answer2 = answer) == null ? void 0 : _answer2.action) === "show") this.printDiff(diff$1);
      } while (((_answer = answer) == null ? void 0 : _answer.action) === "show");

      return answer.action;
    }

    return "identical";
  };

  _proto.printDiff = function printDiff(diff) {
    console.log("\n");
    diff.forEach(function (line) {
      var value = line.value.replace("\n", "");

      if (line.added) {
        console.log(chalk__default['default'].green("+ " + value));
      } else if (line.removed) {
        console.log(chalk__default['default'].red("- " + value));
      } else {
        console.log(value);
      }
    });
    console.log("\n");
  };

  _proto.fileStatusString = function fileStatusString(file, status, dryRun) {
    if (dryRun === void 0) {
      dryRun = false;
    }

    var statusLog = null;

    switch (status) {
      case "create":
        statusLog = chalk__default['default'].green((dryRun ? "Would create" : "CREATE") + "   ");
        break;

      case "overwrite":
        statusLog = chalk__default['default'].cyan((dryRun ? "Would overwrite" : "OVERWRITE") + "   ");
        break;

      case "skip":
        statusLog = chalk__default['default'].blue("SKIP     ");
        break;

      case "identical":
        statusLog = chalk__default['default'].gray("IDENTICAL");
    }

    return statusLog + " " + file.relative;
  };

  return ConflictChecker;
}(stream.Transform);

function pipe() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function piper(initial) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    return fns.reduce(function (acc, val) {
      return val.apply(void 0, [acc].concat(args));
    }, initial);
  };
}

async function readdirRecursive(root, filter, dir) {
  if (dir === void 0) {
    dir = "";
  }

  var absoluteDir = path__namespace['default'].resolve(root, dir);
  var dirStats = await fs$1.promises.stat(absoluteDir);

  if (dirStats.isDirectory()) {
    var entries = await fs$1.promises.readdir(absoluteDir);

    if (filter) {
      entries = entries.filter(function (name) {
        return filter(name, dir);
      });
    }

    var recursiveList = await Promise.all(entries.map(function (name) {
      return readdirRecursive(root, filter, path__namespace['default'].join(dir, name));
    }));
    return recursiveList.flat(Infinity);
  } else {
    return [dir];
  }
}

var debug = /*#__PURE__*/require("debug")("blitz:generator");

var customTsParser = {
  parse: function parse(source, options) {
    var babelOptions = getBabelOptions__default['default'](options);
    babelOptions.plugins.push("typescript");
    babelOptions.plugins.push("jsx");
    return babelParser.parser.parse(source, babelOptions);
  }
};
var alwaysIgnoreFiles = [".blitz", ".DS_Store", ".git", ".next", ".now", "node_modules"];
var ignoredExtensions = [".ico", ".png", ".jpg"];
var tsExtension = /\.(tsx?)$/;
var codeFileExtensions = /\.(tsx?|jsx?)$/;

function getStatements(node) {
  return j__default['default'].BlockStatement.check(node) ? node.body : [node];
}

function replaceConditionalNode(path, templateValues) {
  // @ts-ignore
  var condition = path.node.test.property.name;
  if (!Object.keys(templateValues).includes(condition)) return;
  var derivedCondition = templateValues[condition];

  if (derivedCondition) {
    j__default['default'](path).replaceWith(getStatements(path.node.consequent));
  } else {
    if (path.node.alternate) {
      j__default['default'](path).replaceWith(getStatements(path.node.alternate));
    } else {
      j__default['default'](path).remove();
    }
  }
} // process any template expressions that access process.env, but bypass any
// expressions that aren't targeting templateValues so templates can include
// checks for other env variables


function replaceConditionalStatements(program, templateValues) {
  var processEnvRequirements = {
    test: {
      object: {
        object: {
          name: "process"
        },
        property: {
          name: "env"
        }
      }
    }
  };
  program.find(j__default['default'].IfStatement, processEnvRequirements).forEach(function (path) {
    return replaceConditionalNode(path, templateValues);
  });
  program.find(j__default['default'].ConditionalExpression, processEnvRequirements).forEach(function (path) {
    return replaceConditionalNode(path, templateValues);
  });
  return program;
}

function replaceJsxConditionals(program, templateValues) {
  program.find(j__default['default'].JSXIdentifier, {
    name: "if"
  }).forEach(function (path) {
    if (j__default['default'].JSXOpeningElement.check(path.parent.node)) {
      var conditionPath = j__default['default'](path.parent).find(j__default['default'].JSXAttribute, {
        name: {
          name: "condition"
        }
      }).at(0);
      var condition = conditionPath.paths()[0].value.value.value;
      if (!Object.keys(templateValues).includes(condition)) return;
      var useConsequent = templateValues[condition];
      var innerElements = path.parent.parent.node.children.filter(j__default['default'].JSXElement.check.bind(j__default['default'].JSXElement));
      var consequent = innerElements[0];
      var alternate = innerElements[1] && j__default['default'](innerElements[1]).paths()[0].node.children.filter(j__default['default'].JSXElement.check.bind(j__default['default'].JSXElement));
      var result = useConsequent ? consequent : alternate;

      if (!result) {
        j__default['default'](path.parent.parent).remove();
      } else {
        j__default['default'](path.parent.parent).replaceWith(result);
      }
    }
  });
  return program;
}
/**
 * The base generator class.
 * Every generator must extend this class.
 */


var Generator = /*#__PURE__*/function (_EventEmitter) {
  _inheritsLoose(Generator, _EventEmitter);

  /**
   * When `type: 'absolute'`, it's an absolute path
   * When `type: 'template'`, is the path type `templates/`.
   *
   * @example {type: 'absolue', path: './src/app'} => `./src/app`
   * @example {type: 'template', path: 'app'} => `templates/app`
   */
  function Generator(options) {
    var _this;

    _this = _EventEmitter.call(this) || this;
    _this.store = void 0;
    _this.fs = void 0;
    _this.enquirer = void 0;
    _this.performedActions = [];
    _this.useTs = void 0;
    _this.prettier = void 0;
    _this.prettierDisabled = false;
    _this.unsafe_disableConflictChecker = false;
    _this.returnResults = false;
    _this.sourceRoot = void 0;
    _this.options = options;
    _this.store = memFs.create();
    _this.fs = memFsEditor.create(_this.store);
    _this.enquirer = new enquirer__default['default']();
    _this.useTs = typeof _this.options.useTs === "undefined" ? fs.existsSync(path.resolve("tsconfig.json")) : _this.options.useTs;
    if (!_this.options.destinationRoot) _this.options.destinationRoot = process.cwd();
    return _this;
  }

  var _proto = Generator.prototype;

  _proto.filesToIgnore = function filesToIgnore() {
    // allow subclasses to conditionally ignore certain template files
    // for example, ignoring tsconfig.json in the app generator when
    // generating a plain JS project
    return [];
  };

  _proto.replaceConditionals = function replaceConditionals(input, templateValues, prettierOptions) {
    if (prettierOptions === void 0) {
      prettierOptions = {};
    }

    var source = j__default['default'](input, {
      parser: customTsParser
    });
    var program = source.find(j__default['default'].Program);
    var result = pipe(replaceConditionalStatements, replaceJsxConditionals)(program, templateValues);
    return result.toSource(_extends({}, prettierOptions, {
      lineTerminator: "\n"
    }));
  };

  _proto.replaceTemplateValues = function replaceTemplateValues(input, templateValues) {
    var result = input;

    for (var templateKey in templateValues) {
      var token = "__" + templateKey + "__";

      if (result.includes(token)) {
        result = result.replace(new RegExp(token, "g"), templateValues[templateKey]);
      }
    }

    return result;
  };

  _proto.process = function process(input, pathEnding, templateValues, prettierOptions) {
    debug("Generator.process...");

    if (new RegExp(ignoredExtensions.join("|") + "$").test(pathEnding)) {
      return input;
    }

    var inputStr = input.toString("utf-8");
    var templatedFile = inputStr;

    if (codeFileExtensions.test(pathEnding)) {
      templatedFile = this.replaceConditionals(inputStr, templateValues, prettierOptions || {});
    }

    templatedFile = this.replaceTemplateValues(templatedFile, templateValues);

    if (!this.useTs && tsExtension.test(pathEnding)) {
      var _babel$transform;

      return ((_babel$transform = babel.transform(templatedFile, {
        plugins: [[babelTransformTypescript__default['default'], {
          isTSX: true
        }]]
      })) == null ? void 0 : _babel$transform.code) || "";
    }

    if (codeFileExtensions.test(pathEnding) && typeof templatedFile === "string" && this.prettier && !this.prettierDisabled) {
      var _options = _extends({}, prettierOptions);

      if (this.useTs) {
        _options.parser = "babel-ts";
      }

      try {
        templatedFile = this.prettier.format(templatedFile, _options);
      } catch (error) {
        display.log.warning("Failed trying to run prettier:" + error);
      }
    }

    return templatedFile;
  };

  _proto.write = async function write() {
    var _this2 = this,
        _this$prettier;

    debug("Generator.write...");
    var paths = await readdirRecursive(this.sourcePath(), function (name) {
      var additionalFilesToIgnore = _this2.filesToIgnore();

      return ![].concat(alwaysIgnoreFiles, additionalFilesToIgnore).includes(name);
    });

    try {
      this.prettier = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('prettier')); });
    } catch (_unused) {}

    var prettierOptions = await ((_this$prettier = this.prettier) == null ? void 0 : _this$prettier.resolveConfig(this.sourcePath()));

    for (var _iterator = _createForOfIteratorHelperLoose(paths), _step; !(_step = _iterator()).done;) {
      var filePath = _step.value;

      try {
        await async function () {
          var pathSuffix = filePath;
          pathSuffix = path.join(_this2.getTargetDirectory(), pathSuffix);
          var templateValues = await _this2.getTemplateValues();

          _this2.fs.copy(_this2.sourcePath(filePath), _this2.destinationPath(pathSuffix), {
            process: function process(input) {
              return _this2.process(input, pathSuffix, templateValues, prettierOptions != null ? prettierOptions : undefined);
            }
          });

          var templatedPathSuffix = _this2.replaceTemplateValues(pathSuffix, templateValues);

          if (!_this2.useTs && tsExtension.test(_this2.destinationPath(pathSuffix))) {
            templatedPathSuffix = templatedPathSuffix.replace(tsExtension, ".js");
          }

          if (templatedPathSuffix !== pathSuffix) {
            _this2.fs.move(_this2.destinationPath(pathSuffix), _this2.destinationPath(templatedPathSuffix));
          }
        }();
      } catch (error) {
        display.log.error("Error generating " + filePath);
        throw error;
      }
    }
  };

  _proto.preCommit = async function preCommit() {// expose precommit hook, no default implementation
  };

  _proto.postWrite = async function postWrite() {// expose postWrite hook, no default implementation
  };

  _proto.preventFileFromLogging = function preventFileFromLogging(_path) {
    // no default implementation
    return false;
  };

  _proto.sourcePath = function sourcePath() {
    for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {
      paths[_key] = arguments[_key];
    }

    if (this.sourceRoot.type === "absolute") {
      return path.join.apply(path__namespace, [this.sourceRoot.path].concat(paths));
    } else {
      return path.join.apply(path__namespace, [__dirname, "./templates", this.sourceRoot.path].concat(paths));
    }
  };

  _proto.destinationPath = function destinationPath() {
    for (var _len2 = arguments.length, paths = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      paths[_key2] = arguments[_key2];
    }

    return path.join.apply(path__namespace, [this.options.destinationRoot].concat(paths));
  };

  _proto.run = async function run() {
    var _this3 = this;

    debug("Generator.run...", {
      options: this.options
    });

    if (!this.options.dryRun) {
      await fs.ensureDir(this.options.destinationRoot);
      process.chdir(this.options.destinationRoot);
    }

    await this.write();
    await this.preCommit();

    if (this.unsafe_disableConflictChecker) {
      await new Promise(function (resolve, reject) {
        try {
          _this3.fs.commit(resolve);
        } catch (err) {
          reject(err);
        }
      });
    } else {
      await new Promise(function (resolve, reject) {
        var conflictChecker = new ConflictChecker({
          dryRun: _this3.options.dryRun
        });
        conflictChecker.on("error", function (err) {
          reject(err);
        });
        conflictChecker.on("fileStatus", function (data) {
          _this3.performedActions.push(data);
        });

        _this3.fs.commit([conflictChecker], function (err) {
          if (err) reject(err);
          resolve();
        });
      });
    }

    if (!this.returnResults) {
      this.performedActions.sort().filter(function (action) {
        // Each action is something like this:
        // "\u001b[32mCREATE   \u001b[39m .env"
        var path = action.split(/ +/g).pop();
        return !_this3.preventFileFromLogging(path);
      }).forEach(function (action) {
        return console.log(action);
      });
    }

    if (!this.options.dryRun) {
      await this.postWrite();
    }

    if (this.returnResults) {
      return this.performedActions.join("\n");
    }
  };

  return Generator;
}(events.EventEmitter);

var fetchAllVersions = async function fetchAllVersions(dependency) {
  var res = await got__default['default']("https://registry.npmjs.org/" + dependency, {
    retry: {
      limit: 3
    },
    timeout: 3000,
    responseType: "json"
  }).json();
  return Object.keys(res.versions);
};
var fetchDistTags = async function fetchDistTags(dependency) {
  var res = await got__default['default']("https://registry.npmjs.org/-/package/" + dependency + "/dist-tags", {
    retry: {
      limit: 3
    },
    timeout: 3000,
    responseType: "json"
  }).json();
  return res;
};
var fetchLatestDistVersion = async function fetchLatestDistVersion(dependency) {
  var res = await fetchDistTags(dependency);
  return res.latest;
};

var logFailedVersionFetch = function logFailedVersionFetch(dependency, fallback) {
  display.log.clearLine(display.log.withWarning("Failed to fetch latest version of '" + chalk__default['default'].bold(dependency) + "', falling back to '" + chalk__default['default'].bold(fallback) + "'.\n"));
};
var getLatestVersion = async function getLatestVersion(dependency, templateVersion) {
  if (templateVersion === void 0) {
    templateVersion = "";
  }

  var major = templateVersion.replace(".x", "");

  try {
    var _await$Promise$all = await Promise.all([fetchAllVersions(dependency), fetchLatestDistVersion(dependency)]),
        allVersions = _await$Promise$all[0],
        latestDistVersion = _await$Promise$all[1];

    var latestVersion = allVersions.filter(function (version) {
      return version.startsWith(major);
    }).sort(function (a, b) {
      return a.localeCompare(b, undefined, {
        numeric: true
      });
    }).reverse()[0]; // If the latest tagged version matches our pinned major, use that, otherwise use the
    // latest untagged which does

    if (latestDistVersion.startsWith(major)) {
      return {
        value: latestDistVersion,
        isFallback: false
      };
    } else {
      return {
        value: latestVersion,
        isFallback: false
      };
    }
  } catch (error) {
    var fallback = templateVersion;
    logFailedVersionFetch(dependency, fallback);
    return {
      value: fallback,
      isFallback: false
    };
  }
};

function fromEntries(entries) {
  return entries.reduce(function (result, _ref) {
    var _Object$assign;

    var key = _ref[0],
        value = _ref[1];
    return Object.assign({}, result, (_Object$assign = {}, _Object$assign[key] = value, _Object$assign));
  }, {});
}

var fetchLatestVersionsFor = async function fetchLatestVersionsFor(dependencies) {
  var entries = Object.entries(dependencies || {});
  var fallbackUsed = false;
  var updated = await Promise.all(entries.map(async function (_ref2) {
    var dep = _ref2[0],
        version = _ref2[1];
    var skipFetch = false;
    if (!version.match(/\d.x/)) skipFetch = true; // We pin experimental versions to ensure they work, so don't auto update experimental

    if (version.match(/experimental/)) skipFetch = true;

    if (skipFetch) {
      return [dep, version];
    } else {
      var _await$getLatestVersi = await getLatestVersion(dep, version),
          latestVersion = _await$getLatestVersi.value,
          isFallback = _await$getLatestVersi.isFallback;

      if (isFallback) {
        fallbackUsed = true;
      }

      return [dep, latestVersion];
    }
  }));
  return {
    isFallback: fallbackUsed,
    value: fromEntries(updated)
  };
};

var getBlitzDependencyVersion = async function getBlitzDependencyVersion(cliVersion) {
  try {
    var _await$fetchDistTags = await fetchDistTags("blitz"),
        latest = _await$fetchDistTags.latest,
        canary = _await$fetchDistTags.canary;

    if (cliVersion.includes("canary")) {
      return {
        value: canary,
        isFallback: false
      };
    }

    return {
      value: latest,
      isFallback: false
    };
  } catch (error) {
    var fallback = "latest";
    logFailedVersionFetch("blitz", fallback);
    return {
      value: fallback,
      isFallback: true
    };
  }
};

function assert(condition, message) {
  if (!condition) throw new Error(message);
}

var AppGenerator = /*#__PURE__*/function (_Generator) {
  _inheritsLoose(AppGenerator, _Generator);

  function AppGenerator() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Generator.call.apply(_Generator, [this].concat(args)) || this;
    _this.sourceRoot = {
      type: "template",
      path: "app"
    };
    _this.prettierDisabled = true;
    _this.packageInstallSuccess = false;
    return _this;
  }

  var _proto = AppGenerator.prototype;

  _proto.filesToIgnore = function filesToIgnore() {
    if (!this.options.useTs) {
      return ["tsconfig.json"];
    }

    return ["jsconfig.json"];
  };

  _proto.getTemplateValues = async function getTemplateValues() {
    return {
      name: this.options.appName,
      username: await username__default['default']()
    };
  };

  _proto.getTargetDirectory = function getTargetDirectory() {
    return "";
  } // eslint-disable-next-line require-await
  ;

  _proto.preCommit = async function preCommit() {
    this.fs.move(this.destinationPath("gitignore"), this.destinationPath(".gitignore"));
    this.fs.move(this.destinationPath("npmrc"), this.destinationPath(".npmrc"));
    var pkg = this.fs.readJSON(this.destinationPath("package.json"));
    assert(pkg, "couldn't find package.json");
    var ext = this.options.useTs ? "tsx" : "js";
    var type;

    switch (this.options.form) {
      case "React Final Form":
        type = "finalform";
        pkg.dependencies["final-form"] = "4.x";
        pkg.dependencies["react-final-form"] = "6.x";
        break;

      case "React Hook Form":
        type = "hookform";
        pkg.dependencies["react-hook-form"] = "7.x";
        pkg.dependencies["@hookform/resolvers"] = "2.x";
        break;

      case "Formik":
        type = "formik";
        pkg.dependencies["formik"] = "2.x";
        break;
    }

    this.fs.move(this.destinationPath("_forms/" + type + "/Form." + ext), this.destinationPath("app/core/components/Form." + ext));
    this.fs.move(this.destinationPath("_forms/" + type + "/LabeledTextField." + ext), this.destinationPath("app/core/components/LabeledTextField." + ext));
    this.fs["delete"](this.destinationPath("_forms"));
    this.fs.writeJSON(this.destinationPath("package.json"), pkg);
  };

  _proto.postWrite = async function postWrite() {
    var _this2 = this;

    var gitInitSuccessful;

    if (!this.options.skipGit) {
      var initResult = spawn__default['default'].sync("git", ["init"], {
        stdio: "ignore"
      });
      gitInitSuccessful = initResult.status === 0;

      if (!gitInitSuccessful) {
        display.log.warning("Failed to run git init.");
        display.log.warning("Find out more about how to install git here: https://git-scm.com/downloads.");
      }
    }

    var pkgJsonLocation = path.join(this.destinationPath(), "package.json");
    var pkg = fs.readJSONSync(pkgJsonLocation);
    console.log(""); // New line needed

    var spinner = display.log.spinner(display.log.withBrand("Retrieving the freshest of dependencies")).start();

    var _await$Promise$all = await Promise.all([fetchLatestVersionsFor(pkg.dependencies), fetchLatestVersionsFor(pkg.devDependencies), getBlitzDependencyVersion(this.options.version)]),
        _await$Promise$all$ = _await$Promise$all[0],
        newDependencies = _await$Promise$all$.value,
        dependenciesUsedFallback = _await$Promise$all$.isFallback,
        _await$Promise$all$2 = _await$Promise$all[1],
        newDevDependencies = _await$Promise$all$2.value,
        devDependenciesUsedFallback = _await$Promise$all$2.isFallback,
        _await$Promise$all$3 = _await$Promise$all[2],
        blitzDependencyVersion = _await$Promise$all$3.value,
        blitzUsedFallback = _await$Promise$all$3.isFallback;

    pkg.dependencies = newDependencies;
    pkg.devDependencies = newDevDependencies;
    pkg.dependencies.blitz = blitzDependencyVersion;
    var fallbackUsed = dependenciesUsedFallback || devDependenciesUsedFallback || blitzUsedFallback;
    await fs.writeJson(pkgJsonLocation, pkg, {
      spaces: 2
    });

    if (!fallbackUsed && !this.options.skipInstall) {
      var _this$options$onPostI, _this$options;

      spinner.succeed();
      await new Promise(function (resolve) {
        var _cp$stdout, _cp$stderr, _cp$stdout2, _cp$stderr2;

        var logFlag = _this2.options.yarn ? "--json" : "--loglevel=error";
        var cp = spawn__default['default'](_this2.options.yarn ? "yarn" : "npm", ["install", logFlag], {
          stdio: ["inherit", "pipe", "pipe"]
        });

        var getJSON = function getJSON(data) {
          try {
            return JSON.parse(data);
          } catch (_unused) {
            return null;
          }
        };

        var spinners = [];

        if (!_this2.options.yarn) {
          var _spinner = display.log.spinner(display.log.withBrand("Installing those dependencies (this will take a few minutes)")).start();

          spinners.push(_spinner);
        }

        (_cp$stdout = cp.stdout) == null ? void 0 : _cp$stdout.setEncoding("utf8");
        (_cp$stderr = cp.stderr) == null ? void 0 : _cp$stderr.setEncoding("utf8");
        (_cp$stdout2 = cp.stdout) == null ? void 0 : _cp$stdout2.on("data", function (data) {
          if (_this2.options.yarn) {
            var json = getJSON(data);

            if (json && json.type === "step") {
              var _spinners;

              (_spinners = spinners[spinners.length - 1]) == null ? void 0 : _spinners.succeed();

              var _spinner2 = display.log.spinner(display.log.withBrand(json.data.message)).start();

              spinners.push(_spinner2);
            }

            if (json && json.type === "success") {
              var _spinners2;

              (_spinners2 = spinners[spinners.length - 1]) == null ? void 0 : _spinners2.succeed();
            }
          }
        });
        (_cp$stderr2 = cp.stderr) == null ? void 0 : _cp$stderr2.on("data", function (data) {
          if (_this2.options.yarn) {
            var json = getJSON(data);

            if (json && json.type === "error") {
              var _spinners3;

              (_spinners3 = spinners[spinners.length - 1]) == null ? void 0 : _spinners3.fail();
              console.error(json.data);
            }
          } else {
            // Hide the annoying Prisma warning about not finding the schema file
            // because we generate the client ourselves
            if (!data.includes("schema.prisma")) {
              console.error("\n" + data);
            }
          }
        });
        cp.on("exit", function (code) {
          if (!_this2.options.yarn && spinners[spinners.length - 1].isSpinning) {
            if (code !== 0) spinners[spinners.length - 1].fail();else {
              spinners[spinners.length - 1].succeed();
              _this2.packageInstallSuccess = true;
            }
          }

          resolve();
        });
      });
      await ((_this$options$onPostI = (_this$options = this.options).onPostInstall) == null ? void 0 : _this$options$onPostI.call(_this$options));

      var runLocalNodeCLI = function runLocalNodeCLI(command) {
        if (_this2.options.yarn) {
          return spawn__default['default'].sync("yarn", ["run"].concat(command.split(" ")));
        } else {
          return spawn__default['default'].sync("npx", command.split(" "));
        }
      }; // Ensure the generated files are formatted with the installed prettier version


      if (this.packageInstallSuccess) {
        var formattingSpinner = display.log.spinner(display.log.withBrand("Formatting your code")).start();
        var prettierResult = runLocalNodeCLI("prettier --loglevel silent --write .");

        if (prettierResult.status !== 0) {
          formattingSpinner.fail(chalk__default['default'].yellow.bold("We had an error running Prettier, but don't worry your app will still run fine :)"));
        } else {
          formattingSpinner.succeed();
        }
      }
    } else {
      console.log(""); // New line needed

      spinner.fail(chalk__default['default'].red.bold("We had some trouble connecting to the network, so we'll skip installing your dependencies right now. Make sure to run " + (this.options.yarn ? "'yarn'" : "'npm install'") + " once you're connected again."));
    }

    if (!this.options.skipGit && gitInitSuccessful) {
      this.commitChanges();
    }
  };

  _proto.preventFileFromLogging = function preventFileFromLogging(path) {
    if (path.includes(".env")) return false;
    if (path.includes("eslint")) return false;
    var filename = path.split("/").pop();
    return path[0] === "." || filename[0] === ".";
  };

  _proto.commitChanges = function commitChanges() {
    var commitSpinner = display.log.spinner(display.log.withBrand("Committing your app")).start();
    var commands = [["git", ["add", "."], {
      stdio: "ignore"
    }], ["git", ["-c", "user.name='Blitz.js CLI'", "-c", "user.email='noop@blitzjs.com'", "commit", "--no-gpg-sign", "--no-verify", "-m", "Brand new Blitz app!"], {
      stdio: "ignore",
      timeout: 10000
    }]];

    for (var _i = 0, _commands = commands; _i < _commands.length; _i++) {
      var command = _commands[_i];
      var result = spawn__default['default'].sync.apply(spawn__default['default'], command);

      if (result.status !== 0) {
        commitSpinner.fail(chalk__default['default'].red.bold("Failed to run command " + command[0] + " with " + command[1].join(" ") + " options."));
        return;
      }
    }

    commitSpinner.succeed();
  };

  return AppGenerator;
}(Generator);

function plural(input) {
  return pluralize__default['default'].isPlural(input) ? input : pluralize__default['default'].plural(input);
}
function singular(input) {
  return pluralize__default['default'].isSingular(input) ? input : pluralize__default['default'].singular(input);
}
function capitalize(input) {
  return "" + input.slice(0, 1).toUpperCase() + input.slice(1);
}
function uncapitalize(input) {
  return "" + input.slice(0, 1).toLowerCase() + input.slice(1);
}
var singlePascal = /*#__PURE__*/pipe(singular, capitalize);
var singleCamel = /*#__PURE__*/pipe(singular, uncapitalize);
var pluralPascal = /*#__PURE__*/pipe(plural, capitalize);
var pluralCamel = /*#__PURE__*/pipe(plural, uncapitalize);
function camelCaseToKebabCase(transformString) {
  return transformString.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase();
}

var FieldType;

(function (FieldType) {
  FieldType["Boolean"] = "Boolean";
  FieldType["DateTime"] = "DateTime";
  FieldType["Float"] = "Float";
  FieldType["Int"] = "Int";
  FieldType["Json"] = "Json";
  FieldType["String"] = "String";
})(FieldType || (FieldType = {}));

var Relation;

(function (Relation) {
  Relation[Relation["belongsTo"] = 0] = "belongsTo";
})(Relation || (Relation = {}));

function isRelation(maybeRelation) {
  return Object.keys(Relation).includes(maybeRelation);
}

var fallbackIfUndef = function fallbackIfUndef(defaultValue, input) {
  if (input === undefined) return defaultValue;
  return input;
};

var defaultValueTest = /=([\w]+)$/;
var builtInGenerators = ["autoincrement", "now", "uuid", "cuid"];

var MissingFieldNameError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(MissingFieldNameError, _Error);

  function MissingFieldNameError() {
    return _Error.apply(this, arguments) || this;
  }

  return MissingFieldNameError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var Field = /*#__PURE__*/function () {
  // 'name:type?[]:attribute' => Field
  Field.parse = function parse(input, schema) {
    var _input$split = input.split(":"),
        _fieldName = _input$split[0],
        _input$split$ = _input$split[1],
        _fieldType = _input$split$ === void 0 ? "String" : _input$split$,
        attribute = _input$split[2];

    var fieldName = uncapitalize(_fieldName);
    var fieldType = capitalize(_fieldType);
    var isId = fieldName === "id";
    var isRequired = true;
    var isList = false;
    var isUpdatedAt = false;
    var isUnique = false;
    var defaultValue = undefined;
    var relationFromFields = undefined;
    var relationToFields = undefined;
    var maybeIdField = undefined;

    if (fieldType.includes("?")) {
      fieldType = fieldType.replace("?", "");
      isRequired = false;
    }

    if (fieldType.includes("[]")) {
      fieldType = fieldType.replace("[]", "");
      fieldName = uncapitalize(fieldName);
      isList = true;
    } // use original unmodified field name in case the list handling code
    // has modified fieldName


    if (isRelation(_fieldName)) {
      // this field is an object type, not a scalar type
      var relationType = Relation[_fieldName]; // translate the type into the name since they should stay in sync

      fieldName = uncapitalize(fieldType);
      fieldType = singlePascal(fieldType);

      switch (relationType) {
        case Relation.belongsTo:
          // current model gets two fields:
          //   modelName    ModelName   @relation(fields: [modelNameId], references: [id])
          //   modelNameId  ModelIdType
          var idFieldName = fieldName + "Id";
          relationFromFields = [idFieldName];
          relationToFields = ["id"];
          var relationModel = schema == null ? void 0 : schema.list.find(function (component) {
            return component.type === "model" && component.name === fieldType;
          });
          var relationField = relationModel && relationModel.properties.find(function (prop) {
            return prop.type === "field" && prop.name === "id";
          });
          maybeIdField = new Field(idFieldName, {
            // find the matching field based on the relation and, if found, match its field type
            type: relationField ? relationField.fieldType : FieldType.Int,
            isRequired: isRequired
          });
          isList = false;
          break;
      }
    }

    if (!/^[A-Za-z][A-Za-z0-9_]*$/.test(fieldName)) {
      // modelName should be just alpha characters at this point, validate
      throw new Error("[Field.parse]: received unknown special character in field name: " + fieldName);
    }

    if (/unique/i.test(attribute)) isUnique = true;
    if (/updatedAt/i.test(attribute)) isUpdatedAt = true;

    if (/default/i.test(attribute)) {
      if (defaultValueTest.test(attribute)) {
        var _ref = attribute.match(defaultValueTest),
            _defaultValue = _ref[1];

        defaultValue = builtInGenerators.includes(_defaultValue) ? {
          type: "function",
          name: _defaultValue,
          params: []
        } : _defaultValue;
      }
    }

    try {
      var parseResult = new Field(fieldName, {
        "default": defaultValue,
        isId: isId,
        isList: isList,
        isRequired: isRequired,
        isUnique: isUnique,
        isUpdatedAt: isUpdatedAt,
        relationFromFields: relationFromFields,
        relationToFields: relationToFields,
        type: fieldType
      });
      return maybeIdField ? [parseResult, maybeIdField] : [parseResult];
    } catch (err) {
      if (err instanceof MissingFieldNameError) {
        throw new Error("Each field in a model must have a name, but you supplied " + display.log.variable(input) + ".\n         Try giving the field as a " + display.log.variable("name:type") + " pair, such as " + display.log.variable("description:string") + ".");
      }

      throw err;
    }
  };

  function Field(name, options) {
    this["default"] = void 0;
    this.name = void 0;
    this.isId = void 0;
    this.isList = void 0;
    this.isRequired = void 0;
    this.isUnique = void 0;
    this.isUpdatedAt = void 0;
    this.type = void 0;
    this.relationFromFields = void 0;
    this.relationToFields = void 0;
    if (!name) throw new MissingFieldNameError("[PrismaField]: A field name is required");

    if (!options.type) {
      display.log.warning("No field type specified for field " + display.log.variable(name) + ", falling back to " + display.log.variable("String") + ".");
      options.type = FieldType.String;
    }

    this.name = name;
    this.isList = fallbackIfUndef(false, options.isList);
    this.isRequired = fallbackIfUndef(true, options.isRequired);
    this.isUnique = fallbackIfUndef(false, options.isUnique);
    this.isId = fallbackIfUndef(false, options.isId);
    this.type = options.type;
    this["default"] = options["default"];
    this.isUpdatedAt = fallbackIfUndef(false, options.isUpdatedAt);
    this.relationFromFields = options.relationFromFields;
    this.relationToFields = options.relationToFields;

    if (!this.isRequired && this.isList) {
      throw new Error("[PrismaField]: a type cannot be both optional and a list");
    }

    if (this.isId && this["default"] === undefined) {
      throw new Error("[PrismaField]: ID fields must have a default value");
    }
  }

  var _proto = Field.prototype;

  _proto.appendTo = function appendTo(model) {
    var _this = this;

    if (model.properties.some(function (prop) {
      return prop.type === "field" && prop.name === _this.name;
    })) return;
    var attributes = [this.getId(), this.getIsUnique(), this.getDefault(), this.getIsUpdatedAt(), this.getRelation()].filter(Boolean);
    model.properties.push({
      type: "field",
      name: this.name,
      fieldType: this.type,
      optional: !this.isRequired,
      array: this.isList,
      attributes: attributes
    });
  };

  _proto.getDefault = function getDefault() {
    if (this["default"] == null) return;
    return {
      type: "attribute",
      kind: "field",
      name: "default",
      args: [{
        type: "attributeArgument",
        value: typeof this["default"] === "object" ? this["default"].name + "()" : String(this["default"])
      }]
    };
  };

  _proto.getId = function getId() {
    if (!this.isId) return;
    return {
      type: "attribute",
      kind: "field",
      name: "id"
    };
  };

  _proto.getIsUnique = function getIsUnique() {
    if (!this.isUnique) return;
    return {
      type: "attribute",
      kind: "field",
      name: "unique"
    };
  };

  _proto.getIsUpdatedAt = function getIsUpdatedAt() {
    if (!this.isUpdatedAt) return;
    return {
      type: "attribute",
      kind: "field",
      name: "updatedAt"
    };
  };

  _proto.getRelation = function getRelation() {
    if (this.relationFromFields == null || this.relationToFields == null) return;
    return {
      type: "attribute",
      kind: "field",
      name: "relation",
      args: [{
        type: "attributeArgument",
        value: {
          type: "keyValue",
          key: "fields",
          value: {
            type: "array",
            args: this.relationFromFields
          }
        }
      }, {
        type: "attributeArgument",
        value: {
          type: "keyValue",
          key: "references",
          value: {
            type: "array",
            args: this.relationToFields
          }
        }
      }]
    };
  };

  return Field;
}();

var Model = /*#__PURE__*/function () {
  function Model(name, fields) {
    if (fields === void 0) {
      fields = [];
    }

    this.name = void 0;
    this.fields = void 0;
    this.name = singlePascal(name);
    this.fields = fields;
  }

  var _proto = Model.prototype;

  _proto.appendTo = function appendTo(schema) {
    var model = this.createModelAst();
    schema.list.push(model);
    return model;
  };

  _proto.createModelAst = function createModelAst() {
    var properties = [this.getIdField(), this.getCreatedAtField(), this.getUpdatedAtField()].filter(Boolean);
    var model = {
      type: "model",
      name: this.name,
      properties: properties
    };

    for (var _iterator = _createForOfIteratorHelperLoose(this.fields), _step; !(_step = _iterator()).done;) {
      var field = _step.value;
      field.appendTo(model);
    }

    return model;
  };

  _proto.getIdField = function getIdField() {
    if (this.fieldExists("id")) return;
    return {
      type: "field",
      name: "id",
      fieldType: "Int",
      attributes: [{
        type: "attribute",
        kind: "field",
        name: "id"
      }, {
        type: "attribute",
        kind: "field",
        name: "default",
        args: [{
          type: "attributeArgument",
          value: {
            type: "function",
            name: "autoincrement",
            params: []
          }
        }]
      }]
    };
  };

  _proto.getCreatedAtField = function getCreatedAtField() {
    if (this.fieldExists("createdAt")) return;
    return {
      type: "field",
      name: "createdAt",
      fieldType: "DateTime",
      attributes: [{
        type: "attribute",
        kind: "field",
        name: "default",
        args: [{
          type: "attributeArgument",
          value: {
            type: "function",
            name: "now",
            params: []
          }
        }]
      }]
    };
  };

  _proto.getUpdatedAtField = function getUpdatedAtField() {
    if (this.fieldExists("updatedAt")) return;
    return {
      type: "field",
      name: "updatedAt",
      fieldType: "DateTime",
      attributes: [{
        type: "attribute",
        kind: "field",
        name: "updatedAt"
      }]
    };
  };

  _proto.fieldExists = function fieldExists(name) {
    return this.fields.some(function (field) {
      return field.name === name;
    });
  };

  _proto.toString = function toString() {
    return ast.printSchema({
      type: "schema",
      list: [this.createModelAst()]
    });
  };

  return Model;
}();

var ModelGenerator = /*#__PURE__*/function (_Generator) {
  _inheritsLoose(ModelGenerator, _Generator);

  function ModelGenerator() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Generator.call.apply(_Generator, [this].concat(args)) || this;
    _this.sourceRoot = {
      type: "absolute",
      path: ""
    };
    _this.unsafe_disableConflictChecker = true;
    return _this;
  }

  var _proto = ModelGenerator.prototype;

  _proto.getTemplateValues = async function getTemplateValues() {};

  _proto.getTargetDirectory = function getTargetDirectory() {
    return "";
  };

  _proto.prismaMigratePrompt = async function prismaMigratePrompt() {
    var response = await this.enquirer.prompt({
      name: "migrate",
      type: "confirm",
      message: "Run 'prisma migrate dev' to update your database?",
      initial: "y"
    });
    return response.migrate === true;
  } // eslint-disable-next-line require-await
  ;

  _proto.write = async function write() {
    var schemaPath = path__namespace['default'].resolve("db/schema.prisma");

    if (!this.fs.exists(schemaPath)) {
      throw new Error("Prisma schema file was not found");
    }

    var schema;

    try {
      schema = ast.getSchema(this.fs.read(schemaPath));
    } catch (err) {
      display.log.error("Failed to parse db/schema.prisma file");
      throw err;
    }

    var _this$options = this.options,
        modelName = _this$options.modelName,
        extraArgs = _this$options.extraArgs,
        dryRun = _this$options.dryRun;
    var updatedOrCreated = "created";
    var fields = (extraArgs.length === 1 && extraArgs[0].includes(" ") ? extraArgs[0].split(" ") : extraArgs).flatMap(function (input) {
      return Field.parse(input, schema);
    });
    var modelDefinition = new Model(modelName, fields);
    var model;

    if (!dryRun) {
      model = schema.list.find(function (component) {
        return component.type === "model" && component.name === modelDefinition.name;
      });

      try {
        if (model) {
          for (var _iterator = _createForOfIteratorHelperLoose(fields), _step; !(_step = _iterator()).done;) {
            var field = _step.value;
            field.appendTo(model);
          }

          this.fs.write(schemaPath, ast.printSchema(schema));
          updatedOrCreated = "updated";
        } else {
          model = modelDefinition.appendTo(schema);
          this.fs.write(schemaPath, ast.printSchema(schema));
        }
      } catch (err) {
        console.error("Failed to apply changes to model '" + modelDefinition.name + "'");
        throw err;
      }
    }

    if (model) {
      display.log.newline();
      display.log.success("Model '" + modelDefinition.name + "'" + (dryRun ? "" : " " + updatedOrCreated + " in schema.prisma") + ":\n");
      ast.printSchema({
        type: "schema",
        list: [model]
      }).split("\n").map(display.log.progress);
      display.log.newline();
    }
  };

  _proto.postWrite = async function postWrite() {
    var shouldMigrate = await this.prismaMigratePrompt();

    if (shouldMigrate) {
      await new Promise(function (res, rej) {
        var prismaBin = which__default['default'](process.cwd()).sync("prisma");
        var child = spawn.spawn(prismaBin, ["migrate", "dev"], {
          stdio: "inherit"
        });
        child.on("exit", function (code) {
          return code === 0 ? res() : rej();
        });
      });
    }
  };

  return ModelGenerator;
}(Generator);
ModelGenerator.subdirectory = "../..";

var MutationsGenerator = /*#__PURE__*/function (_Generator) {
  _inheritsLoose(MutationsGenerator, _Generator);

  function MutationsGenerator() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Generator.call.apply(_Generator, [this].concat(args)) || this;
    _this.sourceRoot = {
      type: "template",
      path: "mutations"
    };
    return _this;
  }

  var _proto = MutationsGenerator.prototype;

  _proto.getId = function getId(input) {
    if (input === void 0) {
      input = "";
    }

    if (!input) return input;
    return input + "Id";
  };

  _proto.getParam = function getParam(input) {
    if (input === void 0) {
      input = "";
    }

    if (!input) return input;
    return "[" + input + "]";
  } // eslint-disable-next-line require-await
  ;

  _proto.getTemplateValues = async function getTemplateValues() {
    return {
      parentModelId: this.getId(this.options.parentModel),
      parentModelParam: this.getParam(this.getId(this.options.parentModel)),
      parentModel: this.options.parentModel,
      parentModels: this.options.parentModels,
      ParentModel: this.options.ParentModel,
      ParentModels: this.options.ParentModels,
      modelId: this.getId(this.options.modelName),
      modelIdParam: this.getParam(this.getId(this.options.modelName)),
      modelName: this.options.modelName,
      modelNames: this.options.modelNames,
      ModelName: this.options.ModelName,
      ModelNames: this.options.ModelNames
    };
  };

  _proto.getTargetDirectory = function getTargetDirectory() {
    var context = this.options.context ? camelCaseToKebabCase(this.options.context) + "/" : "";
    var kebabCaseModelName = camelCaseToKebabCase(this.options.modelNames);
    return "app/" + context + kebabCaseModelName + "/mutations";
  };

  return MutationsGenerator;
}(Generator);
MutationsGenerator.subdirectory = "mutations";

var MutationGenerator = /*#__PURE__*/function (_Generator) {
  _inheritsLoose(MutationGenerator, _Generator);

  function MutationGenerator() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Generator.call.apply(_Generator, [this].concat(args)) || this;
    _this.sourceRoot = {
      type: "template",
      path: "mutation"
    };
    return _this;
  }

  var _proto = MutationGenerator.prototype;

  // eslint-disable-next-line require-await
  _proto.getTemplateValues = async function getTemplateValues() {
    return {
      name: this.options.name,
      Name: this.options.Name
    };
  };

  _proto.getTargetDirectory = function getTargetDirectory() {
    var context = this.options.context ? "" + camelCaseToKebabCase(this.options.context) : "";
    return "app/" + context + "/mutations";
  };

  return MutationGenerator;
}(Generator);
MutationGenerator.subdirectory = "mutation";

var PageGenerator = /*#__PURE__*/function (_Generator) {
  _inheritsLoose(PageGenerator, _Generator);

  function PageGenerator() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Generator.call.apply(_Generator, [this].concat(args)) || this;
    _this.sourceRoot = {
      type: "template",
      path: "page"
    };
    return _this;
  }

  var _proto = PageGenerator.prototype;

  _proto.getId = function getId(input) {
    if (input === void 0) {
      input = "";
    }

    if (!input) return input;
    return input + "Id";
  };

  _proto.getParam = function getParam(input) {
    if (input === void 0) {
      input = "";
    }

    if (!input) return input;
    return "[" + input + "]";
  } // eslint-disable-next-line require-await
  ;

  _proto.getTemplateValues = async function getTemplateValues() {
    return {
      parentModelId: this.getId(this.options.parentModel),
      parentModelParam: this.getParam(this.getId(this.options.parentModel)),
      parentModel: this.options.parentModel,
      parentModels: this.options.parentModels,
      ParentModel: this.options.ParentModel,
      ParentModels: this.options.ParentModels,
      modelId: this.getId(this.options.modelName),
      modelIdParam: this.getParam(this.getId(this.options.modelName)),
      modelName: this.options.modelName,
      modelNames: this.options.modelNames,
      ModelName: this.options.ModelName,
      ModelNames: this.options.ModelNames,
      modelNamesPath: this.getModelNamesPath()
    };
  };

  _proto.getModelNamesPath = function getModelNamesPath() {
    var kebabCaseContext = this.options.context ? camelCaseToKebabCase(this.options.context) + "/" : "";
    var kebabCaseModelNames = camelCaseToKebabCase(this.options.modelNames);
    return kebabCaseContext + kebabCaseModelNames;
  };

  _proto.getTargetDirectory = function getTargetDirectory() {
    var kebabCaseModelName = camelCaseToKebabCase(this.options.modelNames);
    var parent = this.options.parentModels ? this.options.parentModels + "/__parentModelParam__/" : "";
    return "app/pages/" + parent + kebabCaseModelName;
  };

  return PageGenerator;
}(Generator);
PageGenerator.subdirectory = "pages";

var QueriesGenerator = /*#__PURE__*/function (_Generator) {
  _inheritsLoose(QueriesGenerator, _Generator);

  function QueriesGenerator() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Generator.call.apply(_Generator, [this].concat(args)) || this;
    _this.sourceRoot = {
      type: "template",
      path: "queries"
    };
    return _this;
  }

  var _proto = QueriesGenerator.prototype;

  _proto.getId = function getId(input) {
    if (input === void 0) {
      input = "";
    }

    if (!input) return input;
    return input + "Id";
  };

  _proto.getParam = function getParam(input) {
    if (input === void 0) {
      input = "";
    }

    if (!input) return input;
    return "[" + input + "]";
  } // eslint-disable-next-line require-await
  ;

  _proto.getTemplateValues = async function getTemplateValues() {
    return {
      parentModelId: this.getId(this.options.parentModel),
      parentModelParam: this.getParam(this.getId(this.options.parentModel)),
      parentModel: this.options.parentModel,
      parentModels: this.options.parentModels,
      ParentModel: this.options.ParentModel,
      ParentModels: this.options.ParentModels,
      modelId: this.getId(this.options.modelName),
      modelIdParam: this.getParam(this.getId(this.options.modelName)),
      modelName: this.options.modelName,
      modelNames: this.options.modelNames,
      ModelName: this.options.ModelName,
      ModelNames: this.options.ModelNames
    };
  };

  _proto.getTargetDirectory = function getTargetDirectory() {
    var context = this.options.context ? camelCaseToKebabCase(this.options.context) + "/" : "";
    var kebabCaseModelName = camelCaseToKebabCase(this.options.modelNames);
    return "app/" + context + kebabCaseModelName + "/queries";
  };

  return QueriesGenerator;
}(Generator);
QueriesGenerator.subdirectory = "queries";

var QueryGenerator = /*#__PURE__*/function (_Generator) {
  _inheritsLoose(QueryGenerator, _Generator);

  function QueryGenerator() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Generator.call.apply(_Generator, [this].concat(args)) || this;
    _this.sourceRoot = {
      type: "template",
      path: "query"
    };
    return _this;
  }

  var _proto = QueryGenerator.prototype;

  // eslint-disable-next-line require-await
  _proto.getTemplateValues = async function getTemplateValues() {
    return {
      name: this.options.name,
      Name: this.options.Name
    };
  };

  _proto.getTargetDirectory = function getTargetDirectory() {
    var context = this.options.context ? "" + camelCaseToKebabCase(this.options.context) : "";
    return "app/" + context + "/queries";
  };

  return QueryGenerator;
}(Generator);
QueryGenerator.subdirectory = "query";

var FormGenerator = /*#__PURE__*/function (_Generator) {
  _inheritsLoose(FormGenerator, _Generator);

  function FormGenerator() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Generator.call.apply(_Generator, [this].concat(args)) || this;
    _this.sourceRoot = {
      type: "template",
      path: "form"
    };
    return _this;
  }

  var _proto = FormGenerator.prototype;

  _proto.getId = function getId(input) {
    if (input === void 0) {
      input = "";
    }

    if (!input) return input;
    return input + "Id";
  };

  _proto.getParam = function getParam(input) {
    if (input === void 0) {
      input = "";
    }

    if (!input) return input;
    return "[" + input + "]";
  } // eslint-disable-next-line require-await
  ;

  _proto.getTemplateValues = async function getTemplateValues() {
    return {
      parentModelId: this.getId(this.options.parentModel),
      parentModelParam: this.getParam(this.getId(this.options.parentModel)),
      parentModel: this.options.parentModel,
      parentModels: this.options.parentModels,
      ParentModel: this.options.ParentModel,
      ParentModels: this.options.ParentModels,
      modelId: this.getId(this.options.modelName),
      modelIdParam: this.getParam(this.getId(this.options.modelName)),
      modelName: this.options.modelName,
      modelNames: this.options.modelNames,
      ModelName: this.options.ModelName,
      ModelNames: this.options.ModelNames
    };
  };

  _proto.getTargetDirectory = function getTargetDirectory() {
    var context = this.options.context ? camelCaseToKebabCase(this.options.context) + "/" : "";
    var kebabCaseModelName = camelCaseToKebabCase(this.options.modelNames);
    return "app/" + context + kebabCaseModelName + "/components";
  };

  return FormGenerator;
}(Generator);
FormGenerator.subdirectory = "queries";

exports.AppGenerator = AppGenerator;
exports.ConflictChecker = ConflictChecker;
exports.FormGenerator = FormGenerator;
exports.Generator = Generator;
exports.ModelGenerator = ModelGenerator;
exports.MutationGenerator = MutationGenerator;
exports.MutationsGenerator = MutationsGenerator;
exports.PageGenerator = PageGenerator;
exports.QueriesGenerator = QueriesGenerator;
exports.QueryGenerator = QueryGenerator;
exports.capitalize = capitalize;
exports.customTsParser = customTsParser;
exports.getLatestVersion = getLatestVersion;
exports.pluralCamel = pluralCamel;
exports.pluralPascal = pluralPascal;
exports.singleCamel = singleCamel;
exports.singlePascal = singlePascal;
exports.uncapitalize = uncapitalize;
