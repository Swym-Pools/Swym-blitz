/// <reference types="node" />
import * as babel from "@babel/core";
import Enquirer from "enquirer";
import { EventEmitter } from "events";
import { Editor } from "mem-fs-editor";
export declare const customTsParser: {
    parse(source: string, options?: Partial<{
        sourceType: "script" | "module" | "unambiguous" | undefined;
        strictMode: boolean | undefined;
    }> | undefined): babel.types.File;
};
export interface GeneratorOptions {
    context?: string;
    destinationRoot?: string;
    dryRun?: boolean;
    useTs?: boolean;
}
export interface SourceRootType {
    type: "template" | "absolute";
    path: string;
}
/**
 * The base generator class.
 * Every generator must extend this class.
 */
export declare abstract class Generator<T extends GeneratorOptions = GeneratorOptions> extends EventEmitter {
    protected readonly options: T;
    private readonly store;
    protected readonly fs: Editor;
    protected readonly enquirer: Enquirer;
    private performedActions;
    private useTs;
    private prettier;
    prettierDisabled: boolean;
    unsafe_disableConflictChecker: boolean;
    returnResults: boolean;
    /**
     * When `type: 'absolute'`, it's an absolute path
     * When `type: 'template'`, is the path type `templates/`.
     *
     * @example {type: 'absolue', path: './src/app'} => `./src/app`
     * @example {type: 'template', path: 'app'} => `templates/app`
     */
    abstract sourceRoot: SourceRootType;
    constructor(options: T);
    abstract getTemplateValues(): Promise<any>;
    abstract getTargetDirectory(): string;
    filesToIgnore(): string[];
    replaceConditionals(input: string, templateValues: any, prettierOptions?: import("prettier").Options): string;
    replaceTemplateValues(input: string, templateValues: any): string;
    process(input: Buffer, pathEnding: string, templateValues: any, prettierOptions: import("prettier").Options | undefined): string | Buffer;
    write(): Promise<void>;
    preCommit(): Promise<void>;
    postWrite(): Promise<void>;
    preventFileFromLogging(_path: string): boolean;
    sourcePath(...paths: string[]): string;
    destinationPath(...paths: string[]): string;
    run(): Promise<string | void>;
}
