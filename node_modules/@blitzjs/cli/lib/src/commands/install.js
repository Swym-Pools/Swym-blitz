"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Install = exports.RecipeLocation = void 0;
const tslib_1 = require("tslib");
const config_1 = require("@blitzjs/config");
const display_1 = require("@blitzjs/display");
const command_1 = require("@oclif/command");
const global_agent_1 = require("global-agent");
const stream_1 = require("stream");
const util_1 = require("util");
const command_2 = require("../command");
const pipeline = util_1.promisify(stream_1.Stream.pipeline);
function got(url) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return require("got")(url).catch((e) => e);
    });
}
function gotJSON(url) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return JSON.parse((yield got(url)).body);
    });
}
function isUrlValid(url) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return (yield got(url).catch((e) => e)).statusCode === 200;
    });
}
function requireJSON(file) {
    return JSON.parse(require("fs-extra").readFileSync(file).toString("utf-8"));
}
const GH_ROOT = "https://github.com/";
const API_ROOT = "https://api.github.com/repos/";
const CODE_ROOT = "https://codeload.github.com/";
var RecipeLocation;
(function (RecipeLocation) {
    RecipeLocation[RecipeLocation["Local"] = 0] = "Local";
    RecipeLocation[RecipeLocation["Remote"] = 1] = "Remote";
})(RecipeLocation = exports.RecipeLocation || (exports.RecipeLocation = {}));
class Install extends command_2.Command {
    // exposed for testing
    normalizeRecipePath(recipeArg) {
        const isNavtiveRecipe = /^([\w\-_]*)$/.test(recipeArg);
        const isUrlRecipe = recipeArg.startsWith(GH_ROOT);
        const isGitHubShorthandRecipe = /^([\w-_]*)\/([\w-_]*)$/.test(recipeArg);
        if (isNavtiveRecipe || isUrlRecipe || isGitHubShorthandRecipe) {
            let repoUrl;
            let subdirectory;
            switch (true) {
                case isUrlRecipe:
                    repoUrl = recipeArg;
                    break;
                case isNavtiveRecipe:
                    repoUrl = `${GH_ROOT}blitz-js/blitz`;
                    subdirectory = `recipes/${recipeArg}`;
                    break;
                case isGitHubShorthandRecipe:
                    repoUrl = `${GH_ROOT}${recipeArg}`;
                    break;
                default:
                    throw new Error("should be impossible, the 3 cases are the only way to get into this switch");
            }
            return {
                path: repoUrl,
                subdirectory,
                location: RecipeLocation.Remote,
            };
        }
        else {
            return {
                path: recipeArg,
                location: RecipeLocation.Local,
            };
        }
    }
    /**
     * Clones the repository into a temp directory, returning the path to the new directory
     *
     * Exposed for unit testing
     *
     * @param repoFullName username and repository name in the form {{user}}/{{repo}}
     * @param defaultBranch the name of the repository's default branch
     */
    cloneRepo(repoFullName, defaultBranch, subdirectory) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const recipeDir = require("path").join(require("os").tmpdir(), `blitz-recipe-${repoFullName.replace("/", "-")}`);
            // clean up from previous run in case of error
            require("rimraf").sync(recipeDir);
            require("fs-extra").mkdirSync(recipeDir);
            process.chdir(recipeDir);
            const repoName = repoFullName.split("/")[1];
            // `tar` top-level filter is `${repoName}-${defaultBranch}`, and then we want to get our recipe path
            // within that folder
            const extractPath = subdirectory ? [`${repoName}-${defaultBranch}/${subdirectory}`] : undefined;
            const depth = subdirectory ? subdirectory.split("/").length + 1 : 1;
            yield pipeline(require("got").stream(`${CODE_ROOT}${repoFullName}/tar.gz/${defaultBranch}`), require("tar").extract({ strip: depth }, extractPath));
            return recipeDir;
        });
    }
    installRecipeAtPath(recipePath) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const recipe = require(recipePath).default;
            const recipeArgs = this.argv.slice(1).reduce((acc, arg) => (Object.assign(Object.assign({}, acc), { [arg.split("=")[0].replace(/--/g, "")]: arg.split("=")[1]
                    ? JSON.parse(`"${arg.split("=")[1]}"`)
                    : true })), {});
            yield recipe.run(recipeArgs);
        });
    }
    /**
     * Setup proxy support for blitz install
     *
     * Loads proxy variables from enviroment and blitz.config.js
     *
     */
    setupProxySupport() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const cli = config_1.getConfig().cli;
            const httpProxy = (cli === null || cli === void 0 ? void 0 : cli.httpProxy) || process.env.http_proxy || process.env.HTTP_PROXY;
            const httpsProxy = (cli === null || cli === void 0 ? void 0 : cli.httpsProxy) || process.env.https_proxy || process.env.HTTPS_PROXY;
            const noProxy = (cli === null || cli === void 0 ? void 0 : cli.noProxy) || process.env.no_proxy || process.env.NO_PROXY;
            if (httpProxy || httpsProxy) {
                global.GLOBAL_AGENT = {
                    HTTP_PROXY: httpProxy,
                    HTTPS_PROXY: httpsProxy,
                    NO_PROXY: noProxy,
                };
                global_agent_1.bootstrap();
            }
        });
    }
    run() {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.parse(Install);
            require("../utils/setup-ts-node").setupTsnode();
            yield this.setupProxySupport();
            const { args } = this.parse(Install);
            const pkgManager = require("fs-extra").existsSync(require("path").resolve("yarn.lock"))
                ? "yarn"
                : "npm";
            const originalCwd = process.cwd();
            const recipeInfo = this.normalizeRecipePath(args.recipe);
            const chalk = (yield Promise.resolve().then(() => tslib_1.__importStar(require("chalk")))).default;
            if (recipeInfo.location === RecipeLocation.Remote) {
                const apiUrl = recipeInfo.path.replace(GH_ROOT, API_ROOT);
                const packageJsonPath = require("path").join(`${apiUrl}/contents`, (_a = recipeInfo.subdirectory) !== null && _a !== void 0 ? _a : "", "package.json");
                if (!(yield isUrlValid(packageJsonPath))) {
                    display_1.log.error(`Could not find recipe "${args.recipe}"\n`);
                    console.log(`${chalk.bold("Please provide one of the following:")}

1. The name of a recipe to install (e.g. "tailwind")
   ${chalk.dim("- Available recipes listed at https://github.com/blitz-js/blitz/tree/canary/recipes")}
2. The full name of a GitHub repository (e.g. "blitz-js/example-recipe"),
3. A full URL to a Github repository (e.g. "https://github.com/blitz-js/example-recipe"), or
4. A file path to a locally-written recipe.\n`);
                    process.exit(1);
                }
                else {
                    const repoInfo = yield gotJSON(apiUrl);
                    let spinner = display_1.log.spinner(`Cloning GitHub repository for ${args.recipe} recipe`).start();
                    const recipeRepoPath = yield this.cloneRepo(repoInfo.full_name, repoInfo.default_branch, recipeInfo.subdirectory);
                    spinner.stop();
                    spinner = display_1.log.spinner("Installing package.json dependencies").start();
                    yield new Promise((resolve) => {
                        const installProcess = require("cross-spawn")(pkgManager, ["install"]);
                        installProcess.on("exit", resolve);
                    });
                    spinner.stop();
                    const recipePackageMain = requireJSON("./package.json").main;
                    const recipeEntry = require("path").resolve(recipePackageMain);
                    process.chdir(originalCwd);
                    yield this.installRecipeAtPath(recipeEntry);
                    require("rimraf").sync(recipeRepoPath);
                }
            }
            else {
                yield this.installRecipeAtPath(require("path").resolve(args.recipe));
            }
        });
    }
}
exports.Install = Install;
Install.description = "Install a Recipe into your Blitz app";
Install.aliases = ["i"];
Install.strict = false;
Install.flags = {
    help: command_1.flags.help({ char: "h" }),
};
Install.args = [
    {
        name: "recipe",
        required: true,
        description: "Name of a Blitz recipe from @blitzjs/blitz/recipes, or a file path to a local recipe definition",
    },
    {
        name: "recipe-flags",
        description: "A list of flags to pass to the recipe. Blitz will only parse these in the form key=value",
    },
];
