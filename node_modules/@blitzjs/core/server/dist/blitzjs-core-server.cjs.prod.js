'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var constants = require('../../dist/constants-a47ef47f.cjs.prod.js');
var config = require('@blitzjs/config');
var display = require('@blitzjs/display');
var _extends = require('../../dist/extends-f26277ce.cjs.prod.js');
var b64Lite = require('b64-lite');
var cookie = require('cookie');
var jsonwebtoken = require('jsonwebtoken');
var apiUtils = require('next/dist/next-server/server/api-utils');
var path = require('path');
var crypto = require('crypto');
var nanoid = require('nanoid');
var SecurePasswordLib = require('secure-password');
var cookieSession = require('cookie-session');
var passport = require('passport');
var chalk = require('chalk');
var SuperJson = require('superjson');
require('../../dist/blitz-data-d800ac04.cjs.prod.js');
require('htmlescape');
require('react');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var cookie__default = /*#__PURE__*/_interopDefault(cookie);
var SecurePasswordLib__default = /*#__PURE__*/_interopDefault(SecurePasswordLib);
var cookieSession__default = /*#__PURE__*/_interopDefault(cookieSession);
var passport__default = /*#__PURE__*/_interopDefault(passport);
var chalk__default = /*#__PURE__*/_interopDefault(chalk);

var debug$1 = /*#__PURE__*/require("debug")("blitz:middleware");

function getAllMiddlewareForModule(resolverModule) {
  var middleware = [];
  var config$1 = config.getConfig();

  if (config$1.middleware) {
    if (!Array.isArray(config$1.middleware)) {
      throw new Error("'middleware' in blitz.config.js must be an array");
    }

    middleware.push.apply(middleware, config$1.middleware);
  }

  if (resolverModule.middleware) {
    if (!Array.isArray(resolverModule.middleware)) {
      throw new Error("'middleware' exported from " + resolverModule._meta.name + " must be an array");
    }

    middleware.push.apply(middleware, resolverModule.middleware);
  }

  return middleware;
}
async function handleRequestWithMiddleware(req, res, middleware, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$throwOnError = _ref.throwOnError,
      throwOnError = _ref$throwOnError === void 0 ? true : _ref$throwOnError,
      _ref$stackPrintOnErro = _ref.stackPrintOnError,
      stackPrintOnError = _ref$stackPrintOnErro === void 0 ? true : _ref$stackPrintOnErro;

  if (!res.blitzCtx) {
    res.blitzCtx = {};
  }

  if (!res._blitz) {
    res._blitz = {};
  }

  var handler;

  if (Array.isArray(middleware)) {
    handler = compose(middleware);
  } else {
    handler = middleware;
  }

  try {
    await handler(req, res, function (error) {
      if (error) {
        throw error;
      }
    });
  } catch (error) {
    display.log.newline();

    if (req.method === "GET") {
      // This GET method check is so we don't .end() the request for SSR requests
      display.baseLogger().error("Error while processing the request");
    } else if (res.writableFinished) {
      display.baseLogger().error("Error occured in middleware after the response was already sent to the browser");
    } else {
      res.statusCode = error.statusCode || error.status || 500;
      res.end(error.message || res.statusCode.toString());
      display.baseLogger().error("Error while processing the request");
    }

    if (error._clearStack) {
      delete error.stack;
    }

    if (stackPrintOnError) {
      display.baseLogger().prettyError(error);
    } else {
      display.baseLogger().prettyError(error, true, false, false);
    }

    display.log.newline();
    if (throwOnError) throw error;
  }
} // -------------------------------------------------------------------------------
// This takes an array of middleware and composes them into a single middleware fn
// This is what makes `next()` and `await next()` work
// -------------------------------------------------------------------------------

function compose(middleware) {
  if (!Array.isArray(middleware)) {
    throw new TypeError("Middleware stack must be an array!");
  }

  for (var _iterator = constants._createForOfIteratorHelperLoose(middleware), _step; !(_step = _iterator()).done;) {
    var handler = _step.value;

    if (typeof handler !== "function") {
      throw new TypeError("Middleware must be composed of functions!");
    }
  } // Return a single middleware function that composes everything passed in


  return function (req, res, next) {
    // last called middleware #
    var index = -1;

    function dispatch(i, error) {
      if (error) {
        return Promise.reject(error);
      }

      if (i <= index) throw new Error("next() called multiple times");
      index = i;
      var handler = middleware[i];

      if (!handler) {
        return Promise.resolve();
      }

      try {
        debug$1("[" + handler.name + "] Starting handler...");
        return Promise.resolve(handler(req, res, dispatch.bind(null, i + 1)));
      } catch (error) {
        return Promise.reject(error);
      }
    } // const result = await dispatch(0)
    // return next(result as any)


    return dispatch(0).then(next);
  };
}
/**
 * If the middleware function doesn't declare receiving the `next` callback
 * assume that it's synchronous and invoke `next` ourselves
 */

function noCallbackHandler(req, res, next, middleware) {
  middleware(req, res);
  return next();
}
/**
 * The middleware function does include the `next` callback so only resolve
 * the Promise when it's called. If it's never called, the middleware stack
 * completion will stall
 */


function withCallbackHandler(req, res, next, middleware) {
  return new Promise(function (resolve, reject) {
    // Rule doesn't matter since we are inside new Promise()
    //eslint-disable-next-line @typescript-eslint/no-floating-promises
    middleware(req, res, function (err) {
      if (err) reject(err);else resolve(next());
    });
  });
}
/**
 * Returns a Blitz middleware function that varies its async logic based on if the
 * given middleware function declares at least 3 parameters, i.e. includes
 * the `next` callback function
 */


function connectMiddleware(middleware) {
  var handler = middleware.length < 3 ? noCallbackHandler : withCallbackHandler;
  return function connectHandler(req, res, next) {
    return handler(req, res, next, middleware);
  };
}

function round(num, decimalPlaces) {
  var p = Math.pow(10, decimalPlaces);
  var m = num * p * (1 + Number.EPSILON);
  return Math.round(m) / p;
}
/**
 * Formats milliseconds to a string
 * If more than 1s, it'll return seconds instead
 * @example
 * prettyMs(100) // -> `100ms`
 * prettyMs(1200) // -> `1.2s`
 * @param ms
 */


function prettyMs(ms) {
  if (Math.abs(ms) >= 1000) {
    return round(ms / 1000, 1) + "s";
  }

  return ms + "ms";
}

async function invokeWithMiddleware(resolver, params, ctx) {
  if (!ctx.req) {
    throw new Error("You must provide `req` in third argument of invokeWithMiddleware()");
  }

  if (!ctx.res) {
    throw new Error("You must provide `res` in third argument of invokeWithMiddleware()");
  }

  var enhancedResolver = resolver;
  var middleware = getAllMiddlewareForModule(enhancedResolver);

  if (ctx.middleware) {
    middleware.push.apply(middleware, ctx.middleware);
  }

  middleware.push(async function (_req, res, next) {
    var log = display.baseLogger().getChildLogger({
      prefix: [enhancedResolver._meta.name + "()"]
    });
    display.log.newline();

    try {
      log.info(display.chalk.dim("Starting with input:"), params);
      var startTime = Date.now();
      var result = await enhancedResolver(params, res.blitzCtx);
      var duration = Date.now() - startTime;
      log.info(display.chalk.dim("Finished in " + prettyMs(duration)));
      display.log.newline();
      res.blitzResult = result;
      return next();
    } catch (error) {
      throw error;
    }
  });
  await handleRequestWithMiddleware(ctx.req, ctx.res, middleware);
  return ctx.res.blitzResult;
}

function isLocalhost(req) {
  var host = req.headers.host;
  var localhost = false;

  if (host) {
    host = host.split(":")[0];
    localhost = host === "localhost";
  }

  return localhost;
}

var isInteger = function isInteger(value) {
  return typeof value === "number" && value % 1 === 0;
};

async function paginate(_ref) {
  var _ref$skip = _ref.skip,
      skip = _ref$skip === void 0 ? 0 : _ref$skip,
      _ref$take = _ref.take,
      take = _ref$take === void 0 ? 0 : _ref$take,
      _ref$maxTake = _ref.maxTake,
      maxTake = _ref$maxTake === void 0 ? 250 : _ref$maxTake,
      countQuery = _ref.count,
      query = _ref.query;

  if (!isInteger(skip)) {
    throw new constants.PaginationArgumentError("`skip` argument must be a integer");
  }

  if (!isInteger(take)) {
    throw new constants.PaginationArgumentError("`take` argument must be a integer");
  }

  if (!isInteger(maxTake)) {
    throw new constants.PaginationArgumentError("`maxTake` argument must be a integer");
  }

  if (typeof countQuery !== "function") {
    throw new constants.PaginationArgumentError("`count` argument must be a function");
  }

  if (typeof query !== "function") {
    throw new constants.PaginationArgumentError("`query` argument must be a function");
  }

  if (skip < 0) {
    throw new constants.PaginationArgumentError("`skip` argument must be a positive number");
  }

  if (take < 0) {
    throw new constants.PaginationArgumentError("`take` argument must be a positive number");
  }

  if (take > maxTake) {
    throw new constants.PaginationArgumentError("`take` argument must less than `maxTake` which is currently " + maxTake);
  }

  var _await$Promise$all = await Promise.all([countQuery(), query({
    skip: skip,
    take: take
  })]),
      count = _await$Promise$all[0],
      items = _await$Promise$all[1];

  var hasMore = skip + take < count;
  var nextPage = hasMore ? {
    take: take,
    skip: skip + take
  } : null;
  return {
    items: items,
    nextPage: nextPage,
    hasMore: hasMore,
    count: count
  };
}

function isResultWithContext(x) {
  return typeof x === "object" && x !== null && "ctx" in x && x.__blitz === true;
}

function pipe() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var functions = args;
  return async function (input, ctx) {
    var lastResult = input;

    for (var _iterator = constants._createForOfIteratorHelperLoose(functions), _step; !(_step = _iterator()).done;) {
      var fn = _step.value;
      lastResult = await fn(lastResult, ctx);

      if (isResultWithContext(lastResult)) {
        ctx = lastResult.ctx;
        lastResult = lastResult.value;
      }
    }

    return lastResult;
  };
}

var authorize = function authorize() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return function _innerAuthorize(input, ctx) {
    var session = ctx.session;
    session.$authorize.apply(session, args);
    return {
      __blitz: true,
      value: input,
      // we could use {...ctx, session} instead of `as any` just for TypeScript's sake
      ctx: ctx
    };
  };
};

var resolver = {
  pipe: pipe,
  zod: function zod(schema) {
    return function (input) {
      return schema.parse(input);
    };
  },
  authorize: authorize
};

var MILLISECONDS_IN_MINUTE = 60000;
var MINUTES_IN_YEAR = 525960;
var isPast = function isPast(date) {
  return date.getTime() < Date.now();
};
function differenceInMilliseconds(dateLeft, dateRight) {
  return dateLeft.getTime() - dateRight.getTime();
}
function differenceInMinutes(dateLeft, dateRight) {
  var diff = differenceInMilliseconds(dateLeft, dateRight) / MILLISECONDS_IN_MINUTE;
  return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
}
function addMilliseconds(date, amount) {
  var timestamp = date.getTime();
  var cleanAmount = toInteger(amount);
  return new Date(timestamp + cleanAmount);
}
function addMinutes(date, amount) {
  var cleanAmount = toInteger(amount);
  return addMilliseconds(date, cleanAmount * MILLISECONDS_IN_MINUTE);
}
function addYears(date, amount) {
  var cleanAmount = toInteger(amount);
  return addMinutes(date, cleanAmount * MINUTES_IN_YEAR);
}
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }

  var number = Number(dirtyNumber);

  if (isNaN(number)) {
    return number;
  }

  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

var hash256 = function hash256(input) {
  if (input === void 0) {
    input = "";
  }

  return crypto.createHash("sha256").update(input).digest("hex");
};
var generateToken = function generateToken(numberOfCharacters) {
  if (numberOfCharacters === void 0) {
    numberOfCharacters = 32;
  }

  return nanoid.nanoid(numberOfCharacters);
};

var SP = function SP() {
  return new SecurePasswordLib__default['default']();
};

var SecurePassword = /*#__PURE__*/_extends._extends({}, SecurePasswordLib__default['default'], {
  hash: async function hash(password) {
    if (!password) {
      throw new constants.AuthenticationError();
    }

    var hashedBuffer = await SP().hash(Buffer.from(password));
    return hashedBuffer.toString("base64");
  },
  verify: async function verify(hashedPassword, password) {
    if (!hashedPassword || !password) {
      throw new constants.AuthenticationError();
    }

    try {
      var result = await SP().verify(Buffer.from(password), Buffer.from(hashedPassword, "base64")); // Return result for valid results.

      switch (result) {
        case SecurePassword.VALID:
        case SecurePassword.VALID_NEEDS_REHASH:
          return result;
      } // For everything else throw AuthenticationError


      throw new constants.AuthenticationError();
    } catch (error) {
      // Could be error like failed to hash password
      throw new constants.AuthenticationError();
    }
  }
});

var debug = /*#__PURE__*/require("debug")("blitz:session");

function assert$1(condition, message) {
  if (!condition) throw new Error(message);
} // ----------------------------------------------------------------------------------------
// IMPORTANT: blitz.config.js must be loaded for session management config to be initialized
// This line ensures that blitz.config.js is loaded
// ----------------------------------------------------------------------------------------


process.nextTick(config.getConfig);

var getDb = function getDb() {
  var projectRoot = config.getProjectRoot();
  var path$1 = path.join(projectRoot, ".next/blitz/db.js"); // eslint-disable-next-line no-eval -- block webpack from following this module path

  return eval("require")(path$1)["default"];
};

var defaultConfig = {
  sessionExpiryMinutes: 30 * 24 * 60,
  // Sessions expire after 30 days of being idle
  method: "essential",
  sameSite: "lax",
  publicDataKeysToSyncAcrossSessions: ["role", "roles"],
  getSession: function getSession(handle) {
    return getDb().session.findFirst({
      where: {
        handle: handle
      }
    });
  },
  getSessions: function getSessions(userId) {
    return getDb().session.findMany({
      where: {
        userId: userId
      }
    });
  },
  createSession: function createSession(session) {
    var user;

    if (session.userId) {
      user = {
        connect: {
          id: session.userId
        }
      };
    }

    return getDb().session.create({
      data: _extends._extends({}, session, {
        userId: undefined,
        user: user
      })
    });
  },
  updateSession: async function updateSession(handle, session) {
    try {
      return await getDb().session.update({
        where: {
          handle: handle
        },
        data: session
      });
    } catch (error) {
      // Session doesn't exist in DB for some reason, so create it
      if (error.code === "P2016") {
        display.log.warning("Could not update session because it's not in the DB");
      } else {
        throw error;
      }
    }
  },
  deleteSession: function deleteSession(handle) {
    return getDb().session["delete"]({
      where: {
        handle: handle
      }
    });
  },
  isAuthorized: function isAuthorized() {
    throw new Error("No isAuthorized implementation provided");
  }
};
var simpleRolesIsAuthorized = function simpleRolesIsAuthorized(_ref) {
  var ctx = _ref.ctx,
      args = _ref.args;
  var roleOrRoles = args[0];
  var publicData = ctx.session.$publicData;

  if ("role" in publicData && "roles" in publicData) {
    throw new Error("Session publicData can only have only `role` or `roles`, but not both.'");
  }

  var roles = [];

  if ("role" in publicData) {
    if (typeof publicData.role !== "string") {
      throw new Error("Session publicData.role field must be a string");
    }

    roles.push(publicData.role);
  } else if ("roles" in publicData) {
    if (!Array.isArray(publicData.roles)) {
      throw new Error("Session `publicData.roles` is not an array, but it must be");
    }

    roles = publicData.roles;
  } else {
    throw new Error("Session publicData is missing the required `role` or roles` field");
  } // No roles required, so all roles allowed


  if (!roleOrRoles) return true;
  var rolesToAuthorize = [];

  if (Array.isArray(roleOrRoles)) {
    rolesToAuthorize.push.apply(rolesToAuthorize, roleOrRoles);
  } else if (roleOrRoles) {
    rolesToAuthorize.push(roleOrRoles);
  }

  for (var _i = 0, _rolesToAuthorize = rolesToAuthorize; _i < _rolesToAuthorize.length; _i++) {
    var role = _rolesToAuthorize[_i];
    if (roles.includes(role)) return true;
  }

  return false;
}; // --------------------------------
// Middleware
// --------------------------------

var sessionMiddleware = function sessionMiddleware(sessionConfig) {
  var _global$sessionConfig;

  if (sessionConfig === void 0) {
    sessionConfig = {};
  }

  assert$1(sessionConfig.isAuthorized, "You must provide an authorization implementation to sessionMiddleware as isAuthorized(userRoles, input)");
  global.sessionConfig = _extends._extends({}, defaultConfig, sessionConfig); // Checks if cookie prefix from configuration has
  // non-alphanumeric characters and throws error

  var cookiePrefix = (_global$sessionConfig = global.sessionConfig.cookiePrefix) != null ? _global$sessionConfig : "blitz";
  assert$1(cookiePrefix.match(/^[a-zA-Z0-9-_]+$/), "The cookie prefix used has invalid characters. Only alphanumeric characters, \"-\"  and \"_\" character are supported");

  var blitzSessionMiddleware = async function blitzSessionMiddleware(req, res, next) {
    debug("Starting sessionMiddleware...");

    if (!res.blitzCtx.session) {
      // This function also saves session to res.blitzCtx
      await getSession(req, res);
    }

    return next();
  };

  blitzSessionMiddleware.config = {
    cookiePrefix: cookiePrefix
  };
  return blitzSessionMiddleware;
};

// const isBlitzApiRequest = (req: BlitzApiRequest | IncomingMessage): req is BlitzApiRequest => {
//   return "cookies" in req
// }
function ensureBlitzApiRequest(req) {
  if (!("cookies" in req)) {
    req.cookies = apiUtils.getCookieParser(req)();
  }
} // const isMiddlewareApResponse = (
//   res: MiddlewareResponse | ServerResponse,
// ): res is MiddlewareResponse => {
//   return "blitzCtx" in res
// }


function ensureMiddlewareResponse(res) {
  if (!("blitzCtx" in res)) {
    res.blitzCtx = {};
  }
}

async function getSession(req, res) {
  ensureBlitzApiRequest(req);
  ensureMiddlewareResponse(res);
  var response = res;

  if (response.blitzCtx.session) {
    return response.blitzCtx.session;
  }

  var sessionKernel = await getSessionKernel(req, res);

  if (sessionKernel) {
    debug("Got existing session", sessionKernel);
  }

  if (!sessionKernel) {
    debug("No session found, creating anonymous session");
    sessionKernel = await createAnonymousSession(req, res);
  }

  var sessionContext = makeProxyToPublicData(new SessionContextClass(req, res, sessionKernel));
  response.blitzCtx.session = sessionContext;
  return sessionContext;
}

var makeProxyToPublicData = function makeProxyToPublicData(ctxClass) {
  return new Proxy(ctxClass, {
    get: function get(target, prop, receiver) {
      if (prop in target || prop === "then") {
        return Reflect.get(target, prop, receiver);
      } else {
        return Reflect.get(target.$publicData, prop, receiver);
      }
    }
  });
};

var SessionContextClass = /*#__PURE__*/function () {
  function SessionContextClass(req, res, kernel) {
    this._req = void 0;
    this._res = void 0;
    this._kernel = void 0;
    this._req = req;
    this._res = res;
    this._kernel = kernel;
  }

  var _proto = SessionContextClass.prototype;

  _proto.$authorize = function $authorize() {
    var e = new constants.AuthenticationError();
    Error.captureStackTrace(e, this.$authorize);
    if (!this.userId) throw e;

    if (!this.$isAuthorized.apply(this, arguments)) {
      var _e = new constants.AuthorizationError();

      Error.captureStackTrace(_e, this.$authorize);
      throw _e;
    }
  };

  _proto.$isAuthorized = function $isAuthorized() {
    if (!this.userId) return false;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return global.sessionConfig.isAuthorized({
      ctx: this._res.blitzCtx,
      args: args
    });
  };

  _proto.$create = async function $create(publicData, privateData) {
    this._kernel = await createNewSession({
      req: this._req,
      res: this._res,
      publicData: publicData,
      privateData: privateData,
      jwtPayload: this._kernel.jwtPayload,
      anonymous: false
    });
  };

  _proto.$revoke = function $revoke() {
    return revokeSession(this._req, this._res, this.$handle);
  };

  _proto.$revokeAll = async function $revokeAll() {
    if (!this.$publicData.userId) {
      throw new Error("session.revokeAll() cannot be used with anonymous sessions");
    }

    await revokeAllSessionsForUser(this._req, this._res, this.$publicData.userId);
    return;
  };

  _proto.$setPublicData = async function $setPublicData(data) {
    if (this.userId) {
      await syncPubicDataFieldsForUserIfNeeded(this.userId, data);
    }

    this._kernel.publicData = await setPublicData(this._req, this._res, this._kernel, data);
  };

  _proto.$getPrivateData = async function $getPrivateData() {
    return (await getPrivateData(this.$handle)) || {};
  };

  _proto.$setPrivateData = function $setPrivateData(data) {
    return setPrivateData(this._kernel, data);
  };

  constants._createClass(SessionContextClass, [{
    key: "$handle",
    get: function get() {
      return this._kernel.handle;
    }
  }, {
    key: "userId",
    get: function get() {
      return this._kernel.publicData.userId;
    }
  }, {
    key: "$publicData",
    get: function get() {
      return this._kernel.publicData;
    }
  }]);

  return SessionContextClass;
}(); // --------------------------------
// Token/handle utils
// --------------------------------

var TOKEN_LENGTH = 32;
var generateEssentialSessionHandle = function generateEssentialSessionHandle() {
  return generateToken(TOKEN_LENGTH) + constants.HANDLE_SEPARATOR + constants.SESSION_TYPE_OPAQUE_TOKEN_SIMPLE;
};
var generateAnonymousSessionHandle = function generateAnonymousSessionHandle() {
  return generateToken(TOKEN_LENGTH) + constants.HANDLE_SEPARATOR + constants.SESSION_TYPE_ANONYMOUS_JWT;
};
var createSessionToken = function createSessionToken(handle, publicData) {
  // We store the hashed public data in the opaque token so that when we verify,
  // we can detect changes in it and return a new set of tokens if necessary.
  var publicDataString;

  if (typeof publicData === "string") {
    publicDataString = publicData;
  } else {
    publicDataString = JSON.stringify(publicData);
  }

  return b64Lite.toBase64([handle, generateToken(TOKEN_LENGTH), hash256(publicDataString), constants.SESSION_TOKEN_VERSION_0].join(constants.TOKEN_SEPARATOR));
};
var parseSessionToken = function parseSessionToken(token) {
  var _fromBase64$split = b64Lite.fromBase64(token).split(constants.TOKEN_SEPARATOR),
      handle = _fromBase64$split[0],
      id = _fromBase64$split[1],
      hashedPublicData = _fromBase64$split[2],
      version = _fromBase64$split[3];

  if (!handle || !id || !hashedPublicData || !version) {
    throw new constants.AuthenticationError("Failed to parse session token");
  }

  return {
    handle: handle,
    id: id,
    hashedPublicData: hashedPublicData,
    version: version
  };
};
var createPublicDataToken = function createPublicDataToken(publicData) {
  var payload = typeof publicData === "string" ? publicData : JSON.stringify(publicData);
  return b64Lite.toBase64(payload);
};
var createAntiCSRFToken = function createAntiCSRFToken() {
  return generateToken(TOKEN_LENGTH);
};
var getSessionSecretKey = function getSessionSecretKey() {
  {
    assert$1(process.env.SESSION_SECRET_KEY, "You must provide the SESSION_SECRET_KEY environment variable in production. This is used to sign and verify tokens. It should be 32 chars long.");
    assert$1(process.env.SESSION_SECRET_KEY.length >= 32, "The SESSION_SECRET_KEY environment variable must be at least 32 bytes for sufficent token security");
    return process.env.SESSION_SECRET_KEY;
  }
};
var JWT_NAMESPACE = "blitzjs";
var JWT_ISSUER = "blitzjs";
var JWT_AUDIENCE = "blitzjs";
var JWT_ANONYMOUS_SUBJECT = "anonymous";
var JWT_ALGORITHM = "HS256";
var createAnonymousSessionToken = function createAnonymousSessionToken(payload) {
  var _jwtSign;

  return jsonwebtoken.sign((_jwtSign = {}, _jwtSign[JWT_NAMESPACE] = payload, _jwtSign), getSessionSecretKey(), {
    algorithm: JWT_ALGORITHM,
    issuer: JWT_ISSUER,
    audience: JWT_AUDIENCE,
    subject: JWT_ANONYMOUS_SUBJECT
  });
};
var parseAnonymousSessionToken = function parseAnonymousSessionToken(token) {
  // This must happen outside the try/catch because it could throw an error
  // about a missing environment variable
  var secret = getSessionSecretKey();

  try {
    var fullPayload = jsonwebtoken.verify(token, secret, {
      algorithms: [JWT_ALGORITHM],
      issuer: JWT_ISSUER,
      audience: JWT_AUDIENCE,
      subject: JWT_ANONYMOUS_SUBJECT
    });

    if (typeof fullPayload === "object") {
      return fullPayload[JWT_NAMESPACE];
    } else {
      return null;
    }
  } catch (error) {
    return null;
  }
};
var setCookie = function setCookie(res, cookie) {
  var getCookieName = function getCookieName(c) {
    return c.split("=", 2)[0];
  };

  var appendCookie = function appendCookie() {
    return append(res, "Set-Cookie", cookie);
  };

  var cookiesHeader = res.getHeader("Set-Cookie");
  var cookieName = getCookieName(cookie);

  if (typeof cookiesHeader !== "string" && !Array.isArray(cookiesHeader)) {
    appendCookie();
    return;
  }

  if (typeof cookiesHeader === "string") {
    if (cookieName === getCookieName(cookiesHeader)) {
      res.setHeader("Set-Cookie", cookie);
    } else {
      appendCookie();
    }
  } else {
    for (var i = 0; i < cookiesHeader.length; i++) {
      if (cookieName === getCookieName(cookiesHeader[i])) {
        cookiesHeader[i] = cookie;
        res.setHeader("Set-Cookie", cookie);
        return;
      }
    }

    appendCookie();
  }
};
var setHeader = function setHeader(res, name, value) {
  res.setHeader(name, value);

  if ("_blitz" in res) {
    res._blitz[name] = value;
  }
};
var removeHeader = function removeHeader(res, name) {
  res.removeHeader(name);

  if ("_blitz" in res) {
    delete res._blitz[name];
  }
};
var setSessionCookie = function setSessionCookie(req, res, sessionToken, expiresAt) {
  setCookie(res, cookie__default['default'].serialize(constants.COOKIE_SESSION_TOKEN(), sessionToken, {
    path: "/",
    httpOnly: true,
    secure: !process.env.DISABLE_SECURE_COOKIES &&         "production" === "production" && !isLocalhost(req),
    sameSite: global.sessionConfig.sameSite,
    domain: global.sessionConfig.domain,
    expires: expiresAt
  }));
};
var setAnonymousSessionCookie = function setAnonymousSessionCookie(req, res, token, expiresAt) {
  setCookie(res, cookie__default['default'].serialize(constants.COOKIE_ANONYMOUS_SESSION_TOKEN(), token, {
    path: "/",
    httpOnly: true,
    secure: !process.env.DISABLE_SECURE_COOKIES &&         "production" === "production" && !isLocalhost(req),
    sameSite: global.sessionConfig.sameSite,
    domain: global.sessionConfig.domain,
    expires: expiresAt
  }));
};
var setCSRFCookie = function setCSRFCookie(req, res, antiCSRFToken, expiresAt) {
  debug("setCSRFCookie", antiCSRFToken);
  setCookie(res, cookie__default['default'].serialize(constants.COOKIE_CSRF_TOKEN(), antiCSRFToken, {
    path: "/",
    secure: !process.env.DISABLE_SECURE_COOKIES &&         "production" === "production" && !isLocalhost(req),
    sameSite: global.sessionConfig.sameSite,
    domain: global.sessionConfig.domain,
    expires: expiresAt
  }));
};
var setPublicDataCookie = function setPublicDataCookie(req, res, publicDataToken, expiresAt) {
  setHeader(res, constants.HEADER_PUBLIC_DATA_TOKEN, "updated");
  setCookie(res, cookie__default['default'].serialize(constants.COOKIE_PUBLIC_DATA_TOKEN(), publicDataToken, {
    path: "/",
    secure: !process.env.DISABLE_SECURE_COOKIES &&         "production" === "production" && !isLocalhost(req),
    sameSite: global.sessionConfig.sameSite,
    domain: global.sessionConfig.domain,
    expires: expiresAt
  }));
}; // --------------------------------
// Get Session
// --------------------------------

async function getSessionKernel(req, res) {
  var anonymousSessionToken = req.cookies[constants.COOKIE_ANONYMOUS_SESSION_TOKEN()];
  var sessionToken = req.cookies[constants.COOKIE_SESSION_TOKEN()]; // for essential method

  var idRefreshToken = req.cookies[constants.COOKIE_REFRESH_TOKEN()]; // for advanced method

  var enableCsrfProtection = req.method !== "GET" && req.method !== "OPTIONS" && !process.env.DISABLE_CSRF_PROTECTION;
  var antiCSRFToken = req.headers[constants.HEADER_CSRF];

  if (sessionToken) {
    debug("[getSessionKernel] Request has sessionToken");

    var _parseSessionToken = parseSessionToken(sessionToken),
        handle = _parseSessionToken.handle,
        version = _parseSessionToken.version,
        hashedPublicData = _parseSessionToken.hashedPublicData;

    if (!handle) {
      debug("No handle in sessionToken");
      return null;
    }

    if (version !== constants.SESSION_TOKEN_VERSION_0) {
      console.log(new constants.AuthenticationError("Session token version is not " + constants.SESSION_TOKEN_VERSION_0));
      return null;
    }

    debug("global session config", global.sessionConfig);
    var persistedSession = await global.sessionConfig.getSession(handle);

    if (!persistedSession) {
      debug("Session not found in DB");
      return null;
    }

    if (persistedSession.hashedSessionToken !== hash256(sessionToken)) {
      debug("sessionToken hash did not match");
      debug("persisted: ", persistedSession.hashedSessionToken);
      debug("in req: ", hash256(sessionToken));
      return null;
    }

    if (persistedSession.expiresAt && isPast(persistedSession.expiresAt)) {
      debug("Session expired");
      return null;
    }

    if (enableCsrfProtection && persistedSession.antiCSRFToken !== antiCSRFToken) {
      if (!antiCSRFToken) {
        display.log.warning("This request is missing the " + constants.HEADER_CSRF + " header. You can learn about adding this here: https://blitzjs.com/docs/session-management#manual-api-requests");
      }

      setHeader(res, constants.HEADER_CSRF_ERROR, "true");
      throw new constants.CSRFTokenMismatchError();
    }
    /*
     * Session Renewal - Will renew if any of the following is true
     * 1) publicData has changed
     * 2) 1/4 of expiry time has elasped
     *
     *  But only renew with non-GET requests because a GET request could be from a
     *  browser level navigation
     */


    if (req.method !== "GET") {
      var _persistedSession$pub;

      // The publicData in the DB could have been updated since this client last made
      // a request. If so, then we generate a new access token
      var hasPublicDataChanged = hash256((_persistedSession$pub = persistedSession.publicData) != null ? _persistedSession$pub : undefined) !== hashedPublicData;

      if (hasPublicDataChanged) {
        debug("PublicData has changed since the last request");
      } // Check if > 1/4th of the expiry time has passed
      // (since we are doing a rolling expiry window).


      var hasQuarterExpiryTimePassed = persistedSession.expiresAt && differenceInMinutes(persistedSession.expiresAt, new Date()) < 0.75 * global.sessionConfig.sessionExpiryMinutes;

      if (hasQuarterExpiryTimePassed) {
        debug("quarter expiry time has passed");
        debug("Persisted expire time", persistedSession.expiresAt);
      }

      if (hasPublicDataChanged || hasQuarterExpiryTimePassed) {
        await refreshSession(req, res, {
          handle: handle,
          publicData: JSON.parse(persistedSession.publicData || ""),
          jwtPayload: null,
          antiCSRFToken: antiCSRFToken,
          sessionToken: sessionToken
        }, {
          publicDataChanged: hasPublicDataChanged
        });
      }
    }

    return {
      handle: handle,
      publicData: JSON.parse(persistedSession.publicData || ""),
      jwtPayload: null,
      antiCSRFToken: antiCSRFToken,
      sessionToken: sessionToken
    };
  } else if (idRefreshToken) {
    // TODO: advanced method
    return null; // Important: check anonymousSessionToken token as the very last thing
  } else if (anonymousSessionToken) {
    debug("Request has anonymousSessionToken");
    var payload = parseAnonymousSessionToken(anonymousSessionToken);

    if (!payload) {
      debug("Payload empty");
      return null;
    }

    if (enableCsrfProtection && payload.antiCSRFToken !== antiCSRFToken) {
      if (!antiCSRFToken) {
        display.log.warning("This request is missing the " + constants.HEADER_CSRF + " header. You can learn about adding this here: https://blitzjs.com/docs/session-management#manual-api-requests");
      }

      setHeader(res, constants.HEADER_CSRF_ERROR, "true");
      throw new constants.CSRFTokenMismatchError();
    }

    return {
      handle: payload.handle,
      publicData: payload.publicData,
      jwtPayload: payload,
      antiCSRFToken: antiCSRFToken,
      anonymousSessionToken: anonymousSessionToken
    };
  } // No session exists


  return null;
} // --------------------------------
// Create Session
// --------------------------------

async function createNewSession(args) {
  var req = args.req,
      res = args.res;
  assert$1(args.publicData.userId !== undefined, "You must provide publicData.userId");
  var antiCSRFToken = createAntiCSRFToken();

  if (args.anonymous) {
    debug("Creating new anonymous session");
    var handle = generateAnonymousSessionHandle();
    var payload = {
      isAnonymous: true,
      handle: handle,
      publicData: args.publicData,
      antiCSRFToken: antiCSRFToken
    };
    var anonymousSessionToken = createAnonymousSessionToken(payload);
    var publicDataToken = createPublicDataToken(args.publicData);
    var expiresAt = addYears(new Date(), 30);
    setAnonymousSessionCookie(req, res, anonymousSessionToken, expiresAt);
    setCSRFCookie(req, res, antiCSRFToken, expiresAt);
    setPublicDataCookie(req, res, publicDataToken, expiresAt); // Clear the essential session cookie in case it was previously set

    setSessionCookie(req, res, "", new Date(0));
    removeHeader(res, constants.HEADER_SESSION_REVOKED);
    setHeader(res, constants.HEADER_SESSION_CREATED, "true");
    return {
      handle: handle,
      publicData: args.publicData,
      jwtPayload: payload,
      antiCSRFToken: antiCSRFToken,
      anonymousSessionToken: anonymousSessionToken
    };
  } else if (global.sessionConfig.method === "essential") {
    var _args$jwtPayload, _args$jwtPayload2;

    debug("Creating new session");

    var newPublicData = _extends._extends({}, ((_args$jwtPayload = args.jwtPayload) == null ? void 0 : _args$jwtPayload.publicData) || {}, args.publicData);

    assert$1(newPublicData.userId, "You must provide a non-empty userId as publicData.userId"); // This carries over any private data from the anonymous session

    var existingPrivateData = {};

    if ((_args$jwtPayload2 = args.jwtPayload) != null && _args$jwtPayload2.isAnonymous) {
      var session = await global.sessionConfig.getSession(args.jwtPayload.handle);

      if (session) {
        if (session.privateData) {
          existingPrivateData = JSON.parse(session.privateData);
        } // Delete the previous anonymous session


        await global.sessionConfig.deleteSession(args.jwtPayload.handle);
      }
    }

    var newPrivateData = _extends._extends({}, existingPrivateData, args.privateData);

    var _expiresAt = addMinutes(new Date(), global.sessionConfig.sessionExpiryMinutes);

    var _handle = generateEssentialSessionHandle();

    var sessionToken = createSessionToken(_handle, newPublicData);

    var _publicDataToken = createPublicDataToken(newPublicData);

    await global.sessionConfig.createSession({
      expiresAt: _expiresAt,
      handle: _handle,
      userId: newPublicData.userId,
      hashedSessionToken: hash256(sessionToken),
      antiCSRFToken: antiCSRFToken,
      publicData: JSON.stringify(newPublicData),
      privateData: JSON.stringify(newPrivateData)
    });
    setSessionCookie(req, res, sessionToken, _expiresAt);
    setCSRFCookie(req, res, antiCSRFToken, _expiresAt);
    setPublicDataCookie(req, res, _publicDataToken, _expiresAt); // Clear the anonymous session cookie in case it was previously set

    setAnonymousSessionCookie(req, res, "", new Date(0));
    removeHeader(res, constants.HEADER_SESSION_REVOKED);
    setHeader(res, constants.HEADER_SESSION_CREATED, "true");
    return {
      handle: _handle,
      publicData: newPublicData,
      jwtPayload: null,
      antiCSRFToken: antiCSRFToken,
      sessionToken: sessionToken
    };
  } else if (global.sessionConfig.method === "advanced") {
    throw new Error("The advanced method is not yet supported");
  } else {
    throw new Error("Session management method " + global.sessionConfig.method + " is invalid. Supported methods are \"essential\" and \"advanced\"");
  }
}
async function createAnonymousSession(req, res) {
  return await createNewSession({
    req: req,
    res: res,
    publicData: {
      userId: null
    },
    anonymous: true
  });
} // --------------------------------
// Session/DB utils
// --------------------------------

async function refreshSession(req, res, sessionKernel, _ref2) {
  var _sessionKernel$jwtPay;

  var publicDataChanged = _ref2.publicDataChanged;
  debug("Refreshing session", sessionKernel);

  if ((_sessionKernel$jwtPay = sessionKernel.jwtPayload) != null && _sessionKernel$jwtPay.isAnonymous) {
    var payload = _extends._extends({}, sessionKernel.jwtPayload, {
      publicData: sessionKernel.publicData
    });

    var anonymousSessionToken = createAnonymousSessionToken(payload);
    var publicDataToken = createPublicDataToken(sessionKernel.publicData);
    var expiresAt = addYears(new Date(), 30);
    setAnonymousSessionCookie(req, res, anonymousSessionToken, expiresAt);
    setPublicDataCookie(req, res, publicDataToken, expiresAt);
    setCSRFCookie(req, res, sessionKernel.antiCSRFToken, expiresAt);
  } else if (global.sessionConfig.method === "essential" && "sessionToken" in sessionKernel) {
    var _expiresAt2 = addMinutes(new Date(), global.sessionConfig.sessionExpiryMinutes);

    var _publicDataToken2 = createPublicDataToken(sessionKernel.publicData);

    var sessionToken; // Only generate new session token if public data actually changed
    // Otherwise if new session token is generated just for refresh, then
    // we have race condition bugs

    if (publicDataChanged) {
      sessionToken = createSessionToken(sessionKernel.handle, sessionKernel.publicData);
    } else {
      sessionToken = sessionKernel.sessionToken;
    }

    setSessionCookie(req, res, sessionToken, _expiresAt2);
    setPublicDataCookie(req, res, _publicDataToken2, _expiresAt2);
    setCSRFCookie(req, res, sessionKernel.antiCSRFToken, _expiresAt2);
    debug("Updating session in db with", {
      expiresAt: _expiresAt2
    });

    if (publicDataChanged) {
      await global.sessionConfig.updateSession(sessionKernel.handle, {
        expiresAt: _expiresAt2,
        hashedSessionToken: hash256(sessionToken),
        publicData: JSON.stringify(sessionKernel.publicData)
      });
    } else {
      await global.sessionConfig.updateSession(sessionKernel.handle, {
        expiresAt: _expiresAt2
      });
    }
  } else if (global.sessionConfig.method === "advanced") {
    throw new Error("refreshSession() not implemented for advanced method");
  }
}
async function syncPubicDataFieldsForUserIfNeeded(userId, data) {
  var _global$sessionConfig2;

  var dataToSync = {};
  (_global$sessionConfig2 = global.sessionConfig.publicDataKeysToSyncAcrossSessions) == null ? void 0 : _global$sessionConfig2.forEach(function (key) {
    if (data[key]) {
      dataToSync[key] = data[key];
    }
  });

  if (Object.keys(dataToSync).length) {
    var sessions = await global.sessionConfig.getSessions(userId);

    for (var _iterator = constants._createForOfIteratorHelperLoose(sessions), _step; !(_step = _iterator()).done;) {
      var session = _step.value;
      var publicData = JSON.stringify(_extends._extends({}, session.publicData ? JSON.parse(session.publicData) : {}, dataToSync));
      await global.sessionConfig.updateSession(session.handle, {
        publicData: publicData
      });
    }
  }
}
async function revokeSession(req, res, handle, anonymous) {
  if (anonymous === void 0) {
    anonymous = false;
  }

  debug("Revoking session", handle);

  if (!anonymous) {
    try {
      await global.sessionConfig.deleteSession(handle);
    } catch (error) {// Ignore any errors, like if session doesn't exist in DB
    }
  } // This is used on the frontend to clear localstorage


  setHeader(res, constants.HEADER_SESSION_REVOKED, "true"); // Clear all cookies

  setSessionCookie(req, res, "", new Date(0));
  setAnonymousSessionCookie(req, res, "", new Date(0));
  setCSRFCookie(req, res, "", new Date(0));
}
async function revokeMultipleSessions(req, res, sessionHandles) {
  var revoked = [];

  for (var _iterator2 = constants._createForOfIteratorHelperLoose(sessionHandles), _step2; !(_step2 = _iterator2()).done;) {
    var handle = _step2.value;
    await revokeSession(req, res, handle);
    revoked.push(handle);
  }

  return revoked;
}
async function revokeAllSessionsForUser(req, res, userId) {
  var sessionHandles = (await global.sessionConfig.getSessions(userId)).map(function (session) {
    return session.handle;
  });
  return revokeMultipleSessions(req, res, sessionHandles);
}
async function getPublicData(sessionKernel) {
  var _sessionKernel$jwtPay2;

  if ((_sessionKernel$jwtPay2 = sessionKernel.jwtPayload) != null && _sessionKernel$jwtPay2.publicData) {
    var _sessionKernel$jwtPay3;

    return (_sessionKernel$jwtPay3 = sessionKernel.jwtPayload) == null ? void 0 : _sessionKernel$jwtPay3.publicData;
  } else {
    var session = await global.sessionConfig.getSession(sessionKernel.handle);

    if (!session) {
      throw new Error("getPublicData() failed because handle doesn't exist " + sessionKernel.handle);
    }

    if (session.publicData) {
      return JSON.parse(session.publicData);
    } else {
      return {};
    }
  }
}
async function getPrivateData(handle) {
  var session = await global.sessionConfig.getSession(handle);

  if (session && session.privateData) {
    return JSON.parse(session.privateData);
  } else {
    return null;
  }
}
async function setPrivateData(sessionKernel, data) {
  var existingPrivateData = await getPrivateData(sessionKernel.handle);

  if (existingPrivateData === null) {
    // Anonymous sessions may not exist in the DB yet
    try {
      await global.sessionConfig.createSession({
        handle: sessionKernel.handle
      });
    } catch (error) {}

    existingPrivateData = {};
  }

  var privateData = JSON.stringify(_extends._extends({}, existingPrivateData, data));
  await global.sessionConfig.updateSession(sessionKernel.handle, {
    privateData: privateData
  });
}
async function setPublicData(req, res, sessionKernel, data) {
  // Don't allow updating userId
  delete data.userId;

  var publicData = _extends._extends({}, await getPublicData(sessionKernel), data);

  await refreshSession(req, res, _extends._extends({}, sessionKernel, {
    publicData: publicData
  }), {
    publicDataChanged: true
  });
  return publicData;
}
/**
 * Append additional header `field` with value `val`.
 *
 * Example:
 *
 *    append(res, 'Set-Cookie', 'foo=bar; Path=/; HttpOnly');
 *
 * @param {ServerResponse} res
 * @param {string} field
 * @param {string| string[]} val
 */

function append(res, field, val) {
  var prev = res.getHeader(field);
  var value = val;

  if (prev !== undefined) {
    // concat the new and prev vals
    value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
  }

  value = Array.isArray(value) ? value.map(String) : String(value);
  res.setHeader(field, value);
  return res;
}

var secureProxyMiddleware = function secureProxyMiddleware(req, _res, next) {
  req.protocol = getProtocol(req);
  next();
};

function getProtocol(req) {
  // @ts-ignore
  // For some reason there is no encrypted on socket while it is expected
  if (req.connection.encrypted) {
    return "https";
  }

  var forwardedProto = req.headers && req.headers["x-forwarded-proto"];

  if (forwardedProto) {
    return forwardedProto.split(/\s*,\s*/)[0];
  }

  return "http";
}

function assert(condition, message) {
  if (!condition) throw new Error(message);
}

var isFunction = function isFunction(functionToCheck) {
  return typeof functionToCheck === "function";
};

var isVerifyCallbackResult = function isVerifyCallbackResult(value) {
  return typeof value === "object" && value !== null && "publicData" in value;
};

var INTERNAL_REDIRECT_URL_KEY = "_redirectUrl";
function passportAuth(config) {
  return async function authHandler(req, res) {
    var globalMiddleware = getAllMiddlewareForModule({});
    await handleRequestWithMiddleware(req, res, globalMiddleware);
    var configObject = isFunction(config) ? config(res.blitzCtx) : config;
    var cookieSessionMiddleware = cookieSession__default['default']({
      secret: process.env.SESSION_SECRET_KEY || "default-dev-secret",
      secure: !isLocalhost(req)
    });
    var passportMiddleware = passport__default['default'].initialize();
    var middleware = [connectMiddleware(cookieSessionMiddleware), connectMiddleware(passportMiddleware), connectMiddleware(passport__default['default'].session())];

    if (configObject.secureProxy) {
      middleware.push(secureProxyMiddleware);
    }

    if (!req.query.auth.length) {
      return res.status(404).end();
    }

    assert(configObject.strategies.length, "No Passport strategies found! Please add at least one strategy.");
    var blitzStrategy = configObject.strategies.find(function (_ref) {
      var strategy = _ref.strategy;
      return strategy.name === req.query.auth[0];
    });
    assert(blitzStrategy, "A passport strategy was not found for: " + req.query.auth[0]);
    var strategy = blitzStrategy.strategy,
        authenticateOptions = blitzStrategy.authenticateOptions;
    passport__default['default'].use(strategy);
    var strategyName = strategy.name;

    if (req.query.auth.length === 1) {
      display.log.info("Starting authentication via " + strategyName + "...");

      if (req.query.redirectUrl) {
        middleware.push(async function (req, res, next) {
          var _session$$setPublicDa;

          var session = res.blitzCtx.session;
          assert(session, "Missing Blitz sessionMiddleware!");
          await session.$setPublicData((_session$$setPublicDa = {}, _session$$setPublicDa[INTERNAL_REDIRECT_URL_KEY] = req.query.redirectUrl, _session$$setPublicDa));
          return next();
        });
      }

      middleware.push(connectMiddleware(passport__default['default'].authenticate(strategyName, _extends._extends({}, authenticateOptions))));
    } else if (req.query.auth[1] === "callback") {
      display.log.info("Processing callback for " + strategyName + "...");
      middleware.push(connectMiddleware(function (req, res, next) {
        var session = res.blitzCtx.session;
        assert(session, "Missing Blitz sessionMiddleware!");
        passport__default['default'].authenticate(strategyName, async function (err, result) {
          try {
            var error = err;

            if (!error) {
              if (result === false) {
                display.log.warning("Login via " + strategyName + " failed - usually this means the user did not authenticate properly with the provider");
                error = "Login failed";
              }

              assert(typeof result === "object" && result !== null, "Your '" + strategyName + "' passport verify callback returned empty data. Ensure you call 'done(null, {publicData: {userId: 1}})' along with any other publicData fields you need)");
              assert(result.publicData, "'publicData' is missing from your '" + strategyName + "' passport verify callback. Ensure you call 'done(null, {publicData: {userId: 1}})' along with any other publicData fields you need)");
            }

            var redirectUrlFromVerifyResult = result && typeof result === "object" && result.redirectUrl;
            var redirectUrl = redirectUrlFromVerifyResult || session.$publicData[INTERNAL_REDIRECT_URL_KEY] || (error ? configObject.errorRedirectUrl : configObject.successRedirectUrl) || "/";

            if (error) {
              redirectUrl += "?authError=" + encodeURIComponent(error.toString());
              res.setHeader("Location", redirectUrl);
              res.statusCode = 302;
              res.end();
              return;
            }

            assert(isVerifyCallbackResult(result), "Passport verify callback is invalid");
            delete result.publicData[INTERNAL_REDIRECT_URL_KEY];
            await session.$create(result.publicData, result.privateData);
            res.setHeader("Location", redirectUrl);
            res.statusCode = 302;
            res.end();
          } catch (error) {
            console.error(error);
            res.statusCode = 500;
            res.end();
          }
        })(req, res, next);
      }));
    }

    await handleRequestWithMiddleware(req, res, middleware);
  };
}

var rpcMiddleware = function rpcMiddleware(resolver, connectDb) {
  return async function (req, res, next) {
    var log = display.baseLogger().getChildLogger({
      prefix: [resolver._meta.name + "()"]
    });

    if (req.method === "HEAD") {
      // Warm the lamda and connect to DB
      if (typeof connectDb === "function") {
        connectDb();
      }

      res.status(200).end();
      return next();
    } else if (req.method === "POST") {
      // Handle RPC call
      if (typeof req.body.params === "undefined") {
        var error = {
          message: "Request body is missing the `params` key"
        };
        log.error(error.message);
        res.status(400).json({
          result: null,
          error: error
        });
        return next();
      }

      try {
        var _req$body$meta;

        var data = SuperJson.deserialize({
          json: req.body.params,
          meta: (_req$body$meta = req.body.meta) == null ? void 0 : _req$body$meta.params
        });
        log.info(chalk__default['default'].dim("Starting with input:"), data ? data : JSON.stringify(data));
        var startTime = Date.now();
        var result = await resolver(data, res.blitzCtx);
        var resolverDuration = Date.now() - startTime;
        log.debug(chalk__default['default'].dim("Result:"), result ? result : JSON.stringify(result));
        var serializerStartTime = Date.now();
        var serializedResult = SuperJson.serialize(result);
        var nextSerializerStartTime = Date.now();
        res.blitzResult = result;
        res.json({
          result: serializedResult.json,
          error: null,
          meta: {
            result: serializedResult.meta
          }
        });
        log.debug(chalk__default['default'].dim("Next.js serialization:" + prettyMs(Date.now() - nextSerializerStartTime)));
        var serializerDuration = Date.now() - serializerStartTime;
        var duration = Date.now() - startTime;
        log.info(chalk__default['default'].dim("Finished: resolver:" + prettyMs(resolverDuration) + " serializer:" + prettyMs(serializerDuration) + " total:" + prettyMs(duration)));
        display.log.newline();
        return next();
      } catch (error) {
        if (error._clearStack) {
          delete error.stack;
        }

        log.error(error);
        display.log.newline();

        if (!error.statusCode) {
          error.statusCode = 500;
        }

        var serializedError = SuperJson.serialize(error);
        res.json({
          result: null,
          error: serializedError.json,
          meta: {
            error: serializedError.meta
          }
        });
        return next();
      }
    } else {
      // Everything else is error
      log.warn(req.method + " method not supported");
      res.status(404).end();
      return next();
    }
  };
};

function rpcApiHandler(resolver, middleware, connectDb) {
  if (middleware === void 0) {
    middleware = [];
  }

  // RPC Middleware is always the last middleware to run
  middleware.push(rpcMiddleware(resolver, connectDb));
  return function (req, res) {
    return handleRequestWithMiddleware(req, res, middleware, {
      throwOnError: false
    });
  };
}

exports.SecurePassword = SecurePassword;
exports.connectMiddleware = connectMiddleware;
exports.generateToken = generateToken;
exports.getAllMiddlewareForModule = getAllMiddlewareForModule;
exports.getSession = getSession;
exports.handleRequestWithMiddleware = handleRequestWithMiddleware;
exports.hash256 = hash256;
exports.invokeWithMiddleware = invokeWithMiddleware;
exports.isLocalhost = isLocalhost;
exports.paginate = paginate;
exports.passportAuth = passportAuth;
exports.resolver = resolver;
exports.rpcApiHandler = rpcApiHandler;
exports.sessionMiddleware = sessionMiddleware;
exports.simpleRolesIsAuthorized = simpleRolesIsAuthorized;
