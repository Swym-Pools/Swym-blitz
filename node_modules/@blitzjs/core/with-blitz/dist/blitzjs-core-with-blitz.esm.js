import { _ as _extends } from '../../dist/extends-1b905a27.esm.js';
import { getProjectRoot } from '@blitzjs/config';
import fs from 'fs';
import path from 'path';

function withBlitz(nextConfig) {
  return function (phase, nextOpts) {
    if (nextOpts === void 0) {
      nextOpts = {};
    }

    // Need to grab the normalized config based on the phase
    // we are in incase we are given a functional config to extend
    var normalizedConfig = typeof nextConfig === "function" ? nextConfig(phase, nextOpts) : nextConfig;

    var experimental = _extends({}, normalizedConfig.experimental);

    if (experimental.reactMode === undefined && experimental.reactRoot === undefined) {
      // Default to true
      experimental.reactRoot = true;
    }

    var newConfig = Object.assign({}, normalizedConfig, {
      experimental: experimental,
      webpack: function webpack(config, options) {
        // ----------------------
        // Set up resolve aliases
        // ----------------------
        // config.resolve ??= {}
        // config.resolve.alias ??= {}
        // for (const [from, to] of Object.entries(resolveAliases.webpack)) {
        //   config.resolve.alias[from] = to
        // }
        if (options.isServer) {
          var originalEntry = config.entry;

          config.entry = async function () {
            return _extends({}, await originalEntry(), doesDbModuleExist() ? {
              "../blitz/db": "./db/index"
            } : {});
          };
        } else {
          var _config$module, _config$module$rules, _normalizedConfig$exp;

          config.module = (_config$module = config.module) != null ? _config$module : {};
          config.module.rules = (_config$module$rules = config.module.rules) != null ? _config$module$rules : [];
          var excluded = [/[\\/]npm-which[\\/]/, /[\\/]cross-spawn[\\/]/, /@blitzjs[\\/]config/, /blitz[\\/]packages[\\/]config/, /blitz2[\\/]packages[\\/]config/];
          excluded.forEach(function (excluded) {
            config.module.rules.push({
              test: excluded,
              use: {
                loader: "null-loader"
              }
            });
          });

          if ((_normalizedConfig$exp = normalizedConfig.experimental) != null && _normalizedConfig$exp.isomorphicResolverImports) {
            config.module.rules.push({
              test: /@blitzjs[\\/]core[\\/]server/,
              use: {
                loader: "null-loader"
              }
            });
            config.module.rules.push({
              test: /blitz[\\/]packages[\\/]core[\\/]server/,
              use: {
                loader: "null-loader"
              }
            });
            config.plugins.push(new options.webpack.NormalModuleReplacementPlugin(/[/\\]?(mutations|queries)[/\\]/, function (resource) {
              var request = resource.request;

              if (request.includes("_resolvers")) {
                return;
              }

              if (request.endsWith(".js") || request.endsWith(".ts") || request.endsWith(".jsx") || request.endsWith(".tsx")) {
                return;
              }

              resource.request = resource.request + ".client";
            }));
          } else {
            config.module.rules.push({
              issuer: /(mutations|queries)(?!.*\.client)/,
              resource: /_resolvers/,
              use: {
                loader: "null-loader"
              }
            });
          }
        }

        if (typeof normalizedConfig.webpack === "function") {
          return normalizedConfig.webpack(config, options);
        }

        return config;
      }
    });

    function doesDbModuleExist() {
      var projectRoot = getProjectRoot();
      return fs.existsSync(path.join(projectRoot, "db/index.js")) || fs.existsSync(path.join(projectRoot, "db/index.ts")) || fs.existsSync(path.join(projectRoot, "db/index.tsx"));
    }

    return newConfig;
  };
}

export { withBlitz };
