'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _extends = require('./extends-93eedbb0.cjs.dev.js');
var NextRouter = require('next/router');
var React = require('react');
var constants = require('./constants-bcd95f7a.cjs.dev.js');
var fromPairs = require('lodash.frompairs');
var routerContext = require('next/dist/next-server/lib/router-context');
var link = require('next/link');
var error = require('next/error');
var reactQuery = require('react-query');
var hydration = require('react-query/hydration');
var SuperJson = require('superjson');
var blitzData = require('./blitz-data-f63b7a88.cjs.dev.js');
var utils = require('next/dist/next-server/lib/utils');
var BadBehavior = require('bad-behavior');
var b64Lite = require('b64-lite');
var Head = require('next/head');
var router = require('next/dist/next-server/lib/router/router');
var _blitz = require('.blitz');
var crossSpawn = require('cross-spawn');
var which = require('npm-which');
require('@blitzjs/config');
require('htmlescape');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var NextRouter__default = /*#__PURE__*/_interopDefault(NextRouter);
var React__default = /*#__PURE__*/_interopDefault(React);
var fromPairs__default = /*#__PURE__*/_interopDefault(fromPairs);
var link__default = /*#__PURE__*/_interopDefault(link);
var error__default = /*#__PURE__*/_interopDefault(error);
var BadBehavior__default = /*#__PURE__*/_interopDefault(BadBehavior);
var Head__default = /*#__PURE__*/_interopDefault(Head);
var which__default = /*#__PURE__*/_interopDefault(which);

function useRouterQuery() {
  var router = NextRouter.useRouter();
  var query = React.useMemo(function () {
    var query = decode(router.asPath.split("?", 2)[1]);
    return query;
  }, [router.asPath]);
  return query;
}

function areQueryValuesEqual(value1, value2) {
  // Check if their type match
  if (typeof value1 !== typeof value2) {
    return false;
  }

  if (Array.isArray(value1) && Array.isArray(value2)) {
    if (value1.length !== value2.length) {
      return false;
    }

    for (var i = 0; i < value1.length; i++) {
      if (value1[i] !== value2[i]) {
        return false;
      }
    }

    return true;
  }

  return value1 === value2;
}

function extractRouterParams(routerQuery, query) {
  return fromPairs__default['default'](Object.entries(routerQuery).filter(function (_ref) {
    var key = _ref[0],
        value = _ref[1];
    return typeof query[key] === "undefined" || !areQueryValuesEqual(value, query[key]);
  }));
}
function useParams(returnType) {
  var router = NextRouter.useRouter();
  var query = useRouterQuery();
  var params = React.useMemo(function () {
    var rawParams = extractRouterParams(router.query, query);

    if (returnType === "string") {
      var _params = {};

      for (var _key in rawParams) {
        if (typeof rawParams[_key] === "string") {
          _params[_key] = rawParams[_key];
        }
      }

      return _params;
    }

    if (returnType === "number") {
      var _params2 = {};

      for (var _key2 in rawParams) {
        if (rawParams[_key2]) {
          var num = Number(rawParams[_key2]);
          _params2[_key2] = isNaN(num) ? undefined : num;
        }
      }

      return _params2;
    }

    if (returnType === "array") {
      var _params3 = {};

      for (var _key3 in rawParams) {
        var rawValue = rawParams[_key3];

        if (Array.isArray(rawParams[_key3])) {
          _params3[_key3] = rawValue;
        } else if (typeof rawValue === "string") {
          _params3[_key3] = [rawValue];
        }
      }

      return _params3;
    }

    return rawParams;
  }, [router.query, query, returnType]);
  return params;
}
function useParam(key, returnType) {
  var params = useParams(returnType);
  var value = params[key];
  return value;
}
/*
 * Based on the code of https://github.com/lukeed/qss
 */

var decodeString = function decodeString(str) {
  return decodeURIComponent(str.replace(/\+/g, "%20"));
};

function decode(str) {
  if (!str) return {};
  var out = {};

  for (var _iterator = constants._createForOfIteratorHelperLoose(str.split("&")), _step; !(_step = _iterator()).done;) {
    var current = _step.value;

    var _current$split = current.split("="),
        _key4 = _current$split[0],
        _current$split$ = _current$split[1],
        value = _current$split$ === void 0 ? "" : _current$split$;

    _key4 = decodeString(_key4);
    value = decodeString(value);
    if (_key4.length === 0) continue;

    if (_key4 in out) {
      out[_key4] = [].concat(out[_key4], value);
    } else {
      out[_key4] = value;
    }
  }

  return out;
}

var Router = NextRouter__default['default'];
function withRouter(WrappedComponent) {
  var Wrapper = function Wrapper(_ref) {
    var router = _ref.router;
    var query = useRouterQuery();
    var params = useParams();
    return /*#__PURE__*/React__default['default'].createElement(WrappedComponent, {
      router: _extends._extends({}, router, {
        query: query,
        params: params
      })
    });
  };

  return NextRouter.withRouter(Wrapper);
}
function useRouter() {
  var router = NextRouter.useRouter();
  var query = useRouterQuery();
  var params = useParams(); // TODO - we have to explicitly define the return type otherwise TS complains about
  // NextHistoryState and TransitionOptions not being exported from Next.js code

  return React__default['default'].useMemo(function () {
    return _extends._extends({}, router, {
      query: query,
      params: params
    });
  }, [params, query, router]);
}

function requestIdleCallbackShim(cb) {
  var start = Date.now();
  return setTimeout(function () {
    cb({
      didTimeout: false,
      timeRemaining: function timeRemaining() {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
}

var requestIdleCallback = blitzData.isClient ? window.requestIdleCallback || requestIdleCallbackShim : requestIdleCallbackShim;

var initializeQueryClient = function initializeQueryClient() {
  var suspenseEnabled = true;

  if (!process.env.CLI_COMMAND_CONSOLE && !process.env.CLI_COMMAND_DB) {
    var data = blitzData.getBlitzRuntimeData();
    suspenseEnabled = data.suspenseEnabled;
  }

  return new reactQuery.QueryClient({
    defaultOptions: {
      queries: {
        suspense: !!suspenseEnabled,
        retry: function retry(failureCount, error) {
          if (process.env.NODE_ENV !== "production") return false; // Retry (max. 3 times) only if network error detected

          if (error.message === "Network request failed" && failureCount <= 3) return true;
          return false;
        }
      }
    }
  });
}; // Create internal QueryClient instance

var queryClient = /*#__PURE__*/initializeQueryClient();

function isEnhancedResolverRpcClient(f) {
  return !!f._meta;
}

var getQueryCacheFunctions = function getQueryCacheFunctions(resolver, params) {
  return {
    setQueryData: function setQueryData(newData, opts) {
      if (opts === void 0) {
        opts = {
          refetch: true
        };
      }

      return _setQueryData(resolver, params, newData, opts);
    }
  };
};
var emptyQueryFn = /*#__PURE__*/function () {
  var fn = function fn() {
    return new Promise(function () {});
  };

  fn._meta = {
    name: "emptyQueryFn",
    type: "n/a",
    filePath: "n/a",
    apiUrl: ""
  };
  return fn;
}();

var isNotInUserTestEnvironment = function isNotInUserTestEnvironment() {
  if (process.env.JEST_WORKER_ID === undefined) return true;
  if (process.env.BLITZ_TEST_ENVIRONMENT !== undefined) return true;
  return false;
};

var validateQueryFn = function validateQueryFn(queryFn) {
  if (!isEnhancedResolverRpcClient(queryFn) && isNotInUserTestEnvironment()) {
    throw new Error("Either the file path to your resolver is incorrect (must be in a \"queries\" or \"mutations\" folder that isn't nested inside \"pages\" or \"api\") or you are trying to use Blitz's useQuery to fetch from third-party APIs (to do that, import useQuery directly from \"react-query\")");
  }
};

var sanitize = function sanitize(type) {
  return function (queryFn) {
    var _enhancedResolver$_me;

    validateQueryFn(queryFn);
    var enhancedResolver = queryFn;
    var queryFnName = type === "mutation" ? "useMutation" : "useQuery";

    if (((_enhancedResolver$_me = enhancedResolver._meta) == null ? void 0 : _enhancedResolver$_me.type) !== type && isNotInUserTestEnvironment()) {
      throw new Error("\"" + queryFnName + "\" was expected to be called with a " + type + " but was called with a \"" + enhancedResolver._meta.type + "\"");
    }

    return enhancedResolver;
  };
};

var sanitizeQuery = /*#__PURE__*/sanitize("query");
var sanitizeMutation = /*#__PURE__*/sanitize("mutation");
var getQueryKeyFromUrlAndParams = function getQueryKeyFromUrlAndParams(url, params) {
  var queryKey = [url];
  var args = typeof params === "function" ? params() : params;
  queryKey.push(SuperJson.serialize(args));
  return queryKey;
};
function getQueryKey(resolver, params) {
  if (typeof resolver === "undefined") {
    throw new Error("getQueryKey is missing the first argument - it must be a resolver function");
  }

  return getQueryKeyFromUrlAndParams(sanitizeQuery(resolver)._meta.apiUrl, params);
}
function invalidateQuery(resolver, params) {
  if (typeof resolver === "undefined") {
    throw new Error("invalidateQuery is missing the first argument - it must be a resolver function");
  }

  var fullQueryKey = getQueryKey(resolver, params);
  var queryKey;

  if (params) {
    queryKey = fullQueryKey;
  } else {
    // Params not provided, only use first query key item (url)
    queryKey = fullQueryKey[0];
  }

  return queryClient.invalidateQueries(queryKey);
}

function _setQueryData(resolver, params, newData, opts) {
  if (opts === void 0) {
    opts = {
      refetch: true
    };
  }

  if (typeof resolver === "undefined") {
    throw new Error("setQueryData is missing the first argument - it must be a resolver function");
  }

  var queryKey = getQueryKey(resolver, params);
  return new Promise(function (res) {
    queryClient.setQueryData(queryKey, newData);
    var result;

    if (opts.refetch) {
      result = invalidateQuery(resolver, params);
    }

    if (blitzData.isClient) {
      // Fix for https://github.com/blitz-js/blitz/issues/1174
      requestIdleCallback(function () {
        res(result);
      });
    } else {
      res(result);
    }
  });
}

var BlitzProvider = function BlitzProvider(_ref) {
  var client = _ref.client,
      _ref$contextSharing = _ref.contextSharing,
      contextSharing = _ref$contextSharing === void 0 ? false : _ref$contextSharing,
      dehydratedState = _ref.dehydratedState,
      hydrateOptions = _ref.hydrateOptions,
      children = _ref.children;
  var queryClientRef = React.useRef();

  if (!queryClientRef.current) {
    queryClientRef.current = queryClient;
  }

  return /*#__PURE__*/React__default['default'].createElement(reactQuery.QueryClientProvider, {
    client: client != null ? client : queryClient,
    contextSharing: contextSharing
  }, /*#__PURE__*/React__default['default'].createElement(hydration.Hydrate, {
    state: dehydratedState,
    options: hydrateOptions
  }, children));
};

// Taken from https://github.com/HenrikJoreteg/cookie-getter
// simple commonJS cookie reader, best perf according to http://jsperf.com/cookie-parsing
function readCookie(name) {
  if (typeof document === "undefined") return null;
  var cookie = document.cookie;
  var setPos = cookie.search(new RegExp("\\b" + name + "="));
  var stopPos = cookie.indexOf(";", setPos);
  var res;
  if (!~setPos) return null;
  res = decodeURIComponent(cookie.substring(setPos, ~stopPos ? stopPos : undefined).split("=")[1]);
  return res.charAt(0) === "{" ? JSON.parse(res) : res;
}
var setCookie = function setCookie(name, value, expires) {
  var result = name + "=" + value + ";path=/;expires=" + expires;
  document.cookie = result;
};
var deleteCookie = function deleteCookie(name) {
  return setCookie(name, "", "Thu, 01 Jan 1970 00:00:01 GMT");
};

function assert(condition, message) {
  if (!condition) throw new Error(message);
}

var parsePublicDataToken = function parsePublicDataToken(token) {
  assert(token, "[parsePublicDataToken] Failed: token is empty");
  var publicDataStr = b64Lite.fromBase64(token);

  try {
    var publicData = JSON.parse(publicDataStr);
    return {
      publicData: publicData
    };
  } catch (error) {
    throw new Error("[parsePublicDataToken] Failed to parse publicDataStr: " + publicDataStr);
  }
};

var PublicDataStore = /*#__PURE__*/function () {
  function PublicDataStore() {
    var _this = this;

    this.eventKey = constants.LOCALSTORAGE_PREFIX + "publicDataUpdated";
    this.emptyPublicData = {
      userId: null
    };
    this.observable = BadBehavior__default['default']();

    if (typeof window !== "undefined") {
      // Set default value & prevent infinite loop
      this.updateState(undefined, {
        suppressEvent: true
      });
      window.addEventListener("storage", function (event) {
        if (event.key === _this.eventKey) {
          // Prevent infinite loop
          _this.updateState(undefined, {
            suppressEvent: true
          });
        }
      });
    }
  }

  var _proto = PublicDataStore.prototype;

  _proto.updateState = function updateState(value, opts) {
    // We use localStorage as a message bus between tabs.
    // Setting the current time in ms will cause other tabs to receive the `storage` event
    if (!(opts != null && opts.suppressEvent)) {
      // Prevent infinite loop
      try {
        localStorage.setItem(this.eventKey, Date.now().toString());
      } catch (err) {
        console.error("LocalStorage is not available", err);
      }
    }

    this.observable.next(value != null ? value : this.getData());
  };

  _proto.clear = function clear() {
    deleteCookie(constants.COOKIE_PUBLIC_DATA_TOKEN());
    this.updateState(this.emptyPublicData);
  };

  _proto.getData = function getData() {
    var publicDataToken = this.getToken();

    if (!publicDataToken) {
      return this.emptyPublicData;
    }

    var _parsePublicDataToken = parsePublicDataToken(publicDataToken),
        publicData = _parsePublicDataToken.publicData;

    return publicData;
  };

  _proto.getToken = function getToken() {
    return readCookie(constants.COOKIE_PUBLIC_DATA_TOKEN());
  };

  return PublicDataStore;
}();

var publicDataStore = /*#__PURE__*/new PublicDataStore();

var getAntiCSRFToken = function getAntiCSRFToken() {
  return readCookie(constants.COOKIE_CSRF_TOKEN()) || readCookie(constants.COOKIE_LEGACY_CSRF_TOKEN());
};
var useSession = function useSession(options) {
  var _options$suspense, _options;

  if (options === void 0) {
    options = {};
  }

  var suspense = (_options$suspense = (_options = options) == null ? void 0 : _options.suspense) != null ? _options$suspense : blitzData.getBlitzRuntimeData().suspenseEnabled;
  var initialState;

  if (options.initialPublicData) {
    initialState = _extends._extends({}, options.initialPublicData, {
      isLoading: false
    });
  } else if (suspense) {
    if (blitzData.isServer) {
      throw new Promise(function (_) {});
    } else {
      initialState = _extends._extends({}, publicDataStore.getData(), {
        isLoading: false
      });
    }
  } else {
    initialState = _extends._extends({}, publicDataStore.emptyPublicData, {
      isLoading: true
    });
  }

  var _useState = React.useState(initialState),
      session = _useState[0],
      setSession = _useState[1];

  React.useEffect(function () {
    // Initialize on mount
    setSession(_extends._extends({}, publicDataStore.getData(), {
      isLoading: false
    }));
    var subscription = publicDataStore.observable.subscribe(function (data) {
      return setSession(_extends._extends({}, data, {
        isLoading: false
      }));
    });
    return subscription.unsubscribe;
  }, []);
  return session;
};
var useAuthenticatedSession = function useAuthenticatedSession(options) {
  if (options === void 0) {
    options = {};
  }

  useAuthorize();
  return useSession(options);
};
var useAuthorize = function useAuthorize() {
  useAuthorizeIf(true);
};
var useAuthorizeIf = function useAuthorizeIf(condition) {
  React.useEffect(function () {
    if (condition && !publicDataStore.getData().userId) {
      var error = new constants.AuthenticationError();
      delete error.stack;
      throw error;
    }
  });
};
var useRedirectAuthenticated = function useRedirectAuthenticated(to) {
  if (typeof window !== "undefined" && publicDataStore.getData().userId) {
    window.location.replace(to);
  }
};

var customCSS = "\n  body::before {\n    content: \"\";\n    display: block;\n    position: fixed;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n    z-index: 99999;\n    background-color: white;\n  }\n\n  .blitz-first-render-complete body::before {\n    display: none;\n  }\n";
var noscriptCSS = "\n  body::before {\n    content: none\n  }\n";

var NoPageFlicker = function NoPageFlicker() {
  return /*#__PURE__*/React__default['default'].createElement(Head__default['default'], null, /*#__PURE__*/React__default['default'].createElement("style", {
    dangerouslySetInnerHTML: {
      __html: customCSS
    }
  }), /*#__PURE__*/React__default['default'].createElement("noscript", null, /*#__PURE__*/React__default['default'].createElement("style", {
    dangerouslySetInnerHTML: {
      __html: noscriptCSS
    }
  })));
};

function withBlitzInnerWrapper(Page) {
  var BlitzInnerRoot = function BlitzInnerRoot(props) {
    useAuthorizeIf(Page.authenticate === true);
    return /*#__PURE__*/React__default['default'].createElement(Page, props);
  };

  for (var _i = 0, _Object$entries = Object.entries(Page); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _Object$entries[_i],
        key = _Object$entries$_i[0],
        value = _Object$entries$_i[1];
    BlitzInnerRoot[key] = value;
  }

  if (process.env.NODE_ENV !== "production") {
    BlitzInnerRoot.displayName = "BlitzInnerRoot";
  }

  return BlitzInnerRoot;
}
function withBlitzAppRoot(UserAppRoot) {
  var BlitzOuterRoot = function BlitzOuterRoot(props) {
    if (typeof window !== "undefined") {
      if (publicDataStore.getData().userId) {
        var redirectAuthenticatedTo = props.Component.redirectAuthenticatedTo;

        if (redirectAuthenticatedTo) {
          if (typeof redirectAuthenticatedTo !== "string") {
            redirectAuthenticatedTo = utils.formatWithValidation(redirectAuthenticatedTo);
          }

          window.location.replace(redirectAuthenticatedTo);
        }
      } else {
        var authenticate = props.Component.authenticate;

        if (authenticate && typeof authenticate === "object" && authenticate.redirectTo) {
          var redirectTo = authenticate.redirectTo;

          if (typeof redirectTo !== "string") {
            redirectTo = utils.formatWithValidation(redirectTo);
          }

          var url = new URL(redirectTo, window.location.href);
          url.searchParams.append("next", window.location.pathname);
          window.location.replace(url.toString());
        }
      }
    }

    var component = React__default['default'].useMemo(function () {
      return withBlitzInnerWrapper(props.Component);
    }, [props.Component]);
    var noPageFlicker = props.Component.suppressFirstRenderFlicker || props.Component.authenticate !== undefined || props.Component.redirectAuthenticatedTo;
    React.useEffect(function () {
      document.documentElement.classList.add("blitz-first-render-complete");
    }, []);
    return /*#__PURE__*/React__default['default'].createElement(BlitzProvider, {
      dehydratedState: props.pageProps.dehydratedState
    }, noPageFlicker && /*#__PURE__*/React__default['default'].createElement(NoPageFlicker, null), /*#__PURE__*/React__default['default'].createElement(UserAppRoot, _extends._extends({}, props, {
      Component: component
    })));
  };

  return BlitzOuterRoot;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function useQuery(queryFn, params, options) {
  var _options$enabled, _options, _options2, _options3;

  if (options === void 0) {
    options = {};
  }

  if (typeof queryFn === "undefined") {
    throw new Error("useQuery is missing the first argument - it must be a query function");
  }

  var suspenseConfig = blitzData.getBlitzRuntimeData().suspenseEnabled;
  var enabled = blitzData.isServer && suspenseConfig ? false : (_options$enabled = (_options = options) == null ? void 0 : _options.enabled) != null ? _options$enabled : ((_options2 = options) == null ? void 0 : _options2.enabled) !== null;
  var suspense = enabled === false ? false : (_options3 = options) == null ? void 0 : _options3.suspense;
  var session = useSession({
    suspense: suspense
  });

  if (session.isLoading) {
    enabled = false;
  }

  var routerIsReady = useRouter().isReady || blitzData.isServer && suspenseConfig;
  var enhancedResolverRpcClient = sanitizeQuery(queryFn);
  var queryKey = getQueryKey(queryFn, params);

  var _useReactQuery = reactQuery.useQuery(_extends._extends({
    queryKey: routerIsReady ? queryKey : ["_routerNotReady_"],
    queryFn: routerIsReady ? function () {
      return enhancedResolverRpcClient(params, {
        fromQueryHook: true
      });
    } : emptyQueryFn
  }, options, {
    enabled: enabled
  })),
      data = _useReactQuery.data,
      queryRest = _objectWithoutPropertiesLoose(_useReactQuery, ["data"]);

  if (queryRest.isIdle && blitzData.isServer && suspenseConfig !== false && !data && (!options || !("suspense" in options) || options.suspense) && (!options || !("enabled" in options) || options.enabled)) {
    throw new Promise(function () {});
  }

  var rest = _extends._extends({}, queryRest, getQueryCacheFunctions(queryFn, params)); // return [data, rest as RestQueryResult<TResult>]


  return [data, rest];
} // -------------------------
// usePaginatedQuery
// -------------------------

function usePaginatedQuery(queryFn, params, options) {
  var _options4, _options5, _options6;

  if (options === void 0) {
    options = {};
  }

  if (typeof queryFn === "undefined") {
    throw new Error("usePaginatedQuery is missing the first argument - it must be a query function");
  }

  var suspense = ((_options4 = options) == null ? void 0 : _options4.enabled) === false || ((_options5 = options) == null ? void 0 : _options5.enabled) === null ? false : (_options6 = options) == null ? void 0 : _options6.suspense;
  var session = useSession({
    suspense: suspense
  });

  if (session.isLoading) {
    options.enabled = false;
  }

  var routerIsReady = useRouter().isReady;
  var enhancedResolverRpcClient = sanitizeQuery(queryFn);
  var queryKey = getQueryKey(queryFn, params);

  var _useReactQuery2 = reactQuery.useQuery(_extends._extends({
    queryKey: routerIsReady ? queryKey : ["_routerNotReady_"],
    queryFn: routerIsReady ? function () {
      return enhancedResolverRpcClient(params, {
        fromQueryHook: true
      });
    } : emptyQueryFn
  }, options, {
    keepPreviousData: true
  })),
      data = _useReactQuery2.data,
      queryRest = _objectWithoutPropertiesLoose(_useReactQuery2, ["data"]);

  var rest = _extends._extends({}, queryRest, getQueryCacheFunctions(queryFn, params)); // return [data, rest as RestPaginatedResult<TResult>]


  return [data, rest];
} // -------------------------
// useInfiniteQuery
// -------------------------

function useInfiniteQuery(queryFn, getQueryParams, options) {
  if (typeof queryFn === "undefined") {
    throw new Error("useInfiniteQuery is missing the first argument - it must be a query function");
  }

  var suspense = (options == null ? void 0 : options.enabled) === false || (options == null ? void 0 : options.enabled) === null ? false : options == null ? void 0 : options.suspense;
  var session = useSession({
    suspense: suspense
  });

  if (session.isLoading) {
    options.enabled = false;
  }

  var routerIsReady = useRouter().isReady;
  var enhancedResolverRpcClient = sanitizeQuery(queryFn);
  var queryKey = getQueryKey(queryFn, getQueryParams);

  var _useInfiniteReactQuer = reactQuery.useInfiniteQuery(_extends._extends({
    // we need an extra cache key for infinite loading so that the cache for
    // for this query is stored separately since the hook result is an array of results.
    // Without this cache for usePaginatedQuery and this will conflict and break.
    queryKey: routerIsReady ? [].concat(queryKey, ["infinite"]) : ["_routerNotReady_"],
    queryFn: routerIsReady ? function (_ref) {
      var pageParam = _ref.pageParam;
      return enhancedResolverRpcClient(getQueryParams(pageParam), {
        fromQueryHook: true
      });
    } : emptyQueryFn
  }, options)),
      data = _useInfiniteReactQuer.data,
      queryRest = _objectWithoutPropertiesLoose(_useInfiniteReactQuer, ["data"]);

  var rest = _extends._extends({}, queryRest, getQueryCacheFunctions(queryFn, getQueryParams), {
    pageParams: data == null ? void 0 : data.pageParams
  });

  return [data == null ? void 0 : data.pages, rest];
}

var executeRpcCall = function executeRpcCall(apiUrl, params, opts) {
  if (opts === void 0) {
    opts = {};
  }

  if (!opts.fromQueryHook && !opts.fromInvoke) {
    console.warn("[Deprecation] Directly calling queries/mutations is deprecated in favor of invoke(queryFn, params)");
  }

  if (blitzData.isServer) return Promise.resolve();
  blitzData.clientDebug("Starting request for", apiUrl, "with", params, "and", opts);
  var headers = {
    "Content-Type": "application/json"
  };
  var antiCSRFToken = getAntiCSRFToken();

  if (antiCSRFToken) {
    blitzData.clientDebug("Adding antiCSRFToken cookie header", antiCSRFToken);
    headers[constants.HEADER_CSRF] = antiCSRFToken;
  } else {
    blitzData.clientDebug("No antiCSRFToken cookie found");
  }

  var serialized;

  if (opts.alreadySerialized) {
    // params is already serialized with superjson when it gets here
    // We have to serialize the params before passing to react-query in the query key
    // because otherwise react-query will use JSON.parse(JSON.stringify)
    // so by the time the arguments come here the real JS objects are lost
    serialized = params;
  } else {
    serialized = SuperJson.serialize(params);
  } // Create a new AbortController instance for this request


  var controller = new AbortController();
  var promise = window.fetch(router.addBasePath(apiUrl), {
    method: "POST",
    headers: headers,
    credentials: "include",
    redirect: "follow",
    body: JSON.stringify({
      params: serialized.json,
      meta: {
        params: serialized.meta
      }
    }),
    signal: controller.signal
  }).then(async function (response) {
    blitzData.clientDebug("Received request for", apiUrl);

    if (response.headers) {
      if (response.headers.get(constants.HEADER_PUBLIC_DATA_TOKEN)) {
        publicDataStore.updateState();
        blitzData.clientDebug("Public data updated");
      }

      if (response.headers.get(constants.HEADER_SESSION_REVOKED)) {
        blitzData.clientDebug("Session revoked");
        await queryClient.cancelQueries();
        await queryClient.resetQueries();
        queryClient.getMutationCache().clear();
        publicDataStore.clear();
      }

      if (response.headers.get(constants.HEADER_SESSION_CREATED)) {
        blitzData.clientDebug("Session created");
        await queryClient.invalidateQueries("");
      }

      if (response.headers.get(constants.HEADER_CSRF_ERROR)) {
        var err = new constants.CSRFTokenMismatchError();
        delete err.stack;
        throw err;
      }
    }

    if (!response.ok) {
      var error = new Error(response.statusText);
      error.statusCode = response.status;
      error.path = apiUrl;
      delete error.stack;
      throw error;
    } else {
      var payload;

      try {
        payload = await response.json();
      } catch (error) {
        var _err = new Error("Failed to parse json from " + apiUrl);

        delete _err.stack;
      }

      if (payload.error) {
        var _payload$meta;

        var _error = SuperJson.deserialize({
          json: payload.error,
          meta: (_payload$meta = payload.meta) == null ? void 0 : _payload$meta.error
        }); // We don't clear the publicDataStore for anonymous users


        if (_error.name === "AuthenticationError" && publicDataStore.getData().userId) {
          publicDataStore.clear();
        }

        var prismaError = _error.message.match(/invalid.*prisma.*invocation/i);

        if (prismaError && !("code" in _error)) {
          _error = new Error(prismaError[0]);
          _error.statusCode = 500;
        }

        throw _error;
      } else {
        var _payload$meta2;

        var data = SuperJson.deserialize({
          json: payload.result,
          meta: (_payload$meta2 = payload.meta) == null ? void 0 : _payload$meta2.result
        });

        if (!opts.fromQueryHook) {
          var queryKey = getQueryKeyFromUrlAndParams(apiUrl, params);
          queryClient.setQueryData(queryKey, data);
        }

        return data;
      }
    }
  }); // Disable react-query request cancellation for now
  // Having too many weird bugs with it enabled
  // promise.cancel = () => controller.abort()

  return promise;
};

executeRpcCall.warm = function (apiUrl) {
  if (!blitzData.isClient) {
    return;
  }

  return window.fetch(router.addBasePath(apiUrl), {
    method: "HEAD"
  });
};

var getApiUrlFromResolverFilePath = function getApiUrlFromResolverFilePath(resolverFilePath) {
  return resolverFilePath.replace(/^app\/_resolvers/, "/api");
};

function getIsomorphicEnhancedResolver( // resolver is undefined on the client
resolver, resolverFilePath, resolverName, resolverType, target, options) {
  if (target === void 0) {
    target = blitzData.isClient ? "client" : "server";
  }

  if (options === void 0) {
    options = {};
  }

  var apiUrl = getApiUrlFromResolverFilePath(resolverFilePath);

  if (target === "client") {
    var resolverRpc = function resolverRpc(params, opts) {
      return executeRpcCall(apiUrl, params, opts);
    };

    var enhancedResolverRpcClient = resolverRpc;
    enhancedResolverRpcClient._meta = {
      name: resolverName,
      type: resolverType,
      filePath: resolverFilePath,
      apiUrl: apiUrl
    }; // Warm the lambda

    if (options.warmApiEndpoints) {
      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      executeRpcCall.warm(apiUrl);
    }

    return enhancedResolverRpcClient;
  } else {
    if (!resolver) throw new Error("resolver is missing on the server");
    var enhancedResolver = resolver["default"];
    enhancedResolver.middleware = resolver.middleware;
    enhancedResolver.config = resolver.config;
    enhancedResolver._meta = {
      name: resolverName,
      type: resolverType,
      filePath: resolverFilePath,
      apiUrl: apiUrl
    };
    return enhancedResolver;
  }
}

/*
 * We have to override react-query's MutationFunction and MutationResultPair
 * types so because we have throwOnError:true by default. And by the RQ types
 * have the mutate function result typed as TData|undefined which isn't typed
 * properly with throwOnError.
 *
 * So this fixes that.
 */

function useMutation(mutationResolver, config) {
  var enhancedResolverRpcClient = sanitizeMutation(mutationResolver);

  var _useReactQueryMutatio = reactQuery.useMutation(function (variables) {
    return enhancedResolverRpcClient(variables, {
      fromQueryHook: true
    });
  }, _extends._extends({
    throwOnError: true
  }, config));
      _useReactQueryMutatio.mutate;
      var mutateAsync = _useReactQueryMutatio.mutateAsync,
      rest = _objectWithoutPropertiesLoose(_useReactQueryMutatio, ["mutate", "mutateAsync"]);

  return [mutateAsync, rest];
}

function invoke(queryFn, params) {
  if (typeof queryFn === "undefined") {
    throw new Error("invoke is missing the first argument - it must be a query or mutation function");
  }

  if (blitzData.isClient) {
    var fn = queryFn;
    return fn(params, {
      fromInvoke: true
    });
  } else {
    var _fn = queryFn;
    return _fn(params);
  }
}

var enhancePrisma = function enhancePrisma(client) {
  return new Proxy(client, {
    construct: function construct(target, args) {
      if (typeof window !== "undefined" && process.env.JEST_WORKER_ID === undefined) {
        // Return empty object if in the browser
        // Skip in Jest tests because window is defined in Jest tests
        return {};
      }

      if (!global._blitz_prismaClient) {
        var _client = constants._construct(target, args);

        _client.$reset = async function reset() {
          if (process.env.NODE_ENV === "production") {
            throw new Error("You are calling db.$reset() in a production environment. We think you probably didn't mean to do that, so we are throwing this error instead of destroying your life's work.");
          }

          var prismaBin = which__default['default'](process.cwd()).sync("prisma");
          await new Promise(function (res, rej) {
            var process = crossSpawn.spawn(prismaBin, ["migrate", "reset", "--force", "--skip-generate"], {
              stdio: "ignore"
            });
            process.on("exit", function (code) {
              return code === 0 ? res(0) : rej(code);
            });
          });

          global._blitz_prismaClient.$disconnect();
        };

        global._blitz_prismaClient = _client;
      }

      return global._blitz_prismaClient;
    }
  });
};

Object.defineProperty(exports, 'createRouter', {
  enumerable: true,
  get: function () {
    return NextRouter.createRouter;
  }
});
Object.defineProperty(exports, 'makePublicRouterInstance', {
  enumerable: true,
  get: function () {
    return NextRouter.makePublicRouterInstance;
  }
});
exports.AuthenticationError = constants.AuthenticationError;
exports.AuthorizationError = constants.AuthorizationError;
exports.COOKIE_ANONYMOUS_SESSION_TOKEN = constants.COOKIE_ANONYMOUS_SESSION_TOKEN;
exports.COOKIE_CSRF_TOKEN = constants.COOKIE_CSRF_TOKEN;
exports.COOKIE_LEGACY_CSRF_TOKEN = constants.COOKIE_LEGACY_CSRF_TOKEN;
exports.COOKIE_PUBLIC_DATA_TOKEN = constants.COOKIE_PUBLIC_DATA_TOKEN;
exports.COOKIE_REFRESH_TOKEN = constants.COOKIE_REFRESH_TOKEN;
exports.COOKIE_SESSION_TOKEN = constants.COOKIE_SESSION_TOKEN;
exports.CSRFTokenMismatchError = constants.CSRFTokenMismatchError;
exports.HANDLE_SEPARATOR = constants.HANDLE_SEPARATOR;
exports.HEADER_CSRF = constants.HEADER_CSRF;
exports.HEADER_CSRF_ERROR = constants.HEADER_CSRF_ERROR;
exports.HEADER_PUBLIC_DATA_TOKEN = constants.HEADER_PUBLIC_DATA_TOKEN;
exports.HEADER_SESSION_CREATED = constants.HEADER_SESSION_CREATED;
exports.HEADER_SESSION_REVOKED = constants.HEADER_SESSION_REVOKED;
exports.LOCALSTORAGE_PREFIX = constants.LOCALSTORAGE_PREFIX;
exports.NotFoundError = constants.NotFoundError;
exports.PaginationArgumentError = constants.PaginationArgumentError;
exports.SESSION_TOKEN_VERSION_0 = constants.SESSION_TOKEN_VERSION_0;
exports.SESSION_TYPE_ANONYMOUS_JWT = constants.SESSION_TYPE_ANONYMOUS_JWT;
exports.SESSION_TYPE_OPAQUE_TOKEN_SIMPLE = constants.SESSION_TYPE_OPAQUE_TOKEN_SIMPLE;
exports.TOKEN_SEPARATOR = constants.TOKEN_SEPARATOR;
Object.defineProperty(exports, 'RouterContext', {
  enumerable: true,
  get: function () {
    return routerContext.RouterContext;
  }
});
Object.defineProperty(exports, 'Link', {
  enumerable: true,
  get: function () {
    return link__default['default'];
  }
});
Object.defineProperty(exports, 'ErrorComponent', {
  enumerable: true,
  get: function () {
    return error__default['default'];
  }
});
Object.defineProperty(exports, 'QueryClient', {
  enumerable: true,
  get: function () {
    return reactQuery.QueryClient;
  }
});
Object.defineProperty(exports, 'useQueryErrorResetBoundary', {
  enumerable: true,
  get: function () {
    return reactQuery.useQueryErrorResetBoundary;
  }
});
Object.defineProperty(exports, 'dehydrate', {
  enumerable: true,
  get: function () {
    return hydration.dehydrate;
  }
});
exports.getBlitzRuntimeData = blitzData.getBlitzRuntimeData;
Object.defineProperty(exports, 'Routes', {
  enumerable: true,
  get: function () {
    return _blitz.Routes;
  }
});
exports.BlitzProvider = BlitzProvider;
exports.Router = Router;
exports.enhancePrisma = enhancePrisma;
exports.getAntiCSRFToken = getAntiCSRFToken;
exports.getIsomorphicEnhancedResolver = getIsomorphicEnhancedResolver;
exports.getQueryKey = getQueryKey;
exports.invalidateQuery = invalidateQuery;
exports.invoke = invoke;
exports.queryClient = queryClient;
exports.setQueryData = _setQueryData;
exports.useAuthenticatedSession = useAuthenticatedSession;
exports.useAuthorize = useAuthorize;
exports.useInfiniteQuery = useInfiniteQuery;
exports.useMutation = useMutation;
exports.usePaginatedQuery = usePaginatedQuery;
exports.useParam = useParam;
exports.useParams = useParams;
exports.useQuery = useQuery;
exports.useRedirectAuthenticated = useRedirectAuthenticated;
exports.useRouter = useRouter;
exports.useRouterQuery = useRouterQuery;
exports.useSession = useSession;
exports.withBlitzAppRoot = withBlitzAppRoot;
exports.withRouter = withRouter;
