/// <reference types="node" />
import { IncomingMessage, ServerResponse } from "http";
import { AppProps as NextAppProps } from "next/app";
import { NextApiHandler, NextApiRequest, NextApiResponse, NextComponentType, NextPage, NextPageContext } from "next/types";
import type { UrlObject } from "url";
import { BlitzRuntimeData } from "./blitz-data";
export type { GetServerSideProps, GetServerSidePropsContext, GetServerSidePropsResult, GetStaticPaths, GetStaticPathsContext, GetStaticPathsResult, GetStaticProps, GetStaticPropsContext, GetStaticPropsResult, InferGetServerSidePropsType, InferGetStaticPropsType, PageConfig, Redirect, } from "next";
export declare type BlitzApiHandler<T = any> = NextApiHandler<T>;
export declare type BlitzApiRequest = NextApiRequest;
export declare type BlitzApiResponse<T = any> = NextApiResponse<T>;
export declare type BlitzPageContext = NextPageContext;
export declare type BlitzComponentType<C = NextPageContext, IP = {}, P = {}> = NextComponentType<C, IP, P>;
export interface AppProps<P = {}> extends NextAppProps<P> {
    Component: BlitzComponentType<NextPageContext, any, P> & BlitzPage;
}
export declare type BlitzPage<P = {}, IP = P> = NextPage<P, IP> & {
    getLayout?: (component: JSX.Element) => JSX.Element;
    authenticate?: boolean | {
        redirectTo?: string | RouteUrlObject;
    };
    suppressFirstRenderFlicker?: boolean;
    redirectAuthenticatedTo?: string | RouteUrlObject;
};
export interface RouteUrlObject extends Pick<UrlObject, "pathname" | "query"> {
    pathname: string;
}
export interface DefaultCtx {
}
export interface Ctx extends DefaultCtx {
}
export interface MiddlewareRequest extends BlitzApiRequest {
    protocol?: string;
}
export interface MiddlewareResponse<C = Ctx> extends BlitzApiResponse {
    /**
     * This will be passed as the second argument to Blitz queries/mutations.
     *
     * You must set blitzCtx BEFORE calling next()
     */
    blitzCtx: C;
    /**
     * This is the exact result returned from the Blitz query/mutation
     *
     * You must first `await next()` before reading this
     */
    blitzResult: unknown;
}
export declare type MiddlewareNext = (error?: Error) => Promise<void> | void;
export declare type Middleware<MiddlewareConfig = {}> = {
    (req: MiddlewareRequest, res: MiddlewareResponse, next: MiddlewareNext): Promise<void> | void;
    type?: string;
    config?: MiddlewareConfig;
};
/**
 * Infer the type of the parameter from function that takes a single argument
 */
export declare type FirstParam<F extends QueryFn> = Parameters<F>[0];
/**
 * If type has a Promise, unwrap it. Otherwise return the original type
 */
export declare type Await<T> = T extends PromiseLike<infer U> ? U : T;
/**
 * Ensure the type is a promise
 */
export declare type EnsurePromise<T> = T extends PromiseLike<unknown> ? T : Promise<T>;
/**
 * Get the return type of a function which returns a Promise.
 */
export declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = Await<ReturnType<T>>;
export interface CancellablePromise<T> extends Promise<T> {
    cancel?: Function;
}
export declare type QueryFn = (...args: any) => Promise<any>;
export declare type Dict<T> = Record<string, T | undefined>;
export declare type ParsedUrlQuery = Dict<string | string[]>;
export declare type ParsedUrlQueryValue = string | string[] | undefined;
export declare type Options = {
    fromQueryHook?: boolean;
};
export declare type ConnectMiddleware = (req: IncomingMessage, res: ServerResponse, next: (error?: Error) => void) => void;
export declare type Resolver<TInput, TResult> = (input: TInput, ctx?: any) => Promise<TResult>;
export declare type ResolverModule<TInput, TResult> = {
    default: Resolver<TInput, TResult>;
    middleware?: Middleware[];
    config?: Record<string, any>;
};
export declare type RpcOptions = {
    fromQueryHook?: boolean;
    fromInvoke?: boolean;
    alreadySerialized?: boolean;
};
export declare type ResolverRpc<TInput, TResult> = (input?: TInput, opts?: RpcOptions) => CancellablePromise<TResult>;
export interface ResolverRpcExecutor<TInput, TResult> {
    (apiUrl: string, params: TInput, opts?: RpcOptions): CancellablePromise<TResult>;
    warm: (apiUrl: string) => undefined | Promise<unknown>;
}
export declare type ResolverType = "query" | "mutation";
export interface ResolverEnhancement {
    config?: Record<string, any>;
    _meta: {
        name: string;
        type: ResolverType;
        filePath: string;
        apiUrl: string;
    };
}
export interface EnhancedResolver<TInput, TResult> extends Resolver<TInput, TResult>, ResolverEnhancement {
    middleware?: Middleware[];
}
export interface EnhancedResolverRpcClient<TInput, TResult> extends ResolverRpc<TInput, TResult>, ResolverEnhancement {
}
declare type RequestIdleCallbackHandle = any;
declare type RequestIdleCallbackOptions = {
    timeout: number;
};
declare type RequestIdleCallbackDeadline = {
    readonly didTimeout: boolean;
    timeRemaining: () => number;
};
declare global {
    namespace NodeJS {
        interface Global {
            __BLITZ_DATA__: BlitzRuntimeData;
            _blitz_prismaClient: any;
        }
    }
    interface Window {
        __BLITZ_DATA__: BlitzRuntimeData;
        requestIdleCallback: (callback: (deadline: RequestIdleCallbackDeadline) => void, opts?: RequestIdleCallbackOptions) => RequestIdleCallbackHandle;
        cancelIdleCallback: (handle: RequestIdleCallbackHandle) => void;
    }
}
export declare type InvokeWithMiddlewareConfig = {
    req: IncomingMessage;
    res: ServerResponse;
    middleware?: Middleware[];
    [prop: string]: any;
};
export interface ErrorFallbackProps {
    error: Error & Record<any, any>;
    resetErrorBoundary: (...args: Array<unknown>) => void;
}
