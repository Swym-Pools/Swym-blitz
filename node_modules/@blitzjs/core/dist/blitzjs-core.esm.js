import { _ as _extends } from './extends-1b905a27.esm.js';
import NextRouter, { useRouter as useRouter$1, withRouter as withRouter$1 } from 'next/router';
export { createRouter, makePublicRouterInstance } from 'next/router';
import React, { useMemo, useRef, useState, useEffect } from 'react';
import { _ as _createForOfIteratorHelperLoose, L as LOCALSTORAGE_PREFIX, C as COOKIE_PUBLIC_DATA_TOKEN, a as COOKIE_CSRF_TOKEN, b as COOKIE_LEGACY_CSRF_TOKEN, A as AuthenticationError, H as HEADER_PUBLIC_DATA_TOKEN, c as HEADER_SESSION_REVOKED, d as HEADER_SESSION_CREATED, e as HEADER_CSRF_ERROR, f as CSRFTokenMismatchError, g as HEADER_CSRF, h as _construct } from './constants-52bb98df.esm.js';
export { A as AuthenticationError, i as AuthorizationError, m as COOKIE_ANONYMOUS_SESSION_TOKEN, a as COOKIE_CSRF_TOKEN, b as COOKIE_LEGACY_CSRF_TOKEN, C as COOKIE_PUBLIC_DATA_TOKEN, o as COOKIE_REFRESH_TOKEN, n as COOKIE_SESSION_TOKEN, f as CSRFTokenMismatchError, j as HANDLE_SEPARATOR, g as HEADER_CSRF, e as HEADER_CSRF_ERROR, H as HEADER_PUBLIC_DATA_TOKEN, d as HEADER_SESSION_CREATED, c as HEADER_SESSION_REVOKED, L as LOCALSTORAGE_PREFIX, N as NotFoundError, P as PaginationArgumentError, l as SESSION_TOKEN_VERSION_0, k as SESSION_TYPE_ANONYMOUS_JWT, S as SESSION_TYPE_OPAQUE_TOKEN_SIMPLE, T as TOKEN_SEPARATOR } from './constants-52bb98df.esm.js';
import fromPairs from 'lodash.frompairs';
export { RouterContext } from 'next/dist/next-server/lib/router-context';
export { default as Link } from 'next/link';
export { default as ErrorComponent } from 'next/error';
import { QueryClient, QueryClientProvider, useQuery as useQuery$1, useInfiniteQuery as useInfiniteQuery$1, useMutation as useMutation$1 } from 'react-query';
export { QueryClient, useQueryErrorResetBoundary } from 'react-query';
import { Hydrate } from 'react-query/hydration';
export { dehydrate } from 'react-query/hydration';
import { serialize, deserialize } from 'superjson';
import { i as isClient, g as getBlitzRuntimeData, a as isServer, c as clientDebug } from './blitz-data-484e455b.esm.js';
export { g as getBlitzRuntimeData } from './blitz-data-484e455b.esm.js';
import { formatWithValidation } from 'next/dist/next-server/lib/utils';
import BadBehavior from 'bad-behavior';
import { fromBase64 } from 'b64-lite';
import Head from 'next/head';
import { addBasePath } from 'next/dist/next-server/lib/router/router';
export { Routes } from '.blitz';
import { spawn } from 'cross-spawn';
import which from 'npm-which';
import '@blitzjs/config';
import 'htmlescape';

function useRouterQuery() {
  var router = useRouter$1();
  var query = useMemo(function () {
    var query = decode(router.asPath.split("?", 2)[1]);
    return query;
  }, [router.asPath]);
  return query;
}

function areQueryValuesEqual(value1, value2) {
  // Check if their type match
  if (typeof value1 !== typeof value2) {
    return false;
  }

  if (Array.isArray(value1) && Array.isArray(value2)) {
    if (value1.length !== value2.length) {
      return false;
    }

    for (var i = 0; i < value1.length; i++) {
      if (value1[i] !== value2[i]) {
        return false;
      }
    }

    return true;
  }

  return value1 === value2;
}

function extractRouterParams(routerQuery, query) {
  return fromPairs(Object.entries(routerQuery).filter(function (_ref) {
    var key = _ref[0],
        value = _ref[1];
    return typeof query[key] === "undefined" || !areQueryValuesEqual(value, query[key]);
  }));
}
function useParams(returnType) {
  var router = useRouter$1();
  var query = useRouterQuery();
  var params = useMemo(function () {
    var rawParams = extractRouterParams(router.query, query);

    if (returnType === "string") {
      var _params = {};

      for (var _key in rawParams) {
        if (typeof rawParams[_key] === "string") {
          _params[_key] = rawParams[_key];
        }
      }

      return _params;
    }

    if (returnType === "number") {
      var _params2 = {};

      for (var _key2 in rawParams) {
        if (rawParams[_key2]) {
          var num = Number(rawParams[_key2]);
          _params2[_key2] = isNaN(num) ? undefined : num;
        }
      }

      return _params2;
    }

    if (returnType === "array") {
      var _params3 = {};

      for (var _key3 in rawParams) {
        var rawValue = rawParams[_key3];

        if (Array.isArray(rawParams[_key3])) {
          _params3[_key3] = rawValue;
        } else if (typeof rawValue === "string") {
          _params3[_key3] = [rawValue];
        }
      }

      return _params3;
    }

    return rawParams;
  }, [router.query, query, returnType]);
  return params;
}
function useParam(key, returnType) {
  var params = useParams(returnType);
  var value = params[key];
  return value;
}
/*
 * Based on the code of https://github.com/lukeed/qss
 */

var decodeString = function decodeString(str) {
  return decodeURIComponent(str.replace(/\+/g, "%20"));
};

function decode(str) {
  if (!str) return {};
  var out = {};

  for (var _iterator = _createForOfIteratorHelperLoose(str.split("&")), _step; !(_step = _iterator()).done;) {
    var current = _step.value;

    var _current$split = current.split("="),
        _key4 = _current$split[0],
        _current$split$ = _current$split[1],
        value = _current$split$ === void 0 ? "" : _current$split$;

    _key4 = decodeString(_key4);
    value = decodeString(value);
    if (_key4.length === 0) continue;

    if (_key4 in out) {
      out[_key4] = [].concat(out[_key4], value);
    } else {
      out[_key4] = value;
    }
  }

  return out;
}

var Router = NextRouter;
function withRouter(WrappedComponent) {
  var Wrapper = function Wrapper(_ref) {
    var router = _ref.router;
    var query = useRouterQuery();
    var params = useParams();
    return /*#__PURE__*/React.createElement(WrappedComponent, {
      router: _extends({}, router, {
        query: query,
        params: params
      })
    });
  };

  return withRouter$1(Wrapper);
}
function useRouter() {
  var router = useRouter$1();
  var query = useRouterQuery();
  var params = useParams(); // TODO - we have to explicitly define the return type otherwise TS complains about
  // NextHistoryState and TransitionOptions not being exported from Next.js code

  return React.useMemo(function () {
    return _extends({}, router, {
      query: query,
      params: params
    });
  }, [params, query, router]);
}

function requestIdleCallbackShim(cb) {
  var start = Date.now();
  return setTimeout(function () {
    cb({
      didTimeout: false,
      timeRemaining: function timeRemaining() {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
}

var requestIdleCallback = isClient ? window.requestIdleCallback || requestIdleCallbackShim : requestIdleCallbackShim;

var initializeQueryClient = function initializeQueryClient() {
  var suspenseEnabled = true;

  if (!process.env.CLI_COMMAND_CONSOLE && !process.env.CLI_COMMAND_DB) {
    var data = getBlitzRuntimeData();
    suspenseEnabled = data.suspenseEnabled;
  }

  return new QueryClient({
    defaultOptions: {
      queries: {
        suspense: !!suspenseEnabled,
        retry: function retry(failureCount, error) {
          if (process.env.NODE_ENV !== "production") return false; // Retry (max. 3 times) only if network error detected

          if (error.message === "Network request failed" && failureCount <= 3) return true;
          return false;
        }
      }
    }
  });
}; // Create internal QueryClient instance

var queryClient = /*#__PURE__*/initializeQueryClient();

function isEnhancedResolverRpcClient(f) {
  return !!f._meta;
}

var getQueryCacheFunctions = function getQueryCacheFunctions(resolver, params) {
  return {
    setQueryData: function setQueryData(newData, opts) {
      if (opts === void 0) {
        opts = {
          refetch: true
        };
      }

      return _setQueryData(resolver, params, newData, opts);
    }
  };
};
var emptyQueryFn = /*#__PURE__*/function () {
  var fn = function fn() {
    return new Promise(function () {});
  };

  fn._meta = {
    name: "emptyQueryFn",
    type: "n/a",
    filePath: "n/a",
    apiUrl: ""
  };
  return fn;
}();

var isNotInUserTestEnvironment = function isNotInUserTestEnvironment() {
  if (process.env.JEST_WORKER_ID === undefined) return true;
  if (process.env.BLITZ_TEST_ENVIRONMENT !== undefined) return true;
  return false;
};

var validateQueryFn = function validateQueryFn(queryFn) {
  if (!isEnhancedResolverRpcClient(queryFn) && isNotInUserTestEnvironment()) {
    throw new Error("Either the file path to your resolver is incorrect (must be in a \"queries\" or \"mutations\" folder that isn't nested inside \"pages\" or \"api\") or you are trying to use Blitz's useQuery to fetch from third-party APIs (to do that, import useQuery directly from \"react-query\")");
  }
};

var sanitize = function sanitize(type) {
  return function (queryFn) {
    var _enhancedResolver$_me;

    validateQueryFn(queryFn);
    var enhancedResolver = queryFn;
    var queryFnName = type === "mutation" ? "useMutation" : "useQuery";

    if (((_enhancedResolver$_me = enhancedResolver._meta) == null ? void 0 : _enhancedResolver$_me.type) !== type && isNotInUserTestEnvironment()) {
      throw new Error("\"" + queryFnName + "\" was expected to be called with a " + type + " but was called with a \"" + enhancedResolver._meta.type + "\"");
    }

    return enhancedResolver;
  };
};

var sanitizeQuery = /*#__PURE__*/sanitize("query");
var sanitizeMutation = /*#__PURE__*/sanitize("mutation");
var getQueryKeyFromUrlAndParams = function getQueryKeyFromUrlAndParams(url, params) {
  var queryKey = [url];
  var args = typeof params === "function" ? params() : params;
  queryKey.push(serialize(args));
  return queryKey;
};
function getQueryKey(resolver, params) {
  if (typeof resolver === "undefined") {
    throw new Error("getQueryKey is missing the first argument - it must be a resolver function");
  }

  return getQueryKeyFromUrlAndParams(sanitizeQuery(resolver)._meta.apiUrl, params);
}
function invalidateQuery(resolver, params) {
  if (typeof resolver === "undefined") {
    throw new Error("invalidateQuery is missing the first argument - it must be a resolver function");
  }

  var fullQueryKey = getQueryKey(resolver, params);
  var queryKey;

  if (params) {
    queryKey = fullQueryKey;
  } else {
    // Params not provided, only use first query key item (url)
    queryKey = fullQueryKey[0];
  }

  return queryClient.invalidateQueries(queryKey);
}

function _setQueryData(resolver, params, newData, opts) {
  if (opts === void 0) {
    opts = {
      refetch: true
    };
  }

  if (typeof resolver === "undefined") {
    throw new Error("setQueryData is missing the first argument - it must be a resolver function");
  }

  var queryKey = getQueryKey(resolver, params);
  return new Promise(function (res) {
    queryClient.setQueryData(queryKey, newData);
    var result;

    if (opts.refetch) {
      result = invalidateQuery(resolver, params);
    }

    if (isClient) {
      // Fix for https://github.com/blitz-js/blitz/issues/1174
      requestIdleCallback(function () {
        res(result);
      });
    } else {
      res(result);
    }
  });
}

var BlitzProvider = function BlitzProvider(_ref) {
  var client = _ref.client,
      _ref$contextSharing = _ref.contextSharing,
      contextSharing = _ref$contextSharing === void 0 ? false : _ref$contextSharing,
      dehydratedState = _ref.dehydratedState,
      hydrateOptions = _ref.hydrateOptions,
      children = _ref.children;
  var queryClientRef = useRef();

  if (!queryClientRef.current) {
    queryClientRef.current = queryClient;
  }

  return /*#__PURE__*/React.createElement(QueryClientProvider, {
    client: client != null ? client : queryClient,
    contextSharing: contextSharing
  }, /*#__PURE__*/React.createElement(Hydrate, {
    state: dehydratedState,
    options: hydrateOptions
  }, children));
};

// Taken from https://github.com/HenrikJoreteg/cookie-getter
// simple commonJS cookie reader, best perf according to http://jsperf.com/cookie-parsing
function readCookie(name) {
  if (typeof document === "undefined") return null;
  var cookie = document.cookie;
  var setPos = cookie.search(new RegExp("\\b" + name + "="));
  var stopPos = cookie.indexOf(";", setPos);
  var res;
  if (!~setPos) return null;
  res = decodeURIComponent(cookie.substring(setPos, ~stopPos ? stopPos : undefined).split("=")[1]);
  return res.charAt(0) === "{" ? JSON.parse(res) : res;
}
var setCookie = function setCookie(name, value, expires) {
  var result = name + "=" + value + ";path=/;expires=" + expires;
  document.cookie = result;
};
var deleteCookie = function deleteCookie(name) {
  return setCookie(name, "", "Thu, 01 Jan 1970 00:00:01 GMT");
};

function assert(condition, message) {
  if (!condition) throw new Error(message);
}

var parsePublicDataToken = function parsePublicDataToken(token) {
  assert(token, "[parsePublicDataToken] Failed: token is empty");
  var publicDataStr = fromBase64(token);

  try {
    var publicData = JSON.parse(publicDataStr);
    return {
      publicData: publicData
    };
  } catch (error) {
    throw new Error("[parsePublicDataToken] Failed to parse publicDataStr: " + publicDataStr);
  }
};

var PublicDataStore = /*#__PURE__*/function () {
  function PublicDataStore() {
    var _this = this;

    this.eventKey = LOCALSTORAGE_PREFIX + "publicDataUpdated";
    this.emptyPublicData = {
      userId: null
    };
    this.observable = BadBehavior();

    if (typeof window !== "undefined") {
      // Set default value & prevent infinite loop
      this.updateState(undefined, {
        suppressEvent: true
      });
      window.addEventListener("storage", function (event) {
        if (event.key === _this.eventKey) {
          // Prevent infinite loop
          _this.updateState(undefined, {
            suppressEvent: true
          });
        }
      });
    }
  }

  var _proto = PublicDataStore.prototype;

  _proto.updateState = function updateState(value, opts) {
    // We use localStorage as a message bus between tabs.
    // Setting the current time in ms will cause other tabs to receive the `storage` event
    if (!(opts != null && opts.suppressEvent)) {
      // Prevent infinite loop
      try {
        localStorage.setItem(this.eventKey, Date.now().toString());
      } catch (err) {
        console.error("LocalStorage is not available", err);
      }
    }

    this.observable.next(value != null ? value : this.getData());
  };

  _proto.clear = function clear() {
    deleteCookie(COOKIE_PUBLIC_DATA_TOKEN());
    this.updateState(this.emptyPublicData);
  };

  _proto.getData = function getData() {
    var publicDataToken = this.getToken();

    if (!publicDataToken) {
      return this.emptyPublicData;
    }

    var _parsePublicDataToken = parsePublicDataToken(publicDataToken),
        publicData = _parsePublicDataToken.publicData;

    return publicData;
  };

  _proto.getToken = function getToken() {
    return readCookie(COOKIE_PUBLIC_DATA_TOKEN());
  };

  return PublicDataStore;
}();

var publicDataStore = /*#__PURE__*/new PublicDataStore();

var getAntiCSRFToken = function getAntiCSRFToken() {
  return readCookie(COOKIE_CSRF_TOKEN()) || readCookie(COOKIE_LEGACY_CSRF_TOKEN());
};
var useSession = function useSession(options) {
  var _options$suspense, _options;

  if (options === void 0) {
    options = {};
  }

  var suspense = (_options$suspense = (_options = options) == null ? void 0 : _options.suspense) != null ? _options$suspense : getBlitzRuntimeData().suspenseEnabled;
  var initialState;

  if (options.initialPublicData) {
    initialState = _extends({}, options.initialPublicData, {
      isLoading: false
    });
  } else if (suspense) {
    if (isServer) {
      throw new Promise(function (_) {});
    } else {
      initialState = _extends({}, publicDataStore.getData(), {
        isLoading: false
      });
    }
  } else {
    initialState = _extends({}, publicDataStore.emptyPublicData, {
      isLoading: true
    });
  }

  var _useState = useState(initialState),
      session = _useState[0],
      setSession = _useState[1];

  useEffect(function () {
    // Initialize on mount
    setSession(_extends({}, publicDataStore.getData(), {
      isLoading: false
    }));
    var subscription = publicDataStore.observable.subscribe(function (data) {
      return setSession(_extends({}, data, {
        isLoading: false
      }));
    });
    return subscription.unsubscribe;
  }, []);
  return session;
};
var useAuthenticatedSession = function useAuthenticatedSession(options) {
  if (options === void 0) {
    options = {};
  }

  useAuthorize();
  return useSession(options);
};
var useAuthorize = function useAuthorize() {
  useAuthorizeIf(true);
};
var useAuthorizeIf = function useAuthorizeIf(condition) {
  useEffect(function () {
    if (condition && !publicDataStore.getData().userId) {
      var error = new AuthenticationError();
      delete error.stack;
      throw error;
    }
  });
};
var useRedirectAuthenticated = function useRedirectAuthenticated(to) {
  if (typeof window !== "undefined" && publicDataStore.getData().userId) {
    window.location.replace(to);
  }
};

var customCSS = "\n  body::before {\n    content: \"\";\n    display: block;\n    position: fixed;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n    z-index: 99999;\n    background-color: white;\n  }\n\n  .blitz-first-render-complete body::before {\n    display: none;\n  }\n";
var noscriptCSS = "\n  body::before {\n    content: none\n  }\n";

var NoPageFlicker = function NoPageFlicker() {
  return /*#__PURE__*/React.createElement(Head, null, /*#__PURE__*/React.createElement("style", {
    dangerouslySetInnerHTML: {
      __html: customCSS
    }
  }), /*#__PURE__*/React.createElement("noscript", null, /*#__PURE__*/React.createElement("style", {
    dangerouslySetInnerHTML: {
      __html: noscriptCSS
    }
  })));
};

function withBlitzInnerWrapper(Page) {
  var BlitzInnerRoot = function BlitzInnerRoot(props) {
    useAuthorizeIf(Page.authenticate === true);
    return /*#__PURE__*/React.createElement(Page, props);
  };

  for (var _i = 0, _Object$entries = Object.entries(Page); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _Object$entries[_i],
        key = _Object$entries$_i[0],
        value = _Object$entries$_i[1];
    BlitzInnerRoot[key] = value;
  }

  if (process.env.NODE_ENV !== "production") {
    BlitzInnerRoot.displayName = "BlitzInnerRoot";
  }

  return BlitzInnerRoot;
}
function withBlitzAppRoot(UserAppRoot) {
  var BlitzOuterRoot = function BlitzOuterRoot(props) {
    if (typeof window !== "undefined") {
      if (publicDataStore.getData().userId) {
        var redirectAuthenticatedTo = props.Component.redirectAuthenticatedTo;

        if (redirectAuthenticatedTo) {
          if (typeof redirectAuthenticatedTo !== "string") {
            redirectAuthenticatedTo = formatWithValidation(redirectAuthenticatedTo);
          }

          window.location.replace(redirectAuthenticatedTo);
        }
      } else {
        var authenticate = props.Component.authenticate;

        if (authenticate && typeof authenticate === "object" && authenticate.redirectTo) {
          var redirectTo = authenticate.redirectTo;

          if (typeof redirectTo !== "string") {
            redirectTo = formatWithValidation(redirectTo);
          }

          var url = new URL(redirectTo, window.location.href);
          url.searchParams.append("next", window.location.pathname);
          window.location.replace(url.toString());
        }
      }
    }

    var component = React.useMemo(function () {
      return withBlitzInnerWrapper(props.Component);
    }, [props.Component]);
    var noPageFlicker = props.Component.suppressFirstRenderFlicker || props.Component.authenticate !== undefined || props.Component.redirectAuthenticatedTo;
    useEffect(function () {
      document.documentElement.classList.add("blitz-first-render-complete");
    }, []);
    return /*#__PURE__*/React.createElement(BlitzProvider, {
      dehydratedState: props.pageProps.dehydratedState
    }, noPageFlicker && /*#__PURE__*/React.createElement(NoPageFlicker, null), /*#__PURE__*/React.createElement(UserAppRoot, _extends({}, props, {
      Component: component
    })));
  };

  return BlitzOuterRoot;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function useQuery(queryFn, params, options) {
  var _options$enabled, _options, _options2, _options3;

  if (options === void 0) {
    options = {};
  }

  if (typeof queryFn === "undefined") {
    throw new Error("useQuery is missing the first argument - it must be a query function");
  }

  var suspenseConfig = getBlitzRuntimeData().suspenseEnabled;
  var enabled = isServer && suspenseConfig ? false : (_options$enabled = (_options = options) == null ? void 0 : _options.enabled) != null ? _options$enabled : ((_options2 = options) == null ? void 0 : _options2.enabled) !== null;
  var suspense = enabled === false ? false : (_options3 = options) == null ? void 0 : _options3.suspense;
  var session = useSession({
    suspense: suspense
  });

  if (session.isLoading) {
    enabled = false;
  }

  var routerIsReady = useRouter().isReady || isServer && suspenseConfig;
  var enhancedResolverRpcClient = sanitizeQuery(queryFn);
  var queryKey = getQueryKey(queryFn, params);

  var _useReactQuery = useQuery$1(_extends({
    queryKey: routerIsReady ? queryKey : ["_routerNotReady_"],
    queryFn: routerIsReady ? function () {
      return enhancedResolverRpcClient(params, {
        fromQueryHook: true
      });
    } : emptyQueryFn
  }, options, {
    enabled: enabled
  })),
      data = _useReactQuery.data,
      queryRest = _objectWithoutPropertiesLoose(_useReactQuery, ["data"]);

  if (queryRest.isIdle && isServer && suspenseConfig !== false && !data && (!options || !("suspense" in options) || options.suspense) && (!options || !("enabled" in options) || options.enabled)) {
    throw new Promise(function () {});
  }

  var rest = _extends({}, queryRest, getQueryCacheFunctions(queryFn, params)); // return [data, rest as RestQueryResult<TResult>]


  return [data, rest];
} // -------------------------
// usePaginatedQuery
// -------------------------

function usePaginatedQuery(queryFn, params, options) {
  var _options4, _options5, _options6;

  if (options === void 0) {
    options = {};
  }

  if (typeof queryFn === "undefined") {
    throw new Error("usePaginatedQuery is missing the first argument - it must be a query function");
  }

  var suspense = ((_options4 = options) == null ? void 0 : _options4.enabled) === false || ((_options5 = options) == null ? void 0 : _options5.enabled) === null ? false : (_options6 = options) == null ? void 0 : _options6.suspense;
  var session = useSession({
    suspense: suspense
  });

  if (session.isLoading) {
    options.enabled = false;
  }

  var routerIsReady = useRouter().isReady;
  var enhancedResolverRpcClient = sanitizeQuery(queryFn);
  var queryKey = getQueryKey(queryFn, params);

  var _useReactQuery2 = useQuery$1(_extends({
    queryKey: routerIsReady ? queryKey : ["_routerNotReady_"],
    queryFn: routerIsReady ? function () {
      return enhancedResolverRpcClient(params, {
        fromQueryHook: true
      });
    } : emptyQueryFn
  }, options, {
    keepPreviousData: true
  })),
      data = _useReactQuery2.data,
      queryRest = _objectWithoutPropertiesLoose(_useReactQuery2, ["data"]);

  var rest = _extends({}, queryRest, getQueryCacheFunctions(queryFn, params)); // return [data, rest as RestPaginatedResult<TResult>]


  return [data, rest];
} // -------------------------
// useInfiniteQuery
// -------------------------

function useInfiniteQuery(queryFn, getQueryParams, options) {
  if (typeof queryFn === "undefined") {
    throw new Error("useInfiniteQuery is missing the first argument - it must be a query function");
  }

  var suspense = (options == null ? void 0 : options.enabled) === false || (options == null ? void 0 : options.enabled) === null ? false : options == null ? void 0 : options.suspense;
  var session = useSession({
    suspense: suspense
  });

  if (session.isLoading) {
    options.enabled = false;
  }

  var routerIsReady = useRouter().isReady;
  var enhancedResolverRpcClient = sanitizeQuery(queryFn);
  var queryKey = getQueryKey(queryFn, getQueryParams);

  var _useInfiniteReactQuer = useInfiniteQuery$1(_extends({
    // we need an extra cache key for infinite loading so that the cache for
    // for this query is stored separately since the hook result is an array of results.
    // Without this cache for usePaginatedQuery and this will conflict and break.
    queryKey: routerIsReady ? [].concat(queryKey, ["infinite"]) : ["_routerNotReady_"],
    queryFn: routerIsReady ? function (_ref) {
      var pageParam = _ref.pageParam;
      return enhancedResolverRpcClient(getQueryParams(pageParam), {
        fromQueryHook: true
      });
    } : emptyQueryFn
  }, options)),
      data = _useInfiniteReactQuer.data,
      queryRest = _objectWithoutPropertiesLoose(_useInfiniteReactQuer, ["data"]);

  var rest = _extends({}, queryRest, getQueryCacheFunctions(queryFn, getQueryParams), {
    pageParams: data == null ? void 0 : data.pageParams
  });

  return [data == null ? void 0 : data.pages, rest];
}

var executeRpcCall = function executeRpcCall(apiUrl, params, opts) {
  if (opts === void 0) {
    opts = {};
  }

  if (!opts.fromQueryHook && !opts.fromInvoke) {
    console.warn("[Deprecation] Directly calling queries/mutations is deprecated in favor of invoke(queryFn, params)");
  }

  if (isServer) return Promise.resolve();
  clientDebug("Starting request for", apiUrl, "with", params, "and", opts);
  var headers = {
    "Content-Type": "application/json"
  };
  var antiCSRFToken = getAntiCSRFToken();

  if (antiCSRFToken) {
    clientDebug("Adding antiCSRFToken cookie header", antiCSRFToken);
    headers[HEADER_CSRF] = antiCSRFToken;
  } else {
    clientDebug("No antiCSRFToken cookie found");
  }

  var serialized;

  if (opts.alreadySerialized) {
    // params is already serialized with superjson when it gets here
    // We have to serialize the params before passing to react-query in the query key
    // because otherwise react-query will use JSON.parse(JSON.stringify)
    // so by the time the arguments come here the real JS objects are lost
    serialized = params;
  } else {
    serialized = serialize(params);
  } // Create a new AbortController instance for this request


  var controller = new AbortController();
  var promise = window.fetch(addBasePath(apiUrl), {
    method: "POST",
    headers: headers,
    credentials: "include",
    redirect: "follow",
    body: JSON.stringify({
      params: serialized.json,
      meta: {
        params: serialized.meta
      }
    }),
    signal: controller.signal
  }).then(async function (response) {
    clientDebug("Received request for", apiUrl);

    if (response.headers) {
      if (response.headers.get(HEADER_PUBLIC_DATA_TOKEN)) {
        publicDataStore.updateState();
        clientDebug("Public data updated");
      }

      if (response.headers.get(HEADER_SESSION_REVOKED)) {
        clientDebug("Session revoked");
        await queryClient.cancelQueries();
        await queryClient.resetQueries();
        queryClient.getMutationCache().clear();
        publicDataStore.clear();
      }

      if (response.headers.get(HEADER_SESSION_CREATED)) {
        clientDebug("Session created");
        await queryClient.invalidateQueries("");
      }

      if (response.headers.get(HEADER_CSRF_ERROR)) {
        var err = new CSRFTokenMismatchError();
        delete err.stack;
        throw err;
      }
    }

    if (!response.ok) {
      var error = new Error(response.statusText);
      error.statusCode = response.status;
      error.path = apiUrl;
      delete error.stack;
      throw error;
    } else {
      var payload;

      try {
        payload = await response.json();
      } catch (error) {
        var _err = new Error("Failed to parse json from " + apiUrl);

        delete _err.stack;
      }

      if (payload.error) {
        var _payload$meta;

        var _error = deserialize({
          json: payload.error,
          meta: (_payload$meta = payload.meta) == null ? void 0 : _payload$meta.error
        }); // We don't clear the publicDataStore for anonymous users


        if (_error.name === "AuthenticationError" && publicDataStore.getData().userId) {
          publicDataStore.clear();
        }

        var prismaError = _error.message.match(/invalid.*prisma.*invocation/i);

        if (prismaError && !("code" in _error)) {
          _error = new Error(prismaError[0]);
          _error.statusCode = 500;
        }

        throw _error;
      } else {
        var _payload$meta2;

        var data = deserialize({
          json: payload.result,
          meta: (_payload$meta2 = payload.meta) == null ? void 0 : _payload$meta2.result
        });

        if (!opts.fromQueryHook) {
          var queryKey = getQueryKeyFromUrlAndParams(apiUrl, params);
          queryClient.setQueryData(queryKey, data);
        }

        return data;
      }
    }
  }); // Disable react-query request cancellation for now
  // Having too many weird bugs with it enabled
  // promise.cancel = () => controller.abort()

  return promise;
};

executeRpcCall.warm = function (apiUrl) {
  if (!isClient) {
    return;
  }

  return window.fetch(addBasePath(apiUrl), {
    method: "HEAD"
  });
};

var getApiUrlFromResolverFilePath = function getApiUrlFromResolverFilePath(resolverFilePath) {
  return resolverFilePath.replace(/^app\/_resolvers/, "/api");
};

function getIsomorphicEnhancedResolver( // resolver is undefined on the client
resolver, resolverFilePath, resolverName, resolverType, target, options) {
  if (target === void 0) {
    target = isClient ? "client" : "server";
  }

  if (options === void 0) {
    options = {};
  }

  var apiUrl = getApiUrlFromResolverFilePath(resolverFilePath);

  if (target === "client") {
    var resolverRpc = function resolverRpc(params, opts) {
      return executeRpcCall(apiUrl, params, opts);
    };

    var enhancedResolverRpcClient = resolverRpc;
    enhancedResolverRpcClient._meta = {
      name: resolverName,
      type: resolverType,
      filePath: resolverFilePath,
      apiUrl: apiUrl
    }; // Warm the lambda

    if (options.warmApiEndpoints) {
      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      executeRpcCall.warm(apiUrl);
    }

    return enhancedResolverRpcClient;
  } else {
    if (!resolver) throw new Error("resolver is missing on the server");
    var enhancedResolver = resolver["default"];
    enhancedResolver.middleware = resolver.middleware;
    enhancedResolver.config = resolver.config;
    enhancedResolver._meta = {
      name: resolverName,
      type: resolverType,
      filePath: resolverFilePath,
      apiUrl: apiUrl
    };
    return enhancedResolver;
  }
}

/*
 * We have to override react-query's MutationFunction and MutationResultPair
 * types so because we have throwOnError:true by default. And by the RQ types
 * have the mutate function result typed as TData|undefined which isn't typed
 * properly with throwOnError.
 *
 * So this fixes that.
 */

function useMutation(mutationResolver, config) {
  var enhancedResolverRpcClient = sanitizeMutation(mutationResolver);

  var _useReactQueryMutatio = useMutation$1(function (variables) {
    return enhancedResolverRpcClient(variables, {
      fromQueryHook: true
    });
  }, _extends({
    throwOnError: true
  }, config));
      _useReactQueryMutatio.mutate;
      var mutateAsync = _useReactQueryMutatio.mutateAsync,
      rest = _objectWithoutPropertiesLoose(_useReactQueryMutatio, ["mutate", "mutateAsync"]);

  return [mutateAsync, rest];
}

function invoke(queryFn, params) {
  if (typeof queryFn === "undefined") {
    throw new Error("invoke is missing the first argument - it must be a query or mutation function");
  }

  if (isClient) {
    var fn = queryFn;
    return fn(params, {
      fromInvoke: true
    });
  } else {
    var _fn = queryFn;
    return _fn(params);
  }
}

var enhancePrisma = function enhancePrisma(client) {
  return new Proxy(client, {
    construct: function construct(target, args) {
      if (typeof window !== "undefined" && process.env.JEST_WORKER_ID === undefined) {
        // Return empty object if in the browser
        // Skip in Jest tests because window is defined in Jest tests
        return {};
      }

      if (!global._blitz_prismaClient) {
        var _client = _construct(target, args);

        _client.$reset = async function reset() {
          if (process.env.NODE_ENV === "production") {
            throw new Error("You are calling db.$reset() in a production environment. We think you probably didn't mean to do that, so we are throwing this error instead of destroying your life's work.");
          }

          var prismaBin = which(process.cwd()).sync("prisma");
          await new Promise(function (res, rej) {
            var process = spawn(prismaBin, ["migrate", "reset", "--force", "--skip-generate"], {
              stdio: "ignore"
            });
            process.on("exit", function (code) {
              return code === 0 ? res(0) : rej(code);
            });
          });

          global._blitz_prismaClient.$disconnect();
        };

        global._blitz_prismaClient = _client;
      }

      return global._blitz_prismaClient;
    }
  });
};

export { BlitzProvider, Router, enhancePrisma, getAntiCSRFToken, getIsomorphicEnhancedResolver, getQueryKey, invalidateQuery, invoke, queryClient, _setQueryData as setQueryData, useAuthenticatedSession, useAuthorize, useInfiniteQuery, useMutation, usePaginatedQuery, useParam, useParams, useQuery, useRedirectAuthenticated, useRouter, useRouterQuery, useSession, withBlitzAppRoot, withRouter };
