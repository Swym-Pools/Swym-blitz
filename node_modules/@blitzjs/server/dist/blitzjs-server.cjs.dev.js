'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var filePipeline = require('@blitzjs/file-pipeline');
var fs = require('fs-extra');
var path = require('path');
var fs$1 = require('fs');
var display = require('@blitzjs/display');
var spawn = require('cross-spawn');
var expandTilde = require('expand-tilde');
var fastGlob = require('fast-glob');
var partition = require('lodash/partition');
var parseGitignore = require('parse-gitignore');
var pkgDir = require('pkg-dir');
var resolveCwd = require('resolve-cwd');
var config = require('@blitzjs/config');
var detect = require('detect-port');
var esbuild = require('esbuild');
var slash = require('slash');
var File = require('vinyl');
var through = require('through2');
require('parallel-transform');
var pumpify = require('pumpify');
var debounce = require('lodash/debounce');
var flow = require('lodash/flow');
var lodash = require('lodash');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefault(path);
var fs__default = /*#__PURE__*/_interopDefault(fs$1);
var spawn__default = /*#__PURE__*/_interopDefault(spawn);
var expandTilde__default = /*#__PURE__*/_interopDefault(expandTilde);
var fastGlob__default = /*#__PURE__*/_interopDefault(fastGlob);
var partition__default = /*#__PURE__*/_interopDefault(partition);
var parseGitignore__default = /*#__PURE__*/_interopDefault(parseGitignore);
var pkgDir__default = /*#__PURE__*/_interopDefault(pkgDir);
var resolveCwd__default = /*#__PURE__*/_interopDefault(resolveCwd);
var detect__default = /*#__PURE__*/_interopDefault(detect);
var slash__default = /*#__PURE__*/_interopDefault(slash);
var File__default = /*#__PURE__*/_interopDefault(File);
var through__default = /*#__PURE__*/_interopDefault(through);
var pumpify__default = /*#__PURE__*/_interopDefault(pumpify);
var debounce__default = /*#__PURE__*/_interopDefault(debounce);
var flow__default = /*#__PURE__*/_interopDefault(flow);

var blitzVersionFilename = "_blitz-version.txt";
function getBlitzVersion() {
  try {
    var pkgJson = require("blitz/package.json");

    return pkgJson.version;
  } catch (_unused) {
    return "";
  }
}
async function isVersionMatched(buildFolder) {
  if (buildFolder === void 0) {
    buildFolder = ".blitz/build";
  }

  var versionStore = path.resolve(buildFolder, blitzVersionFilename);
  if (!(await fs.pathExists(versionStore))) return false;

  try {
    var buffer = await fs.readFile(versionStore);
    var version = getBlitzVersion();
    var read = buffer.toString().trim().replace("\n", "");
    return read === version;
  } catch (err) {
    return false;
  }
}
async function saveBlitzVersion(buildFolder) {
  if (buildFolder === void 0) {
    buildFolder = ".blitz/build";
  }

  var versionStore = path.resolve(buildFolder, blitzVersionFilename);
  var version = getBlitzVersion();
  await fs.writeFile(versionStore, version);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var _process$env$GIT_DIR = process.env.GIT_DIR,
    GIT_DIR = _process$env$GIT_DIR === void 0 ? ".git" : _process$env$GIT_DIR;

function globalGitIgnore() {
  var versionResult = spawn__default['default'].sync("git", ["version"]);

  if (!(versionResult.status === 0)) {
    display.log.warning("Git doesn't seem to be installed. Get it here: https://git-scm.com/downloads.");
    return null;
  }

  var configResult = spawn__default['default'].sync("git", ["config", "--get", "core.excludesfile"], {
    stdio: "pipe"
  });

  if (!(configResult.status === 0)) {
    // Git config core.excludesFile is unset. Inferring .gitignore file locations.
    return null;
  }

  var output = String(configResult.stdout).trim();
  return process.platform === "win32" ? output : expandTilde__default['default'](output);
}

function isControlledByUser(file) {
  if (file.startsWith("node_modules")) {
    return false;
  }

  return true;
}
function getAllGitIgnores(rootFolder) {
  var globalIgnore = globalGitIgnore();
  var localRepoIgnore = GIT_DIR + "/info/exclude";
  var files = fastGlob__default['default'].sync([localRepoIgnore, "**/.gitignore", "**/" + localRepoIgnore], {
    cwd: rootFolder
  });
  if (fs__default['default'].existsSync(globalIgnore)) files.push(globalIgnore);
  return files.filter(isControlledByUser).map(function (file) {
    var prefix = "";
    if (file.match(localRepoIgnore)) prefix = file.split(localRepoIgnore)[0];else if (file.match(globalIgnore)) prefix = "";else prefix = file.split(".gitignore")[0];
    return {
      gitIgnore: fs__default['default'].readFileSync(file, {
        encoding: "utf8"
      }),
      prefix: prefix
    };
  });
}
function chokidarRulesFromGitignore(_ref) {
  var gitIgnore = _ref.gitIgnore,
      prefix = _ref.prefix;
  var rules = parseGitignore__default['default'](gitIgnore);

  var isInclusionRule = function isInclusionRule(rule) {
    return rule.startsWith("!");
  };

  var _partition = partition__default['default'](rules, isInclusionRule),
      includePaths = _partition[0],
      ignoredPaths = _partition[1];

  var trimExclamationMark = function trimExclamationMark(rule) {
    return rule.substring(1);
  };

  var prefixPath = function prefixPath(_rule) {
    var rule = _rule.startsWith("/") ? _rule.substring(1) : _rule;

    if (!prefix) {
      return rule;
    } else {
      return prefix + rule;
    }
  };

  return {
    includePaths: includePaths.map(trimExclamationMark).map(prefixPath),
    ignoredPaths: ignoredPaths.map(prefixPath)
  };
}
function parseChokidarRulesFromGitignore(rootFolder) {
  var result = {
    includePaths: [],
    ignoredPaths: []
  };
  getAllGitIgnores(rootFolder).map(chokidarRulesFromGitignore).forEach(function (_ref2) {
    var _result$includePaths, _result$ignoredPaths;

    var ignoredPaths = _ref2.ignoredPaths,
        includePaths = _ref2.includePaths;

    (_result$includePaths = result.includePaths).push.apply(_result$includePaths, includePaths);

    (_result$ignoredPaths = result.ignoredPaths).push.apply(_result$ignoredPaths, ignoredPaths);
  });
  return result;
}

async function resolveBinAsync(pkg, executable) {
  if (executable === void 0) {
    executable = pkg;
  }

  var packageDir = await pkgDir__default['default'](resolveCwd__default['default'](pkg));
  if (!packageDir) throw new Error("Could not find package.json for '" + pkg + "'");

  var _await$readJSON = await fs.readJSON(path__default['default'].join(packageDir, "package.json")),
      bin = _await$readJSON.bin;

  var binPath = typeof bin === "object" ? bin[executable] : bin;
  if (!binPath) throw new Error("No bin '" + executable + "' in module '" + pkg + "'");
  return path__default['default'].join(packageDir, binPath);
}

var standardBuildFolderPath = ".blitz/build";
var standardBuildFolderPathRegex = /\.blitz[\\/]build[\\/]/g; // https://stackoverflow.com/questions/20010199/how-to-determine-if-a-process-runs-inside-lxc-docker

function isInDocker() {
  var cgroupFile = path.join("proc", "self", "cgroup");

  if (fs__default['default'].existsSync(cgroupFile)) {
    var content = fs__default['default'].readFileSync(cgroupFile, "utf-8");
    return content.includes("docker");
  }

  return false;
}

var defaults = {
  hostname: /*#__PURE__*/isInDocker() ? "0.0.0.0" : "127.0.0.1",
  // -
  env: "prod",
  // -
  buildFolder: standardBuildFolderPath,
  routesFolder: ".blitz/routes",
  // -
  writeManifestFile: true,
  // -
  ignoredPaths: ["./build/**/*", "**/.blitz-*/**/*", "**/.blitz/**/*", "**/.heroku/**/*", "**/.profile.d/**/*", "**/.cache/**/*", "./.config/**/*", "**/.DS_Store", "**/.git/**/*", "**/.next/**/*", "**/*.log", "**/.vercel/**/*", "**/.now/**/*", "**/*.pnp.js", "**/*.sqlite*", "coverage/**/*", ".coverage/**/*", "dist/**/*", "**/node_modules/**/*", "cypress/**/*", "test/**/*", "tests/**/*", "spec/**/*", "specs/**/*", "**/*.test.*", "**/*.spec.*", "**/.yalc/**/*"],
  includePaths: ["**/*"]
};
async function normalize(config) {
  var _config$hostname, _config$buildFolder, _config$routesFolder, _config$isTypeScript, _config$watch, _config$transformFile, _config$writeManifest;

  var rootFolder = path.resolve(process.cwd(), config.rootFolder);
  var git = parseChokidarRulesFromGitignore(rootFolder);
  var env = config.env || defaults.env;
  return _extends({}, config, {
    hostname: (_config$hostname = config.hostname) != null ? _config$hostname : defaults.hostname,
    env: env,
    // -
    rootFolder: rootFolder,
    buildFolder: path.resolve(rootFolder, (_config$buildFolder = config.buildFolder) != null ? _config$buildFolder : defaults.buildFolder),
    routesFolder: path.resolve(rootFolder, (_config$routesFolder = config.routesFolder) != null ? _config$routesFolder : defaults.routesFolder),
    // -
    isTypeScript: (_config$isTypeScript = config.isTypeScript) != null ? _config$isTypeScript : await getIsTypeScript(rootFolder),
    watch: (_config$watch = config.watch) != null ? _config$watch : env === "dev",
    clean: config.clean,
    // -
    transformFiles: (_config$transformFile = config.transformFiles) != null ? _config$transformFile : filePipeline.transformFiles,
    writeManifestFile: (_config$writeManifest = config.writeManifestFile) != null ? _config$writeManifest : defaults.writeManifestFile,
    // -
    ignore: defaults.ignoredPaths.concat(git.ignoredPaths),
    include: defaults.includePaths.concat(git.includePaths),
    // -
    nextBin: await getNextBin(rootFolder, env === "dev")
  });
}

async function getNextBin(rootFolder, usePatched) {
  if (usePatched === void 0) {
    usePatched = false;
  }

  // do not await for both bin-pkg because just one is used at a time
  var nextBinPkg = usePatched ? "@blitzjs/server" : "next";
  var nextBinExec = usePatched ? "next-patched" : undefined;
  var nextBin = await resolveBinAsync(nextBinPkg, nextBinExec);
  return path.resolve(rootFolder, nextBin);
}

async function getIsTypeScript(rootFolder) {
  try {
    await fs$1.promises.access(path.join(rootFolder, "tsconfig.json"));
    return true;
  } catch (_unused) {
    return false;
  }
}

var absolutePathTransform = function absolutePathTransform(sourceFolder) {
  if (sourceFolder === void 0) {
    sourceFolder = "";
  }

  return function (relativeTransformer) {
    return function (filePath) {
      var startingPath = path.relative(sourceFolder, filePath);
      var transformedPath = relativeTransformer(startingPath);
      return path.resolve(sourceFolder, transformedPath);
    };
  };
};

var debug$1 = /*#__PURE__*/require("debug")("blitz:stage:rpc");

var resolverFullBuildPathRegex = /[\\/]app[\\/]_resolvers[\\/]/;
var resolverBuildFolderReplaceRegex = /_resolvers[\\/]/g;
var resolverPathRegex = /(?:app[\\/])(?!_resolvers).*(?:queries|mutations)[\\/].+/;
function isResolverPath(filePath) {
  return resolverPathRegex.exec(filePath);
}

var isomorhicHandlerTemplateClient = function isomorhicHandlerTemplateClient(resolverFilePath, resolverName, resolverType, warmApiEndpoints) {
  return "\nimport {getIsomorphicEnhancedResolver} from '@blitzjs/core'\nexport * from '" + resolverFilePath + "'\nexport default getIsomorphicEnhancedResolver(\n  undefined,\n  '" + resolverFilePath + "',\n  '" + resolverName + "',\n  '" + resolverType + "',\n  undefined,\n  {\n    warmApiEndpoints: " + warmApiEndpoints + "\n  }\n)\n";
};

var isomorhicHandlerTemplateServer = function isomorhicHandlerTemplateServer(resolverFilePath, resolverName, resolverType, warmApiEndpoints) {
  return "\nimport {getIsomorphicEnhancedResolver} from '@blitzjs/core'\nimport * as resolverModule from '" + resolverFilePath + "'\nexport * from '" + resolverFilePath + "'\nexport default getIsomorphicEnhancedResolver(\n  resolverModule,\n  '" + resolverFilePath + "',\n  '" + resolverName + "',\n  '" + resolverType + "',\n  undefined,\n  {\n    warmApiEndpoints: " + warmApiEndpoints + "\n  }\n)\n";
};

var apiHandlerTemplate = function apiHandlerTemplate(originalPath, useTypes, useDb) {
  return "\n// This imports the output of getIsomorphicEnhancedResolver()\nimport enhancedResolver from '" + originalPath + "'\nimport {getAllMiddlewareForModule} from '@blitzjs/core/server'\nimport {rpcApiHandler} from '@blitzjs/core/server'\nimport path from 'path'\n\n// Ensure these files are not eliminated by trace-based tree-shaking (like Vercel)\npath.resolve(\"next.config.js\")\npath.resolve(\"blitz.config.js\")\npath.resolve(\".next/blitz/db.js\")\n// End anti-tree-shaking\n\nlet db" + (useTypes ? ": any" : "") + "\nlet connect" + (useTypes ? ": any" : "") + "\n\n" + (useDb ? "\ndb = require('db').default\nif (require('db').connect) {\n  connect = require('db').connect\n} else if (db?.$connect || db?.connect) {\n  connect = () => db.$connect ? db.$connect() : db.connect()\n} else {\n  connect = () => {}\n}" : "") + "\n\nexport default rpcApiHandler(\n  enhancedResolver,\n  getAllMiddlewareForModule(enhancedResolver),\n  () => db && connect?.(),\n)\n\nexport const config = {\n  ...enhancedResolver.config,\n  api: {\n    ...enhancedResolver.config?.[\"api\"],\n    externalResolver: true,\n  },\n}\n";
};
/**
 * Returns a Stage that manages generating the internal RPC commands and handlers
 */


var createStageRpc = function createStageRpc(isTypeScript) {
  if (isTypeScript === void 0) {
    isTypeScript = true;
  }

  return function configure(_ref) {
    var _target$includes;

    var src = _ref.config.src;
    var fileTransformer = absolutePathTransform(src);
    var getResolverPath = fileTransformer(resolverFilePath);
    var getApiHandlerPath = fileTransformer(apiHandlerPath);

    var _getConfig = config.getConfig(),
        target = _getConfig.target;

    var warmApiEndpoints = (_target$includes = target == null ? void 0 : target.includes("serverless")) != null ? _target$includes : false;
    var stream = filePipeline.transform.file(function (file, _ref2) {
      var next = _ref2.next,
          push = _ref2.push;

      if (!isResolverPath(file.path)) {
        return file;
      }

      debug$1("Event:", file.event);
      var originalPath = resolutionPath(src, file.path);
      var resolverImportPath = resolverFilePath(originalPath);

      var _extractTemplateVars = extractTemplateVars(resolverImportPath),
          resolverType = _extractTemplateVars.resolverType,
          resolverName = _extractTemplateVars.resolverName; // Isomorphic client - original file path


      push(new File__default['default']({
        path: file.path,
        contents: Buffer.from(isomorhicHandlerTemplateServer(resolverImportPath, resolverName, resolverType, warmApiEndpoints)),
        event: file.event
      }));
      push(new File__default['default']({
        path: getResolverPath(file.path),
        contents: file.contents,
        // Appending a new file to the output of this particular stream
        // We don't want to reprocess this file but simply add it to the output
        // of the stream here we provide a hash with some information for how
        // this file came to be here
        hash: [file.hash, "rpc", "resolver"].join("|"),
        event: file.event
      })); // File API route handler

      if (["add", "unlink"].includes(file.event)) {
        push(new File__default['default']({
          path: getApiHandlerPath(file.path),
          contents: Buffer.from(apiHandlerTemplate(originalPath, isTypeScript, fs$1.existsSync("db/index." + (isTypeScript ? "ts" : "js")))),
          // Appending a new file to the output of this particular stream
          // We don't want to reprocess this file but simply add it to the output
          // of the stream here we provide a hash with some information for how
          // this file came to be here
          hash: [file.hash, "rpc", "handler"].join("|"),
          event: file.event === "add" ? "add" : "unlink",
          originalPath: file.path,
          originalRelative: file.relative
        }));
      } // Isomorphic client with export


      if (["add", "unlink"].includes(file.event)) {
        // For some reason, setting `clientWithExport.basename` doesn't work like it should
        // so we have to set the basename with this temp file
        var temp = new File__default['default']({
          path: file.path
        });
        temp.basename = clientResolverBasename(temp.basename);
        var clientWithExport = new File__default['default']({
          path: temp.path,
          contents: Buffer.from(isomorhicHandlerTemplateClient(resolverImportPath, resolverName, resolverType, warmApiEndpoints)),
          hash: [file.hash, "rpc", "client"].join("|"),
          event: file.event === "add" ? "add" : "unlink",
          originalPath: file.path,
          originalRelative: file.relative
        });
        push(clientWithExport);
      }

      return next();
    });
    return {
      stream: stream
    };
  };
};

function removeExt(filePath) {
  return filePath.replace(/[.][^./\s]+$/, "");
}

function resolutionPath(srcPath, filePath) {
  return removeExt(slash__default['default'](path.relative(srcPath, filePath)));
}

function extractTemplateVars(resolverImportPath) {
  var _ref3 = /(queries|mutations)\/(.*)$/.exec(resolverImportPath) || [],
      resolverTypePlural = _ref3[1],
      resolverName = _ref3[2];

  var resolverType = resolverTypePlural === "mutations" ? "mutation" : "query";
  return {
    resolverImportPath: resolverImportPath,
    resolverType: resolverType,
    resolverName: resolverName
  };
}

function resolverFilePath(path) {
  return path.replace(/^app/, "app/_resolvers");
}

function apiHandlerPath(path) {
  return path.replace(/^app/, "pages/api");
}
/**
 * "query.ts" => "query.client.ts"
 */


function clientResolverBasename(basename) {
  var parts = basename.split(".");
  parts.splice(parts.length - 1, 0, "client");
  return parts.join(".");
}

// The following are a loose collaction of stream

/*#__PURE__*/require("from2");

/*#__PURE__*/require("flush-write-stream");

// const pipeline = (pumpifyFn as any) as PumpifyFn & {obj: PumpifyFn}
/*#__PURE__*/pumpify__default['default'].ctor({
  autoDestroy: false,
  destroy: false,
  objectMode: true,
  highWaterMark: 160
});

var pathToGlobalRegex = function pathToGlobalRegex(path) {
  return new RegExp(path.replace(/\//g, "\\/"), "g");
};

function createOutputTransformer(buildFolder, manifest) {
  var projectRoot = config.getProjectRoot();
  var stream = through__default['default'](function (data, _, next) {
    var outputStr = data.toString(); // Remove the blitz build path from the output path so that the
    // printed path is the original file path

    outputStr = outputStr.replace(standardBuildFolderPathRegex, ""); // If find a resolver path, restore printed path to original path

    if (outputStr.match(resolverFullBuildPathRegex)) {
      outputStr = outputStr.replace(resolverBuildFolderReplaceRegex, "");
    }

    if (outputStr.match(/Error:.*find.*production build/)) {
      outputStr = display.log.withError("Could not find a production build, you must run `blitz build` before starting\n\n");
    } else if (manifest) {
      /*
       * Here we look any page files that got moved during the compilation step.
       * And then replace the compiled path with the original path
       */
      var pageMatches = /[\\/](pages[\\/].*.(j|t)sx?)/g.exec(outputStr);

      if (pageMatches) {
        var fullMatch = pageMatches[0],
            simplePath = pageMatches[1];

        if (fullMatch) {
          var builtPath = path__default['default'].join(buildFolder, simplePath);
          var originalPath = manifest.getByValue(builtPath);

          if (originalPath) {
            outputStr = outputStr.replace(pathToGlobalRegex(fullMatch), originalPath.replace(projectRoot, ""));
          }
        }
      }
    }

    next(null, Buffer.from(outputStr));
  });
  return stream;
}

function getSpawnEnv(config) {
  var spawnEnv = process.env;
  spawnEnv.FORCE_COLOR = "3";

  if (config.inspect) {
    spawnEnv = _extends({}, spawnEnv, {
      NODE_OPTIONS: "--inspect"
    });
  }

  return spawnEnv;
}

async function createCommandAndPort(config, command) {
  var spawnCommand = [command];
  var availablePort;
  availablePort = await detect__default['default']({
    port: config.port ? config.port : 3000
  });
  spawnCommand = spawnCommand.concat(["-p", "" + availablePort]);

  if (config.hostname) {
    spawnCommand = spawnCommand.concat(["-H", "" + config.hostname]);
  }

  var spawnEnv = getSpawnEnv(config);
  return {
    spawnCommand: spawnCommand,
    spawnEnv: spawnEnv,
    availablePort: availablePort
  };
}

async function nextStartDev(nextBin, cwd, manifest, buildFolder, config) {
  var _await$createCommandA = await createCommandAndPort(config, "dev"),
      spawnCommand = _await$createCommandA.spawnCommand,
      spawnEnv = _await$createCommandA.spawnEnv,
      availablePort = _await$createCommandA.availablePort;

  process.env.BLITZ_DEV_SERVER_ORIGIN = "http://localhost:" + availablePort;
  return new Promise(function (res, rej) {
    if (config.port && availablePort !== config.port) {
      display.log.error("Couldn't start server on port " + config.port + " because it's already in use");
      rej("");
    } else {
      var nextjs = spawn.spawn(nextBin, spawnCommand, {
        cwd: cwd,
        env: spawnEnv,
        stdio: [process.stdin, "pipe", "pipe"]
      }).on("exit", function (code) {
        if (code === 0) {
          res();
        } else {
          process.exit(code);
        }
      }).on("error", rej);
      nextjs.stdout.pipe(createOutputTransformer(buildFolder, manifest)).pipe(process.stdout);
      nextjs.stderr.pipe(createOutputTransformer(buildFolder, manifest)).pipe(process.stderr);
    }
  });
}
function nextBuild(nextBin, buildFolder, manifest, config) {
  var spawnEnv = getSpawnEnv(config);
  return new Promise(function (res, rej) {
    var nextjs = spawn.spawn(nextBin, ["build"], {
      cwd: buildFolder,
      env: spawnEnv,
      stdio: [process.stdin, "pipe", "pipe"]
    }).on("exit", function (code) {
      if (code === 0 || code === null) {
        res();
      } else {
        process.exit(code);
      }
    }).on("error", rej);
    nextjs.stdout.pipe(createOutputTransformer(buildFolder, manifest)).pipe(process.stdout);
    nextjs.stderr.pipe(createOutputTransformer(buildFolder, manifest)).pipe(process.stderr);
  });
}
function nextExport(nextBin, config) {
  var spawnEnv = getSpawnEnv(config);
  return new Promise(function (res, rej) {
    var nextjs = spawn.spawn(nextBin, ["export"], {
      env: spawnEnv,
      stdio: [process.stdin, "pipe", "pipe"]
    }).on("exit", function (code) {
      if (code === 0 || code === null) {
        res();
      } else {
        process.exit(code);
      }
    }).on("error", rej);
    nextjs.stdout.pipe(process.stdout);
    nextjs.stderr.pipe(process.stderr);
  });
}
async function nextStart(nextBin, buildFolder, config) {
  var _await$createCommandA2 = await createCommandAndPort(config, "start"),
      spawnCommand = _await$createCommandA2.spawnCommand,
      spawnEnv = _await$createCommandA2.spawnEnv,
      availablePort = _await$createCommandA2.availablePort;

  return new Promise(function (res, rej) {
    if (config.port && availablePort !== config.port) {
      display.log.error("Couldn't start server on port " + config.port + " because it's already in use");
      rej("");
    } else {
      var nextjs = spawn.spawn(nextBin, spawnCommand, {
        cwd: buildFolder,
        env: spawnEnv,
        stdio: [process.stdin, "pipe", "pipe"]
      }).on("exit", function (code) {
        if (code === 0) {
          res();
        } else {
          process.exit(code);
        }
      }).on("error", function (err) {
        console.error(err);
        rej(err);
      });
      nextjs.stdout.pipe(createOutputTransformer(buildFolder)).pipe(process.stdout);
      nextjs.stderr.pipe(createOutputTransformer(buildFolder)).pipe(process.stderr);
    }
  });
}
function getCustomServerPath() {
  var projectRoot = config.getProjectRoot();
  var serverPath = path__default['default'].resolve(path__default['default'].join(projectRoot, "server.ts"));
  if (fs.existsSync(serverPath)) return serverPath;
  serverPath = path__default['default'].resolve(path__default['default'].join(projectRoot, "server.js"));
  if (fs.existsSync(serverPath)) return serverPath;
  serverPath = path__default['default'].resolve(path__default['default'].join(projectRoot, "server/index.ts"));
  if (fs.existsSync(serverPath)) return serverPath;
  serverPath = path__default['default'].resolve(path__default['default'].join(projectRoot, "server/index.js"));
  if (fs.existsSync(serverPath)) return serverPath;
  throw new Error("Unable to find custom server");
}
function getCustomServerBuildPath() {
  var projectRoot = config.getProjectRoot();
  return path__default['default'].resolve(projectRoot, ".blitz", "custom-server.js");
}
function customServerExists() {
  try {
    getCustomServerPath();
    return true;
  } catch (_unused) {
    return false;
  }
}
function startCustomServer(cwd, config, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      watch = _ref.watch;

  var serverSrcPath = getCustomServerPath();
  var serverBuildPath = getCustomServerBuildPath();
  var spawnEnv = getSpawnEnv(config);

  if (config.env === "prod") {
    spawnEnv = _extends({}, spawnEnv, {
      NODE_ENV: "production"
    });
  }

  return new Promise(function (res, rej) {
    var process;
    var RESTART_CODE = 777777;

    var spawnServer = function spawnServer() {
      process = spawn.spawn("node", [serverBuildPath], {
        cwd: cwd,
        env: spawnEnv,
        stdio: "inherit"
      }).on("exit", function (code) {
        if (code === 0) {
          res();
        } else if (watch && code === RESTART_CODE) {
          spawnServer();
        } else {
          rej("server.js failed with status code: " + code);
        }
      }).on("error", function (err) {
        console.error(err);
        rej(err);
      });
    };

    var pkg = fs.readJSONSync(path__default['default'].join(pkgDir__default['default'].sync(), "package.json"));
    var esbuildOptions = {
      entryPoints: [serverSrcPath],
      outfile: getCustomServerBuildPath(),
      format: "cjs",
      bundle: true,
      platform: "node",
      external: ["blitz", "next"].concat(Object.keys(require("blitz/package").dependencies), Object.keys(pkg.dependencies), Object.keys(pkg.devDependencies))
    };

    if (watch) {
      esbuildOptions.watch = {
        onRebuild: function onRebuild(error) {
          if (error) {
            display.log.error("Failed to re-build custom server");
          } else {
            display.log.newline();
            display.log.progress("Custom server changed - restarting...");
            display.log.newline(); //@ts-ignore -- incorrect TS type from node

            process.exitCode = RESTART_CODE;
            process.kill("SIGABRT");
          }
        }
      };
    } // eslint-disable-next-line @typescript-eslint/no-floating-promises


    esbuild.build(esbuildOptions).then(function () {
      spawnServer();
    });
  });
}

var isNextConfigPath = function isNextConfigPath(p) {
  return /next\.config\.(js|ts)/.test(p);
};

var isNowBuild = function isNowBuild() {
  return process.env.NOW_BUILDER || process.env.VERCEL_BUILDER;
};
/**
 * Returns a Stage that manages converting from blitz.config.js to next.config.js
 */


var createStageConfig = function createStageConfig(_ref) {
  var config = _ref.config,
      processNewFile = _ref.processNewFile,
      processNewChildFile = _ref.processNewChildFile;
  // Preconditions
  var hasNextConfig = fs.pathExistsSync(path.resolve(config.src, "next.config.js"));
  var hasBlitzConfig = fs.pathExistsSync(path.resolve(config.src, "blitz.config.js")) || fs.pathExistsSync(path.resolve(config.src, "blitz.config.ts"));

  if (hasNextConfig && !isNowBuild()) {
    // TODO: Pause the stream and ask the user if they wish to have their configuration file renamed
    var err = new Error("Blitz does not support next.config.js. Please rename your next.config.js to blitz.config.js");
    err.name = "NextConfigSupportError";
    throw err;
  }

  if (!hasBlitzConfig) {
    // Assume a bare blitz config
    processNewFile(new File__default['default']({
      cwd: config.src,
      path: path.resolve(config.src, "blitz.config.js"),
      contents: Buffer.from("module.exports = {};")
    }));
  }

  if (!hasNextConfig) {
    processNewFile(new File__default['default']({
      cwd: config.src,
      path: path.resolve(config.src, "next.config.js"),
      contents: Buffer.from("\nconst {withBlitz} = require('@blitzjs/core/with-blitz');\nconst config = require('../blitz.config.js');\nmodule.exports = withBlitz(config);\n        ")
    }));
  } // No need to filter yet


  var stream = filePipeline.transform.file(function (file) {
    if (!isNextConfigPath(file.path)) return file; // File is next.config.js
    // Vercel now adds configuration needed for Now, like serverless target,
    // so we need to keep and use that

    if (isNowBuild()) {
      // Assume we have a next.config.js if NOW_BUILDER is true as the cli creates one
      // Divert next.config to next-vercel.config.js
      processNewChildFile({
        parent: file,
        child: new File__default['default']({
          cwd: config.src,
          path: path.resolve(config.src, "next-vercel.config.js"),
          contents: file.contents
        }),
        stageId: "config",
        subfileId: "vercel-config"
      });
      file.contents = Buffer.from("\nconst {withBlitz} = require('@blitzjs/core/with-blitz');\nconst vercelConfig = require('./next-vercel.config.js');\nconst config = require('../blitz.config.js');\nmodule.exports = withBlitz({...config, ...vercelConfig});\n      ");
    }

    return file;
  });
  return {
    stream: stream
  };
};

var debug = /*#__PURE__*/require("debug")("blitz:manifest");

var Manifest = /*#__PURE__*/function () {
  function Manifest(obj) {
    this.keys = {};
    this.values = {};
    this.events = [];

    if (obj) {
      this.keys = obj.keys;
      this.values = obj.values;
    }
  }

  var _proto = Manifest.prototype;

  _proto.getByKey = function getByKey(key) {
    return this.keys[key];
  };

  _proto.getByValue = function getByValue(value) {
    return this.values[value];
  };

  _proto.setEntry = function setEntry(key, dest) {
    debug("Setting key: " + key);
    this.keys[key] = dest;
    this.values[dest] = key;
    this.events.push("set:" + dest);
  };

  _proto.removeKey = function removeKey(key) {
    debug("Removing key: " + key);
    var dest = this.getByKey(key);

    if (!dest) {
      throw new Error("Key \"" + key + "\" returns");
    }

    delete this.values[dest];
    delete this.keys[key];
    this.events.push("del:" + key);
    return dest;
  };

  _proto.getEvents = function getEvents() {
    return this.events;
  };

  _proto.toJson = function toJson(compact) {
    if (compact === void 0) {
      compact = false;
    }

    return JSON.stringify(this.toObject(), null, compact ? undefined : 2);
  };

  _proto.toObject = function toObject() {
    return {
      keys: this.keys,
      values: this.values
    };
  };

  Manifest.create = function create(obj) {
    return new Manifest(obj);
  };

  return Manifest;
}();
/**
 * Returns a stage to create and write the file error manifest so we can
 * link to the correct files on a NextJS browser error.
 */

var createStageManifest = async function createStageManifest(writeManifestFile, buildFolder, env, manifestPath) {
  if (writeManifestFile === void 0) {
    writeManifestFile = true;
  }

  if (manifestPath === void 0) {
    manifestPath = "_manifest.json";
  }

  var manifest;

  if (env !== "prod" && (await fs.pathExists(path__default['default'].join(buildFolder, manifestPath)))) {
    manifest = await ManifestLoader.load(path__default['default'].join(buildFolder, manifestPath));
  } else {
    manifest = Manifest.create();
  }

  var stage = function stage() {
    var debouncePushItem = debounce__default['default'](function (push, file) {
      push(file);
    }, 500);
    var stream = filePipeline.transform.file(function (file, _ref) {
      var next = _ref.next,
          push = _ref.push;
      push(file); // Send file on through to be written

      var _file$history = file.history,
          origin = _file$history[0];
      var dest = file.path;

      if (file.event === "add" || file.event === "change") {
        debug("event:", file.event);
        manifest.setEntry(origin, dest);
      }

      if (file.event === "unlink" || file.event === "unlinkDir") {
        debug("event:", file.event);
        manifest.removeKey(origin);
      }

      if (writeManifestFile) {
        debouncePushItem(push, new File__default['default']({
          // NOTE:  no need to for hash because this is a manifest
          //        and doesn't count as work
          path: manifestPath,
          contents: Buffer.from(manifest.toJson(false))
        }));
      }

      next();
    });
    return {
      stream: stream,
      ready: {
        manifest: manifest
      }
    };
  };

  return stage;
};
var ManifestLoader = {
  load: function load(filename) {
    return new Promise(function (resolve, reject) {
      fs$1.readFile(filename, "utf8", function (err, data) {
        if (err) {
          return reject(err);
        }

        resolve(Manifest.create(JSON.parse(data)));
      });
    });
  }
};

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function handleErrors(bus) {
  bus.on("data", function (event) {
    if (event.type !== filePipeline.ERROR_THROWN) return;
    var err = event.payload;

    if (err instanceof DuplicatePathError) {
      renderDuplicatePathError(err);
      return;
    }
  });
}
var DuplicatePathError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(DuplicatePathError, _Error);

  function DuplicatePathError(message, pathType, paths) {
    var _this;

    _this = _Error.call(this, message) || this;
    _this.name = "DuplicatePathError";
    return _this;
  }

  return DuplicatePathError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var removeCwd = function removeCwd(path) {
  return path.replace(process.cwd(), "");
};

var renderErrorMessage = function renderErrorMessage(path, type) {
  return "- " + path.split(type + "/")[0] + type + "/" + display.log.variable(path.split(type + "/")[1]);
};

function renderDuplicatePathError(err) {
  display.log.error(err.message);
  err.paths.forEach(function (page) {
    page.forEach(function (path) {
      return console.log(renderErrorMessage(removeCwd(path), err.pathType));
    });
  });
}

function pagesPathTransformer(path) {
  var regex = /(?:[\\/]?app[\\/].*?[\\/]?)(pages[\\/].+(?<!\.test))$/;
  return (regex.exec(path) || [])[1] || path;
}
function apiPathTransformer(path$1) {
  var regex = /(?:[\\/]?app[\\/].*?[\\/]?)(api[\\/].+(?<!\.test))$/;
  var matchedPath = (regex.exec(path$1) || [])[1];
  return matchedPath ? path.join("pages", matchedPath) : path$1;
}
var fullTransformer = /*#__PURE__*/flow__default['default'](pagesPathTransformer, apiPathTransformer); // Derived from
// https://codereview.stackexchange.com/questions/203102/count-duplicates-in-a-javascript-array

function findDuplicates(original, transformer) {
  if (transformer === void 0) {
    transformer = function transformer(a) {
      return a;
    };
  }

  var uniqueItems = new Set();
  var duplicates = new Set();
  var inputMap = new Map();
  var duplicateInput = new Set();

  for (var _iterator = _createForOfIteratorHelperLoose(original), _step; !(_step = _iterator()).done;) {
    var value = _step.value;
    var transformed = transformer(value);

    if (!inputMap.has(transformed)) {
      inputMap.set(transformed, new Set());
    }

    var transformedLookup = inputMap.get(transformed);
    transformedLookup.add(value);

    if (uniqueItems.has(transformed)) {
      duplicates.add(transformed);
      duplicateInput.add(transformedLookup);
      uniqueItems["delete"](transformed);
    } else {
      uniqueItems.add(transformed);
    }
  }

  return toArray(duplicateInput);
}

function toArray(nestedSet) {
  return Array.from(nestedSet).map(function (set) {
    return Array.from(set);
  });
} // Retain rows where some items have yes and no items contain no


function filterBy(entries, yes, no) {
  return entries.filter(function (row) {
    var rowContainsYes = false;
    var rowContainsNo = false;

    for (var _iterator2 = _createForOfIteratorHelperLoose(row), _step2; !(_step2 = _iterator2()).done;) {
      var item = _step2.value;
      rowContainsYes = rowContainsYes || item.indexOf(yes) > -1;

      if (typeof no === "string") {
        rowContainsNo = rowContainsNo || item.indexOf(no) > -1;
      }
    }

    return rowContainsYes && !rowContainsNo;
  });
}
/**
 * Returns a Stage to assemble NextJS `/pages` folder from within
 * the BlitzJS folder structure
 */

var createStagePages = function createStagePages(_ref) {
  var config = _ref.config,
      bus = _ref.bus,
      getInputCache = _ref.getInputCache;
  var src = config.src;
  handleErrors(bus);
  var pagesTransformer = absolutePathTransform(src)(pagesPathTransformer);
  var apiTransformer = absolutePathTransform(src)(apiPathTransformer);
  var stream = filePipeline.transform.file(function (file) {
    var entries = getInputCache().toPaths();
    var duplicates = findDuplicates(entries, fullTransformer); // Check for duplicate pages entries

    var duplicatePages = filterBy(duplicates, "pages", "api");

    if (duplicatePages.length > 0) {
      return new DuplicatePathError("Warning: You have created conflicting page routes:", "pages", duplicatePages);
    } // Check for duplicate api entries


    var duplicateApi = filterBy(duplicates, "api");

    if (duplicateApi.length > 0) {
      return new DuplicatePathError("Warning: You have created conflicting api routes:", "api", duplicateApi);
    }

    file.originalPath = file.path;
    file.originalRelative = file.relative;
    file.path = apiTransformer(pagesTransformer(file.path));
    return file;
  });
  return {
    stream: stream
  };
};

var isJavaScriptFile$1 = function isJavaScriptFile(filepath) {
  return filepath.match(/\.(ts|tsx|js|jsx)$/);
};

var isInSpecialFolderInAppFolder = function isInSpecialFolderInAppFolder(s, cwd) {
  var filepath = s.replace(cwd + path__default['default'].sep, "");
  return /^app[/\\].*(pages|api|queries|mutations)[/\\]/.test(filepath);
};
/**
 * Returns a Stage that converts relative files paths to absolute
 */


var createStageRelative = function createStageRelative(_ref) {
  var cwd = _ref.config.cwd;
  var stream = filePipeline.transform.file(function (file) {
    // const cwd = process.cwd()
    var filecontents = file.contents;
    var filepath = file.path;

    if (!isJavaScriptFile$1(filepath) || !isInSpecialFolderInAppFolder(filepath, cwd) || filecontents === null) {
      return file;
    }

    var contents = filecontents.toString();
    var newContents = replaceRelativeImports(contents, relativeToAbsolute(cwd, filepath));
    file.contents = Buffer.from(newContents);
    return file;
  });
  return {
    stream: stream
  };
};
var patternRelativeImportSingle = /(import(?:\s|\()(?:{[^}]*})?.*(?=(?:['"])(?:\.[^'"]+)(?:['"]))(?:['"]))(\.[^'"]+)(['"])/;
var patternRelativeImportGlobal = /*#__PURE__*/new RegExp(patternRelativeImportSingle, "g");
function replaceRelativeImports(content, replacer) {
  return content.replace(patternRelativeImportGlobal, function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var start = args[1],
        importPath = args[2],
        end = args[3];
    return [start, replacer(importPath), end].join("");
  });
}

function isAbsolute(path) {
  if (path.indexOf("./") === 0) {
    return false;
  }

  if (path.indexOf("../") === 0) {
    return false;
  }

  return true;
}

function relativeToAbsolute(_cwd, _filename) {
  return function (filePath) {
    if (isAbsolute(filePath)) return filePath;
    return slash__default['default'](path__default['default'].join(path__default['default'].dirname(_filename), filePath).replace(_cwd + path__default['default'].sep, ""));
  };
}

var isJavaScriptFile = function isJavaScriptFile(filepath) {
  return filepath.match(/\.(ts|tsx|js|jsx)$/);
};

var isInAppFolder = function isInAppFolder(s, cwd) {
  return s.replace(cwd + path__default['default'].sep, "").indexOf("app") === 0;
};
/**
 * Returns a Stage that converts relative files paths to absolute
 */


var createStageRewriteImports = function createStageRewriteImports(_ref) {
  var cwd = _ref.config.cwd;
  var stream = filePipeline.transform.file(function (file) {
    var filecontents = file.contents;
    var filepath = file.path;

    if (!isJavaScriptFile(filepath) || !isInAppFolder(filepath, cwd) || filecontents === null) {
      return file;
    }

    var contents = filecontents.toString();
    var newContents = replaceImports(contents, cwd);
    file.contents = Buffer.from(newContents);
    return file;
  });
  return {
    stream: stream
  };
};
var patternImport = /(import[\s\S]*?["'])([\s\S]+?)(["'])/g;
function replaceImports(content, cwd) {
  return content.replace(patternImport, function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _ref2 = args,
        original = _ref2[0],
        start = _ref2[1],
        resource = _ref2[2],
        end = _ref2[3];

    if (resource.startsWith("@")) {
      return original;
    }

    return start + rewriteImportOrigin(resource, cwd) + end;
  });
}
/**
 * Check wether `someDir/api` links to `someDir/api.js` or `someDir/api/index.js`.
 */

function getImportType(absoluteOrigin, cwd) {
  var foundFiles = fastGlob__default['default'].sync( // if absoluteOrigin is a file import,
  // we'll find a matching file.
  //
  [absoluteOrigin + ".[jt]s", absoluteOrigin + ".[jt]sx"], {
    cwd: cwd
  });
  return foundFiles.length > 0 ? "file" : "directory";
}

function rewriteImportOrigin(origin, cwd) {
  var parts = origin.split("/");

  if (parts.indexOf("pages") === parts.length - 1 || parts.indexOf("api") === parts.length - 1) {
    if (getImportType(origin, cwd) === "file") {
      return origin;
    }
  } // If it's an import from a page, say from app/pages/mypage,
  // we'll rewrite that import to pages/mypage.


  if (parts.includes("pages")) {
    parts.splice(0, parts.indexOf("pages"));
  } // If it's an import from an API Route, say from app/users/api/myRoute,
  // we'll rewrite it to pages/api/myRoute.


  if (parts.includes("api")) {
    parts.splice(0, parts.indexOf("api"), "pages");
  }

  return parts.join("/");
}

function makeDebouncedWriter(path, ms) {
  if (ms === void 0) {
    ms = 100;
  }

  return lodash.debounce(function (contents) {
    fs.outputFileSync(path, contents, {
      encoding: "utf-8"
    });
  }, ms);
}

function parseDefaultExportName(contents) {
  var _result$;

  var result = contents.match(/export\s+default(?:\s+(?:const|let|class|var|function))?\s+(\w+)/);

  if (!result) {
    return null;
  }

  return (_result$ = result[1]) != null ? _result$ : null;
}

var isPage = function isPage(path$1) {
  return path$1.includes(path.join("pages", "/")) && !path$1.includes(path.join("pages", "api", "/")) && !path$1.includes(path.join("/", "_app.")) && !path$1.includes(path.join("/", "_document."));
};

function dedupeBy(arr, by) {
  var allKeys = arr.map(by);
  return arr.filter(function (v, index) {
    var key = by(v);
    var first = allKeys.indexOf(key);
    var last = allKeys.lastIndexOf(key);

    if (first !== last && first !== index) {
      return false;
    }

    return true;
  });
}

function generateManifest(routes) {
  var routesWithoutDuplicates = dedupeBy(Object.entries(routes), function (_ref) {
    _ref[0];
        var name = _ref[1].name;
    return name;
  });
  var implementationLines = routesWithoutDuplicates.map(function (_ref2) {
    var path = _ref2[0],
        name = _ref2[1].name;
    return name + ": (query) => ({ pathname: \"" + path + "\", query })";
  });
  var declarationLines = routesWithoutDuplicates.map(function (_ref3) {
    _ref3[0];
        var _ref3$ = _ref3[1],
        name = _ref3$.name,
        parameters = _ref3$.parameters,
        multipleParameters = _ref3$.multipleParameters;

    if (parameters.length === 0 && multipleParameters.length === 0) {
      return name + "(query?: ParsedUrlQueryInput): RouteUrlObject";
    }

    return name + "(query: { " + [].concat(parameters.map(function (param) {
      return param.name + (param.optional ? "?" : "") + ": string | number";
    }), multipleParameters.map(function (param) {
      return param.name + (param.optional ? "?" : "") + ": (string | number)[]";
    })).join("; ") + " } & ParsedUrlQueryInput): RouteUrlObject";
  });
  return {
    implementation: "exports.Routes = {\n" + implementationLines.map(function (line) {
      return "  " + line;
    }).join(",\n") + "\n}",
    declaration: ("\nimport type { ParsedUrlQueryInput } from \"querystring\"\nimport type { RouteUrlObject }\xA0from \"blitz\"\n\nexport const Routes: {\n" + declarationLines.map(function (line) {
      return "  " + line;
    }).join(";\n") + ";\n}").trim()
  };
}

function removeSquareBracketsFromSegments(value) {
  if (typeof value === "string") {
    return value.replace("[", "").replace("]", "");
  }

  return value.map(function (val) {
    return val.replace("[", "").replace("]", "");
  });
}

var squareBracketsRegex = /\[\[.*?\]\]|\[.*?\]/g;
function parseParametersFromRoute(path) {
  var _path$match;

  var parameteredSegments = (_path$match = path.match(squareBracketsRegex)) != null ? _path$match : [];
  var withoutBrackets = removeSquareBracketsFromSegments(parameteredSegments);

  var _partition = lodash.partition(withoutBrackets, function (p) {
    return p.includes("...");
  }),
      multipleParameters = _partition[0],
      parameters = _partition[1];

  return {
    parameters: parameters.map(function (value) {
      var containsSquareBrackets = squareBracketsRegex.test(value);

      if (containsSquareBrackets) {
        return {
          name: removeSquareBracketsFromSegments(value),
          optional: true
        };
      }

      return {
        name: value,
        optional: false
      };
    }),
    multipleParameters: multipleParameters.map(function (param) {
      var withoutEllipsis = param.replace("...", "");
      var containsSquareBrackets = squareBracketsRegex.test(withoutEllipsis);

      if (containsSquareBrackets) {
        return {
          name: removeSquareBracketsFromSegments(withoutEllipsis),
          optional: true
        };
      }

      return {
        name: withoutEllipsis,
        optional: false
      };
    })
  };
}
/**
 * Will resolve the real node_modules root.
 * We're not fooled by you, `yarn workspace`!
 */

function findNodeModulesRoot(src) {
  var nodeModules = path.join(src, "node_modules");
  var includesBlitzPackage = fs.existsSync(path.join(nodeModules, "blitz"));
  return includesBlitzPackage ? nodeModules : path.join(nodeModules, "../../../node_modules");
}

var createStageRouteImportManifest = function createStageRouteImportManifest(_ref4) {
  var getRouteCache = _ref4.getRouteCache,
      config = _ref4.config;
  var routeCache = getRouteCache();
  var routes = {};
  var dotBlitz = path.join(findNodeModulesRoot(config.src), ".blitz");
  var writeManifestImplementation = makeDebouncedWriter(path.join(dotBlitz, "index.js"));
  var writeManifestBrowserImplementation = makeDebouncedWriter(path.join(dotBlitz, "index-browser.js"));
  var writeManifestDeclaration = makeDebouncedWriter(path.join(dotBlitz, "index.d.ts"));
  var stream = filePipeline.transform.file(function (file) {
    var _file$contents$toStri, _file$contents;

    if (!isPage(file.relative)) {
      return file;
    }

    var defaultExportName = parseDefaultExportName((_file$contents$toStri = (_file$contents = file.contents) == null ? void 0 : _file$contents.toString()) != null ? _file$contents$toStri : "");

    if (!defaultExportName) {
      return file;
    }

    var entry = routeCache.get(file);

    if (!entry) {
      return file;
    }

    function addRoute(path, defaultExportName) {
      routes[path] = _extends({}, parseParametersFromRoute(path), {
        name: defaultExportName
      });

      var _generateManifest = generateManifest(routes),
          declaration = _generateManifest.declaration,
          implementation = _generateManifest.implementation;

      writeManifestImplementation(implementation);
      writeManifestBrowserImplementation(implementation);
      writeManifestDeclaration(declaration);
    }

    addRoute(entry.uri, defaultExportName);
    return file;
  });
  return {
    stream: stream
  };
};

createStageRouteImportManifest.overrideTriage = function (file) {
  if (isPage(file.relative)) {
    return "proceed";
  }

  return undefined;
};

/**
 * Returns a Stage to populate route cache based on the regex path
 */

var createStageRoutes = function createStageRoutes(_ref) {
  var getRouteCache = _ref.getRouteCache;
  var routeCache = getRouteCache();
  var stream = filePipeline.transform.file(function (file) {
    routeCache.add(file);
    return file;
  });
  return {
    stream: stream,
    ready: {
      routeCache: getRouteCache()
    }
  };
};

// These create pipeline stages that are run as the business rules for Blitz
// Read this folders README for more information
var configureStages = async function configureStages(config) {
  return {
    overrideTriage: createStageRouteImportManifest.overrideTriage,
    stages: [// Order is important
    createStageRelative, createStageRewriteImports, createStagePages, createStageRpc(config.isTypeScript), createStageRoutes, createStageRouteImportManifest, createStageConfig, await createStageManifest(config.writeManifestFile, config.buildFolder, config.env)]
  };
};
var configureRouteStages = function configureRouteStages(config) {
  return [createStagePages, createStageRpc(config.isTypeScript), createStageRoutes];
};
var configureGenerateStages = function configureGenerateStages() {
  return [createStagePages, createStageRoutes, createStageRouteImportManifest];
};

async function build(config) {
  var _await$normalize = await normalize(config),
      rootFolder = _await$normalize.rootFolder,
      transformFiles = _await$normalize.transformFiles,
      buildFolder = _await$normalize.buildFolder,
      nextBin = _await$normalize.nextBin,
      ignore = _await$normalize.ignore,
      include = _await$normalize.include,
      watch = _await$normalize.watch,
      isTypeScript = _await$normalize.isTypeScript,
      writeManifestFile = _await$normalize.writeManifestFile,
      env = _await$normalize.env;

  var _await$configureStage = await configureStages({
    isTypeScript: isTypeScript,
    writeManifestFile: writeManifestFile,
    buildFolder: buildFolder,
    env: env
  }),
      stages = _await$configureStage.stages,
      overrideTriage = _await$configureStage.overrideTriage;

  var _await$transformFiles = await transformFiles(rootFolder, stages, buildFolder, {
    ignore: ignore,
    include: include,
    watch: watch,
    clean: true,
    // always clean in build
    overrideTriage: overrideTriage
  }),
      manifest = _await$transformFiles.manifest;

  await saveBlitzVersion(buildFolder);
  await nextBuild(nextBin, buildFolder, manifest, config);
  var rootNextFolder = path.resolve(rootFolder, ".next");
  var buildNextFolder = path.resolve(buildFolder, ".next");
  await filePipeline.rimraf(rootNextFolder);
  await fs.copy(buildNextFolder, rootNextFolder);
}

async function blitzExport(config) {
  var _await$normalize = await normalize(config),
      nextBin = _await$normalize.nextBin;

  await nextExport(nextBin, config);
}

async function dev(config) {
  var _await$normalize = await normalize(_extends({}, config, {
    env: "dev"
  })),
      rootFolder = _await$normalize.rootFolder,
      transformFiles = _await$normalize.transformFiles,
      nextBin = _await$normalize.nextBin,
      buildFolder = _await$normalize.buildFolder,
      ignore = _await$normalize.ignore,
      include = _await$normalize.include,
      isTypeScript = _await$normalize.isTypeScript,
      writeManifestFile = _await$normalize.writeManifestFile,
      watch = _await$normalize.watch,
      clean = _await$normalize.clean,
      env = _await$normalize.env; // if blitz version is mismatched, we need to bust the cache by cleaning the buildFolder


  var versionMatched = await isVersionMatched(buildFolder);

  var _await$configureStage = await configureStages({
    writeManifestFile: writeManifestFile,
    isTypeScript: isTypeScript,
    buildFolder: buildFolder,
    env: env
  }),
      stages = _await$configureStage.stages,
      overrideTriage = _await$configureStage.overrideTriage;

  var _await$transformFiles = await transformFiles(rootFolder, stages, buildFolder, {
    ignore: ignore,
    include: include,
    watch: watch,
    clean: !versionMatched || clean,
    overrideTriage: overrideTriage
  }),
      manifest = _await$transformFiles.manifest;

  if (!versionMatched) await saveBlitzVersion(buildFolder);

  if (customServerExists()) {
    display.log.success("Using your custom server");
    await startCustomServer(buildFolder, config, {
      watch: true
    });
  } else {
    await nextStartDev(nextBin, buildFolder, manifest, buildFolder, config);
  }
}

async function prod(config) {
  var _await$normalize = await normalize(config),
      buildFolder = _await$normalize.buildFolder,
      nextBin = _await$normalize.nextBin;

  if (!fs$1.existsSync(buildFolder)) {
    display.log.error("Could not find a production build, you must run `blitz build` before starting");
    process.exit(1);
  }

  if (customServerExists()) {
    display.log.success("Using your custom server");
    await startCustomServer(buildFolder, config);
  } else {
    await nextStart(nextBin, buildFolder, config);
  }
}

function defaultSitemapFunction(_) {
  return [];
}

async function routes(config$1) {
  var _await$normalize = await normalize(_extends({}, config$1, {
    env: "dev"
  })),
      rootFolder = _await$normalize.rootFolder,
      routesFolder = _await$normalize.routesFolder,
      transformFiles = _await$normalize.transformFiles,
      ignore = _await$normalize.ignore,
      include = _await$normalize.include,
      isTypeScript = _await$normalize.isTypeScript,
      writeManifestFile = _await$normalize.writeManifestFile,
      env = _await$normalize.env;

  var _ref = config.getConfig(),
      _ref$sitemap = _ref.sitemap,
      sitemap = _ref$sitemap === void 0 ? defaultSitemapFunction : _ref$sitemap;

  var stages = configureRouteStages({
    writeManifestFile: writeManifestFile,
    isTypeScript: isTypeScript,
    buildFolder: routesFolder,
    env: env
  });

  var _ref2 = await transformFiles(rootFolder, stages, routesFolder, {
    ignore: ignore,
    include: include,
    watch: false,
    clean: true
  }),
      routeCache = _ref2.routeCache;

  sitemap(routeCache).forEach(function (sitemap_) {
    routeCache.set(sitemap_.uri, sitemap_);
  });
  return Object.values(routeCache.get());
}

async function generate(config) {
  var _await$normalize = await normalize(_extends({}, config, {
    env: "dev"
  })),
      rootFolder = _await$normalize.rootFolder,
      routesFolder = _await$normalize.routesFolder,
      transformFiles = _await$normalize.transformFiles,
      ignore = _await$normalize.ignore,
      include = _await$normalize.include;

  var stages = configureGenerateStages();
  await transformFiles(rootFolder, stages, routesFolder, {
    ignore: ignore,
    include: include,
    watch: false,
    clean: true
  });
}

exports.ManifestLoader = ManifestLoader;
exports.blitzExport = blitzExport;
exports.build = build;
exports.dev = dev;
exports.generate = generate;
exports.normalize = normalize;
exports.prod = prod;
exports.resolveBinAsync = resolveBinAsync;
exports.routes = routes;
