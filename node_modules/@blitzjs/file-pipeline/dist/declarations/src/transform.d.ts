/// <reference types="node" />
import { DuplexOptions, Transform } from "stream";
import { EventedFile, PipelineItem } from "./types";
/**
 * Stream API for utilizing stream functions
 *
 * @param push Function for pushing pipeline items to the stream
 * @param next Function for passing errors or pushing pipeline items to the stream and then triggering the next ingestion
 */
declare type StreamApi = {
    push: (item: PipelineItem) => boolean;
    next: (err?: Error | null | undefined, item?: PipelineItem) => void;
};
declare type PossibleTransformFnReturn = PipelineItem | void | Error;
declare type PossiblePromise<T> = T | Promise<T>;
/**
 * TransformFn
 *
 * @argument file Pipeline item to process
 * @argument api StreamApi to manage the stream
 * @returns A promise with either a Pipelineitem, an error or undefined. If a PipelineItem is returned it will be sent on. If an Error is returned it will throw an Error on the stream. If undefined is returned nothing will happen and you need to remember to call next() to process the next chunk.
 */
export declare type TransformFn = (file: PipelineItem, api: StreamApi) => PossiblePromise<PossibleTransformFnReturn>;
/**
 * TransformFn
 *
 * @argument file An EventedFile to process
 * @argument api StreamApi to manage the stream
 * @returns A promise with either a Pipelineitem, an error or undefined. If a PipelineItem is returned it will be sent on. If an Error is returned it will throw an Error on the stream. If undefined is returned nothing will happen and you need to remember to call next() to process the next chunk.
 */
export declare type TransformFilesFn = (file: EventedFile, api: StreamApi) => PossiblePromise<PossibleTransformFnReturn>;
export declare function transform(transformFn?: TransformFn, options?: DuplexOptions): Transform;
export declare namespace transform {
    var file: (transformFn?: TransformFilesFn, options?: DuplexOptions) => Transform;
}
export {};
