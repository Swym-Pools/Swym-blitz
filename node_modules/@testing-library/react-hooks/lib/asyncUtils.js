"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _reactTestRenderer = require("react-test-renderer");

class TimeoutError extends Error {
  constructor(util, timeout) {
    super(`Timed out in ${util.name} after ${timeout}ms.`);
  }

}

function resolveAfter(ms) {
  return new Promise(resolve => {
    setTimeout(resolve, ms);
  });
}

function asyncUtils(addResolver) {
  let nextUpdatePromise = null;

  const waitForNextUpdate = async ({
    timeout
  } = {}) => {
    if (!nextUpdatePromise) {
      nextUpdatePromise = new Promise((resolve, reject) => {
        let timeoutId;

        if (timeout && timeout > 0) {
          timeoutId = setTimeout(() => reject(new TimeoutError(waitForNextUpdate, timeout)), timeout);
        }

        addResolver(() => {
          clearTimeout(timeoutId);
          nextUpdatePromise = null;
          resolve();
        });
      });
      await (0, _reactTestRenderer.act)(() => nextUpdatePromise);
    }

    await nextUpdatePromise;
  };

  const waitFor = async (callback, {
    interval,
    timeout,
    suppressErrors = true
  } = {}) => {
    const checkResult = () => {
      try {
        const callbackResult = callback();
        return callbackResult != null ? callbackResult : callbackResult === undefined;
      } catch (error) {
        if (!suppressErrors) {
          throw error;
        }

        return undefined;
      }
    };

    const waitForResult = async () => {
      const initialTimeout = timeout;

      while (true) {
        const startTime = Date.now();

        try {
          const nextCheck = interval ? Promise.race([waitForNextUpdate({
            timeout
          }), resolveAfter(interval)]) : waitForNextUpdate({
            timeout
          });
          await nextCheck;

          if (checkResult()) {
            return;
          }
        } catch (error) {
          if (error instanceof TimeoutError && initialTimeout) {
            throw new TimeoutError(waitFor, initialTimeout);
          }

          throw error;
        }

        if (timeout) timeout -= Date.now() - startTime;
      }
    };

    if (!checkResult()) {
      await waitForResult();
    }
  };

  const waitForValueToChange = async (selector, options = {}) => {
    const initialValue = selector();

    try {
      await waitFor(() => selector() !== initialValue, {
        suppressErrors: false,
        ...options
      });
    } catch (error) {
      if (error instanceof TimeoutError && options.timeout) {
        throw new TimeoutError(waitForValueToChange, options.timeout);
      }

      throw error;
    }
  };

  return {
    waitFor,
    waitForNextUpdate,
    waitForValueToChange
  };
}

var _default = asyncUtils;
exports.default = _default;