{"version":3,"file":"prisma-ast.cjs.production.min.js","sources":["../src/lexer.ts","../src/parser.ts","../src/visitor.ts","../src/printSchema.ts","../src/getSchema.ts"],"sourcesContent":["import { createToken, Lexer } from 'chevrotain';\n\nexport const Identifier = createToken({\n  name: 'Identifier',\n  pattern: /[a-zA-Z]\\w*/,\n});\nexport const Datasource = createToken({\n  name: 'Datasource',\n  pattern: /datasource/,\n  longer_alt: Identifier,\n});\nexport const Generator = createToken({\n  name: 'Generator',\n  pattern: /generator/,\n  longer_alt: Identifier,\n});\nexport const Model = createToken({\n  name: 'Model',\n  pattern: /model/,\n  longer_alt: Identifier,\n});\nexport const Enum = createToken({\n  name: 'Enum',\n  pattern: /enum/,\n  longer_alt: Identifier,\n});\nexport const True = createToken({\n  name: 'True',\n  pattern: /true/,\n  longer_alt: Identifier,\n});\nexport const False = createToken({\n  name: 'False',\n  pattern: /false/,\n  longer_alt: Identifier,\n});\nexport const Null = createToken({\n  name: 'Null',\n  pattern: /null/,\n  longer_alt: Identifier,\n});\nexport const Comment = createToken({\n  name: 'Comment',\n  pattern: Lexer.NA,\n});\n\nexport const DocComment = createToken({\n  name: 'DocComment',\n  pattern: /\\/\\/\\/\\s*(.+)/,\n  categories: [Comment],\n});\nexport const LineComment = createToken({\n  name: 'LineComment',\n  pattern: /\\/\\/\\s*(.+)/,\n  categories: [Comment],\n});\nexport const Attribute = createToken({\n  name: 'Attribute',\n  pattern: Lexer.NA,\n});\nexport const ModelAttribute = createToken({\n  name: 'ModelAttribute',\n  pattern: /@@/,\n  label: \"'@@'\",\n  categories: [Attribute],\n});\nexport const FieldAttribute = createToken({\n  name: 'FieldAttribute',\n  pattern: /@/,\n  label: \"'@'\",\n  categories: [Attribute],\n});\nexport const Dot = createToken({\n  name: 'Dot',\n  pattern: /\\./,\n  label: \"'.'\",\n});\nexport const QuestionMark = createToken({\n  name: 'QuestionMark',\n  pattern: /\\?/,\n  label: \"'?'\",\n});\nexport const Array = createToken({\n  name: 'Array',\n  pattern: /\\[\\]/,\n  label: \"'[]'\",\n});\nexport const LCurly = createToken({\n  name: 'LCurly',\n  pattern: /{/,\n  label: \"'{'\",\n});\nexport const RCurly = createToken({\n  name: 'RCurly',\n  pattern: /}/,\n  label: \"'}'\",\n});\nexport const LRound = createToken({\n  name: 'LRound',\n  pattern: /\\(/,\n  label: \"'('\",\n});\nexport const RRound = createToken({\n  name: 'RRound',\n  pattern: /\\)/,\n  label: \"')'\",\n});\nexport const LSquare = createToken({\n  name: 'LSquare',\n  pattern: /\\[/,\n  label: \"'['\",\n});\nexport const RSquare = createToken({\n  name: 'RSquare',\n  pattern: /\\]/,\n  label: \"']'\",\n});\nexport const Comma = createToken({\n  name: 'Comma',\n  pattern: /,/,\n  label: \"','\",\n});\nexport const Colon = createToken({\n  name: 'Colon',\n  pattern: /:/,\n  label: \"':'\",\n});\nexport const Equals = createToken({\n  name: 'Equals',\n  pattern: /=/,\n  label: \"'='\",\n});\nexport const StringLiteral = createToken({\n  name: 'StringLiteral',\n  pattern: /\"(:?[^\\\\\"\\n\\r]+|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/,\n});\nexport const NumberLiteral = createToken({\n  name: 'NumberLiteral',\n  pattern: /-?(0|[1-9]\\d*)(\\.\\d+)?([eE][+-]?\\d+)?/,\n});\nexport const WhiteSpace = createToken({\n  name: 'WhiteSpace',\n  pattern: /\\s+/,\n  group: Lexer.SKIPPED,\n});\nexport const LineBreak = createToken({\n  name: 'LineBreak',\n  pattern: /\\n|\\r\\n/,\n  line_breaks: true,\n  label: 'LineBreak',\n});\n\nexport const allTokens = [\n  Comment,\n  DocComment,\n  LineComment,\n  LineBreak,\n  WhiteSpace,\n  Attribute,\n  ModelAttribute,\n  FieldAttribute,\n  Dot,\n  QuestionMark,\n  Array,\n  LCurly,\n  RCurly,\n  LSquare,\n  RSquare,\n  LRound,\n  RRound,\n  Comma,\n  Colon,\n  Equals,\n  True,\n  False,\n  Null,\n  Datasource,\n  Generator,\n  Model,\n  Enum,\n  StringLiteral,\n  NumberLiteral,\n  Identifier,\n];\nexport const PrismaLexer = new Lexer(allTokens);\n","import { CstParser } from 'chevrotain';\nimport * as lexer from './lexer';\n\nexport class PrismaParser extends CstParser {\n  constructor() {\n    super(lexer.allTokens);\n    this.performSelfAnalysis();\n  }\n\n  private break = this.RULE('break', () => {\n    this.CONSUME1(lexer.LineBreak);\n    this.CONSUME2(lexer.LineBreak);\n  });\n\n  private keyedArg = this.RULE('keyedArg', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'keyName' });\n    this.CONSUME(lexer.Colon);\n    this.SUBRULE(this.value);\n  });\n\n  private array = this.RULE('array', () => {\n    this.CONSUME(lexer.LSquare);\n    this.MANY_SEP({\n      SEP: lexer.Comma,\n      DEF: () => {\n        this.SUBRULE(this.value);\n      },\n    });\n    this.CONSUME(lexer.RSquare);\n  });\n\n  private func = this.RULE('func', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'funcName' });\n    this.CONSUME(lexer.LRound);\n    this.MANY_SEP({\n      SEP: lexer.Comma,\n      DEF: () => {\n        this.SUBRULE(this.value);\n      },\n    });\n    this.CONSUME(lexer.RRound);\n  });\n\n  private value = this.RULE('value', () => {\n    this.OR([\n      { ALT: () => this.CONSUME(lexer.StringLiteral, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.NumberLiteral, { LABEL: 'value' }) },\n      { ALT: () => this.SUBRULE(this.array, { LABEL: 'value' }) },\n      { ALT: () => this.SUBRULE(this.func, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.True, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.False, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.Null, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.Identifier, { LABEL: 'value' }) },\n    ]);\n  });\n\n  private property = this.RULE('property', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'propertyName' });\n    this.CONSUME(lexer.Equals);\n    this.SUBRULE(this.value, { LABEL: 'propertyValue' });\n  });\n\n  private assignment = this.RULE('assignment', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'assignmentName' });\n    this.CONSUME(lexer.Equals);\n    this.SUBRULE(this.value, { LABEL: 'assignmentValue' });\n  });\n\n  private field = this.RULE('field', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'fieldName' });\n    this.SUBRULE(this.value, { LABEL: 'fieldType' });\n    this.OPTION(() => {\n      this.OR([\n        { ALT: () => this.CONSUME(lexer.Array, { LABEL: 'array' }) },\n        { ALT: () => this.CONSUME(lexer.QuestionMark, { LABEL: 'optional' }) },\n      ]);\n    });\n    this.MANY(() => {\n      this.SUBRULE(this.attribute, { LABEL: 'attributeList' });\n    });\n  });\n\n  private block = this.RULE('block', ({ componentType } = {}) => {\n    const isEnum = componentType === 'enum';\n    const isModel = componentType === 'model';\n\n    this.CONSUME(lexer.LCurly);\n    this.CONSUME1(lexer.LineBreak);\n    this.MANY(() => {\n      this.OR([\n        { ALT: () => this.SUBRULE(this.comment, { LABEL: 'list' }) },\n        {\n          GATE: () => isModel,\n          ALT: () => this.SUBRULE(this.property, { LABEL: 'list' }),\n        },\n        {\n          GATE: () => isModel,\n          ALT: () => this.SUBRULE(this.attribute, { LABEL: 'list' }),\n        },\n        {\n          GATE: () => isModel,\n          ALT: () => this.SUBRULE(this.field, { LABEL: 'list' }),\n        },\n        {\n          GATE: () => isEnum,\n          ALT: () => this.SUBRULE(this.enum, { LABEL: 'list' }),\n        },\n        {\n          GATE: () => !isModel,\n          ALT: () => this.SUBRULE(this.assignment, { LABEL: 'list' }),\n        },\n        { ALT: () => this.SUBRULE(this.break, { LABEL: 'list' }) },\n        { ALT: () => this.CONSUME2(lexer.LineBreak) },\n      ]);\n    });\n    this.CONSUME(lexer.RCurly);\n  });\n\n  private enum = this.RULE('enum', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'enumName' });\n  });\n  private attribute = this.RULE('attribute', () => {\n    this.OR1([\n      {\n        ALT: () =>\n          this.CONSUME(lexer.ModelAttribute, { LABEL: 'modelAttribute' }),\n      },\n      {\n        ALT: () =>\n          this.CONSUME(lexer.FieldAttribute, { LABEL: 'fieldAttribute' }),\n      },\n    ]);\n    this.OR2([\n      {\n        ALT: () => {\n          this.CONSUME1(lexer.Identifier, { LABEL: 'groupName' });\n          this.CONSUME(lexer.Dot);\n          this.CONSUME2(lexer.Identifier, { LABEL: 'attributeName' });\n        },\n      },\n      {\n        ALT: () => this.CONSUME(lexer.Identifier, { LABEL: 'attributeName' }),\n      },\n    ]);\n\n    this.OPTION(() => {\n      this.CONSUME(lexer.LRound);\n      this.MANY_SEP({\n        SEP: lexer.Comma,\n        DEF: () => {\n          this.SUBRULE(this.attributeArg);\n        },\n      });\n      this.CONSUME(lexer.RRound);\n    });\n  });\n\n  private attributeArg = this.RULE('attributeArg', () => {\n    this.OR([\n      { ALT: () => this.SUBRULE(this.keyedArg, { LABEL: 'value' }) },\n      { ALT: () => this.SUBRULE(this.value, { LABEL: 'value' }) },\n    ]);\n  });\n\n  private component = this.RULE('component', () => {\n    const type = this.OR1([\n      { ALT: () => this.CONSUME(lexer.Datasource, { LABEL: 'type' }) },\n      { ALT: () => this.CONSUME(lexer.Generator, { LABEL: 'type' }) },\n      { ALT: () => this.CONSUME(lexer.Model, { LABEL: 'type' }) },\n      { ALT: () => this.CONSUME(lexer.Enum, { LABEL: 'type' }) },\n    ]);\n    this.OR2([\n      {\n        ALT: () => {\n          this.CONSUME1(lexer.Identifier, { LABEL: 'groupName' });\n          this.CONSUME(lexer.Dot);\n          this.CONSUME2(lexer.Identifier, { LABEL: 'componentName' });\n        },\n      },\n      {\n        ALT: () => this.CONSUME(lexer.Identifier, { LABEL: 'componentName' }),\n      },\n    ]);\n\n    this.SUBRULE(this.block, { ARGS: [{ componentType: type.image }] });\n  });\n\n  private comment = this.RULE('comment', () => {\n    this.CONSUME(lexer.Comment, { LABEL: 'text' });\n  });\n\n  public schema = this.RULE('schema', () => {\n    this.MANY(() => {\n      this.OR([\n        { ALT: () => this.SUBRULE(this.comment, { LABEL: 'list' }) },\n        { ALT: () => this.SUBRULE(this.component, { LABEL: 'list' }) },\n        { ALT: () => this.SUBRULE(this.break, { LABEL: 'list' }) },\n        { ALT: () => this.CONSUME(lexer.LineBreak) },\n      ]);\n    });\n  });\n}\n\nexport const parser = new PrismaParser();\n","import { CstNode, IToken } from '@chevrotain/types';\nimport { parser } from './parser';\nimport * as Types from './getSchema';\n\nconst BasePrismaVisitor = parser.getBaseCstVisitorConstructorWithDefaults();\nexport class PrismaVisitor extends BasePrismaVisitor {\n  constructor() {\n    super();\n    this.validateVisitor();\n  }\n\n  schema(ctx: CstNode & { list: CstNode[] }): Types.Schema {\n    const list = ctx.list?.map(item => this.visit([item]));\n    return { type: 'schema', list };\n  }\n\n  component(\n    ctx: CstNode & {\n      type: [IToken];\n      componentName: [IToken];\n      block: [CstNode];\n    }\n  ): Types.Block {\n    const [{ image: type }] = ctx.type;\n    const [{ image: name }] = ctx.componentName;\n    const list = this.visit(ctx.block);\n\n    switch (type) {\n      case 'datasource':\n        return { type: 'datasource', name, assignments: list };\n      case 'generator':\n        return { type: 'generator', name, assignments: list };\n      case 'model':\n        return { type: 'model', name, properties: list };\n      case 'enum':\n        return { type: 'enum', name, enumerators: list };\n      default:\n        throw new Error(`Unexpected block type: ${type}`);\n    }\n  }\n\n  break(): Types.Break {\n    return { type: 'break' };\n  }\n\n  comment(ctx: CstNode & { text: [IToken] }): Types.Comment {\n    const [{ image: comment }] = ctx.text;\n    return { type: 'comment', text: comment };\n  }\n\n  block(ctx: CstNode & { list: CstNode[] }): Types.Block[] {\n    return ctx.list?.map(item => this.visit([item]));\n  }\n\n  assignment(\n    ctx: CstNode & { assignmentName: [IToken]; assignmentValue: [CstNode] }\n  ): Types.Assignment {\n    const value = this.visit(ctx.assignmentValue);\n    const [{ image: key }] = ctx.assignmentName;\n    return { type: 'assignment', key, value };\n  }\n\n  field(\n    ctx: CstNode & {\n      fieldName: [IToken];\n      fieldType: [CstNode];\n      array: [IToken];\n      optional: [IToken];\n      attributeList: CstNode[];\n    }\n  ): Types.Field {\n    const fieldType = this.visit(ctx.fieldType);\n    const [{ image: name }] = ctx.fieldName;\n    const attributes =\n      ctx.attributeList && ctx.attributeList.map(item => this.visit([item]));\n    return {\n      type: 'field',\n      name,\n      fieldType,\n      array: ctx.array != null,\n      optional: ctx.optional != null,\n      attributes,\n    };\n  }\n\n  attribute(\n    ctx: CstNode & {\n      modelAttribute: [IToken];\n      fieldAttribute: [IToken];\n      groupName: [IToken];\n      attributeName: [IToken];\n      attributeArg: CstNode[];\n    }\n  ): Types.Attr {\n    const [{ image: name }] = ctx.attributeName;\n    const [{ image: group }] = ctx.groupName || [{}];\n    const args =\n      ctx.attributeArg && ctx.attributeArg.map(attr => this.visit(attr));\n    const kind = ctx.modelAttribute != null ? 'model' : 'field';\n\n    return { type: 'attribute', name, kind, group, args };\n  }\n\n  attributeArg(ctx: CstNode & { value: [CstNode] }): Types.AttributeArgument {\n    const value = this.visit(ctx.value);\n    return { type: 'attributeArgument', value };\n  }\n\n  func(ctx: CstNode & { funcName: [IToken]; value: CstNode[] }): Types.Func {\n    const [{ image: name }] = ctx.funcName;\n    const params = ctx.value && ctx.value.map(item => this.visit([item]));\n    return { type: 'function', name, params };\n  }\n\n  array(ctx: CstNode & { value: CstNode[] }): Types.RelationArray {\n    const args = ctx.value && ctx.value.map(item => this.visit([item]));\n    return { type: 'array', args };\n  }\n\n  keyedArg(\n    ctx: CstNode & { keyName: [IToken]; value: [CstNode] }\n  ): Types.KeyValue {\n    const [{ image: key }] = ctx.keyName;\n    const value = this.visit(ctx.value);\n    return { type: 'keyValue', key, value };\n  }\n\n  value(ctx: CstNode & { value: [IToken] | [CstNode] }): Types.Value {\n    if (isToken(ctx.value)) {\n      const [{ image }] = ctx.value;\n      return image;\n    }\n    return this.visit(ctx.value);\n  }\n\n  enum(ctx: CstNode & { enumName: [IToken] }): Types.Enumerator {\n    const [{ image: name }] = ctx.enumName;\n    return { type: 'enumerator', name };\n  }\n}\n\nfunction isToken(node: [IToken] | [CstNode]): node is [IToken] {\n  return 'image' in node[0];\n}\n","import * as Types from './getSchema';\nimport { EOL } from 'os';\n\nexport function printSchema(schema: Types.Schema): string {\n  return (\n    schema.list\n      .map(printBlock)\n      .filter(Boolean)\n      .join(EOL)\n      .replace(/(\\r?\\n\\s*){3,}/g, EOL + EOL) + EOL\n  );\n}\n\nfunction printBlock(block: Types.Block): string {\n  switch (block.type) {\n    case 'comment':\n      return printComment(block);\n    case 'datasource':\n      return printDatasource(block);\n    case 'enum':\n      return printEnum(block);\n    case 'generator':\n      return printGenerator(block);\n    case 'model':\n      return printModel(block);\n    case 'break':\n      return printBreak();\n    default:\n      throw new Error(`Unrecognized block type`);\n  }\n}\n\nfunction printComment(comment: Types.Comment) {\n  return comment.text;\n}\n\nfunction printBreak() {\n  return EOL;\n}\n\nfunction printDatasource(db: Types.Datasource) {\n  const children = computeAssignmentFormatting(db.assignments);\n\n  return `\ndatasource ${db.name} {\n  ${children}\n}`;\n}\n\nfunction printEnum(enumerator: Types.Enum) {\n  const children = enumerator.enumerators\n    .map(printEnumerator)\n    .filter(Boolean)\n    .join(`${EOL}  `)\n    .replace(/(\\r?\\n\\s*){3,}/g, `${EOL + EOL}  `);\n\n  return `\nenum ${enumerator.name} {\n  ${children}\n}`;\n}\n\nfunction printEnumerator(\n  enumerator: Types.Enumerator | Types.Comment | Types.Break\n) {\n  switch (enumerator.type) {\n    case 'enumerator':\n      return enumerator.name;\n    case 'comment':\n      return printComment(enumerator);\n    case 'break':\n      return printBreak();\n    default:\n      throw new Error(`Unexpected enumerator type`);\n  }\n}\n\nfunction printGenerator(generator: Types.Generator) {\n  const children = computeAssignmentFormatting(generator.assignments);\n\n  return `\ngenerator ${generator.name} {\n  ${children}\n}`;\n}\n\nfunction printModel(model: Types.Model) {\n  const children = computePropertyFormatting(model.properties);\n\n  return `\nmodel ${model.name} {\n  ${children}\n}`;\n}\n\nfunction printAssignment(\n  node: Types.Assignment | Types.Comment | Types.Break,\n  keyLength = 0\n) {\n  switch (node.type) {\n    case 'comment':\n      return printComment(node);\n    case 'break':\n      return printBreak();\n    case 'assignment':\n      return `${node.key.padEnd(keyLength)} = ${printValue(node.value)}`;\n    default:\n      throw new Error(`Unexpected assignment type`);\n  }\n}\n\nfunction printProperty(\n  node: Types.Property | Types.Comment | Types.Break,\n  nameLength = 0,\n  typeLength = 0\n) {\n  switch (node.type) {\n    case 'attribute':\n      return printAttribute(node);\n    case 'field':\n      return printField(node, nameLength, typeLength);\n    case 'comment':\n      return printComment(node);\n    case 'break':\n      return printBreak();\n    default:\n      throw new Error(`Unrecognized property type`);\n  }\n}\n\nfunction printAttribute(attribute: Types.Attribute | Types.ModelAttribute) {\n  const args =\n    attribute.args && attribute.args.length > 0\n      ? `(${attribute.args\n          .map(printAttributeArg)\n          .filter(Boolean)\n          .join(', ')})`\n      : '';\n\n  return `${attribute.kind === 'field' ? '@' : '@@'}${attribute.name}${args}`;\n}\n\nfunction printAttributeArg(arg: Types.AttributeArgument) {\n  return printValue(arg.value);\n}\n\nfunction printField(field: Types.Field, nameLength = 0, typeLength = 0) {\n  const name = field.name.padEnd(nameLength);\n  const fieldType = printFieldType(field).padEnd(typeLength);\n  const attrs = field.attributes ? field.attributes.map(printAttribute) : [];\n  return [name, fieldType, ...attrs]\n    .filter(Boolean)\n    .join(' ')\n    .trim();\n}\n\nfunction printFieldType(field: Types.Field) {\n  const suffix = field.array ? '[]' : field.optional ? '?' : '';\n\n  if (typeof field.fieldType === 'object') {\n    switch (field.fieldType.type) {\n      case 'function': {\n        const params = field.fieldType.params.map(printValue);\n        return `${field.fieldType.name}(${params})${suffix}`;\n      }\n      default:\n        throw new Error(`Unexpected field type`);\n    }\n  }\n\n  return `${field.fieldType}${suffix}`;\n}\n\nfunction printValue(value: Types.KeyValue | Types.Value): string {\n  switch (typeof value) {\n    case 'object': {\n      if ('type' in value) {\n        switch (value.type) {\n          case 'keyValue':\n            return `${value.key}: ${printValue(value.value)}`;\n          case 'function':\n            return `${value.name}(${\n              value.params ? value.params.map(printValue) : ''\n            })`;\n          case 'array':\n            return `[${value.args.join(', ')}]`;\n          default:\n            throw new Error(`Unexpected value type`);\n        }\n      }\n\n      throw new Error(`Unexpected object value`);\n    }\n    default:\n      return String(value);\n  }\n}\n\nfunction computeAssignmentFormatting(\n  list: Array<Types.Comment | Types.Break | Types.Assignment>\n) {\n  let pos = 0;\n  const listBlocks = list.reduce<Array<typeof list>>(\n    (memo, current, index, arr) => {\n      if (current.type === 'break') return memo;\n      if (index > 0 && arr[index - 1].type === 'break') memo[++pos] = [];\n      memo[pos].push(current);\n      return memo;\n    },\n    [[]]\n  );\n\n  const keyLengths = listBlocks.map(lists =>\n    lists.reduce(\n      (max, current) =>\n        Math.max(\n          max,\n          // perhaps someone more typescript-savy than I am can fix this\n          current.type === 'assignment' ? current.key.length : 0\n        ),\n      0\n    )\n  );\n\n  return list\n    .map((item, index, arr) => {\n      if (index > 0 && item.type !== 'break' && arr[index - 1].type === 'break')\n        keyLengths.shift();\n      return printAssignment(item, keyLengths[0]);\n    })\n    .filter(Boolean)\n    .join(`${EOL}  `)\n    .replace(/(\\r?\\n\\s*){3,}/g, `${EOL + EOL}  `);\n}\n\nfunction computePropertyFormatting(\n  list: Array<Types.Break | Types.Comment | Types.Property>\n) {\n  let pos = 0;\n  const listBlocks = list.reduce<Array<typeof list>>(\n    (memo, current, index, arr) => {\n      if (current.type === 'break') return memo;\n      if (index > 0 && arr[index - 1].type === 'break') memo[++pos] = [];\n      memo[pos].push(current);\n      return memo;\n    },\n    [[]]\n  );\n\n  const nameLengths = listBlocks.map(lists =>\n    lists.reduce(\n      (max, current) =>\n        Math.max(\n          max,\n          // perhaps someone more typescript-savy than I am can fix this\n          current.type === 'field' ? current.name.length : 0\n        ),\n      0\n    )\n  );\n\n  const typeLengths = listBlocks.map(lists =>\n    lists.reduce(\n      (max, current) =>\n        Math.max(\n          max,\n          // perhaps someone more typescript-savy than I am can fix this\n          current.type === 'field' ? printFieldType(current).length : 0\n        ),\n      0\n    )\n  );\n\n  return list\n    .map((prop, index, arr) => {\n      if (\n        index > 0 &&\n        prop.type !== 'break' &&\n        arr[index - 1].type === 'break'\n      ) {\n        nameLengths.shift();\n        typeLengths.shift();\n      }\n\n      return printProperty(prop, nameLengths[0], typeLengths[0]);\n    })\n    .filter(Boolean)\n    .join(`${EOL}  `)\n    .replace(/(\\r?\\n\\s*){3,}/g, `${EOL + EOL}  `);\n}\n","import { PrismaLexer } from './lexer';\nimport { PrismaVisitor } from './visitor';\nimport { parser } from './parser';\n\nexport function getSchema(source: string): Schema {\n  const lexingResult = PrismaLexer.tokenize(source);\n  parser.input = lexingResult.tokens;\n  const cstNode = parser.schema();\n  if (parser.errors.length > 0) throw parser.errors[0];\n  const visitor = new PrismaVisitor();\n  return visitor.visit(cstNode);\n}\n\nexport interface Schema {\n  type: 'schema';\n  list: Block[];\n}\n\nexport type Block = Model | Datasource | Generator | Enum | Comment | Break;\n\nexport interface Model {\n  type: 'model';\n  name: string;\n  properties: Array<Property | Comment | Break>;\n}\n\nexport interface Datasource {\n  type: 'datasource';\n  name: string;\n  assignments: Array<Assignment | Comment | Break>;\n}\n\nexport interface Generator {\n  type: 'generator';\n  name: string;\n  assignments: Array<Assignment | Comment | Break>;\n}\n\nexport interface Enum {\n  type: 'enum';\n  name: string;\n  enumerators: Array<Enumerator | Comment | Break>;\n}\n\nexport interface Comment {\n  type: 'comment';\n  text: string;\n}\n\nexport interface Break {\n  type: 'break';\n}\n\nexport type Property = GroupedModelAttribute | ModelAttribute | Field;\n\nexport interface Assignment {\n  type: 'assignment';\n  key: string;\n  value: Value;\n}\n\nexport interface Enumerator {\n  type: 'enumerator';\n  name: string;\n  value?: Value;\n}\n\nexport interface ModelAttribute {\n  type: 'attribute';\n  kind: 'model';\n  name: string;\n  args: AttributeArgument[];\n}\n\nexport type GroupedModelAttribute = ModelAttribute & { group: string };\n\nexport interface Field {\n  type: 'field';\n  name: string;\n  fieldType: string | Func;\n  array?: boolean;\n  optional?: boolean;\n  attributes?: Attribute[];\n}\n\nexport type Attr =\n  | Attribute\n  | GroupedAttribute\n  | ModelAttribute\n  | GroupedModelAttribute;\n\nexport interface Attribute {\n  type: 'attribute';\n  kind: 'field';\n  name: string;\n  args?: AttributeArgument[];\n}\n\nexport type GroupedAttribute = Attribute & { group: string };\n\nexport interface AttributeArgument {\n  type: 'attributeArgument';\n  value: KeyValue | Value;\n}\n\nexport interface KeyValue {\n  type: 'keyValue';\n  key: string;\n  value: Value;\n}\n\nexport interface Func {\n  type: 'function';\n  name: string;\n  params: Value[];\n}\n\nexport interface RelationArray {\n  type: 'array';\n  args: string[];\n}\n\nexport type Value =\n  | string\n  | number\n  | boolean\n  | Func\n  | RelationArray\n  | Array<Value>;\n"],"names":["Identifier","createToken","name","pattern","Datasource","longer_alt","Generator","Model","Enum","True","False","Null","Comment","Lexer","NA","DocComment","categories","LineComment","Attribute","ModelAttribute","label","FieldAttribute","Dot","QuestionMark","Array","LCurly","RCurly","LRound","RRound","LSquare","RSquare","Comma","Colon","Equals","StringLiteral","NumberLiteral","WhiteSpace","group","SKIPPED","LineBreak","line_breaks","allTokens","PrismaLexer","parser","lexer","_this","RULE","CONSUME1","CONSUME2","CONSUME","LABEL","SUBRULE","value","MANY_SEP","SEP","DEF","OR","ALT","array","func","OPTION","MANY","attribute","componentType","isEnum","isModel","comment","GATE","property","field","assignment","OR1","OR2","attributeArg","keyedArg","type","block","ARGS","image","component","performSelfAnalysis","CstParser","PrismaVisitor","validateVisitor","schema","ctx","list","_ctx$list","map","item","_this2","visit","componentName","this","assignments","properties","enumerators","Error","text","_ctx$list2","_this3","assignmentValue","key","assignmentName","fieldType","fieldName","attributes","attributeList","_this4","optional","attributeName","groupName","args","attr","_this5","kind","modelAttribute","funcName","params","_this6","_this7","keyName","enumName","getBaseCstVisitorConstructorWithDefaults","printBlock","printComment","children","computeAssignmentFormatting","db","enumerator","printEnumerator","filter","Boolean","join","EOL","replace","printEnum","generator","printGenerator","model","pos","listBlocks","nameLengths","typeLengths","reduce","memo","current","index","arr","push","lists","max","Math","length","printFieldType","prop","shift","node","nameLength","typeLength","printAttribute","padEnd","attrs","trim","printField","printBreak","printProperty","printModel","printAttributeArg","arg","printValue","suffix","String","keyLengths","keyLength","printAssignment","source","lexingResult","tokenize","input","tokens","cstNode","errors"],"mappings":"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"}