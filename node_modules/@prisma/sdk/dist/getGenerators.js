"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.knownBinaryTargets = exports.skipIndex = exports.getGenerator = exports.getGenerators = void 0;
const debug_1 = __importDefault(require("@prisma/debug"));
const engine_core_1 = require("@prisma/engine-core");
const engines_1 = require("@prisma/engines");
const fetch_engine_1 = require("@prisma/fetch-engine");
const get_platform_1 = require("@prisma/get-platform");
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = __importDefault(require("fs"));
const make_dir_1 = __importDefault(require("make-dir"));
const p_map_1 = __importDefault(require("p-map"));
const path_1 = __importDefault(require("path"));
const engineCommands_1 = require("./engineCommands");
const Generator_1 = require("./Generator");
const getAllVersions_1 = require("./getAllVersions");
const pick_1 = require("./pick");
const predefinedGeneratorResolvers_1 = require("./predefinedGeneratorResolvers");
const resolveOutput_1 = require("./resolveOutput");
const extractPreviewFeatures_1 = require("./utils/extractPreviewFeatures");
const mapPreviewFeatures_1 = require("./utils/mapPreviewFeatures");
const missingDatasource_1 = require("./utils/missingDatasource");
const missingGeneratorMessage_1 = require("./utils/missingGeneratorMessage");
const printConfigWarnings_1 = require("./utils/printConfigWarnings");
const debug = debug_1.default('prisma:getGenerators');
/**
 * Makes sure that all generators have the binaries they deserve and returns a
 * `Generator` class per generator defined in the schema.prisma file.
 * In other words, this is basically a generator factory function.
 * @param schemaPath Path to schema.prisma
 * @param aliases Aliases like `prisma-client-js` -> `node_modules/@prisma/client/generator-build/index.js`
 */
async function getGenerators({ schemaPath, providerAliases: aliases, // do you get the pun?
version, cliVersion, printDownloadProgress, baseDir = path_1.default.dirname(schemaPath), overrideGenerators, skipDownload, binaryPathsOverride, }) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    if (!schemaPath) {
        throw new Error(`schemaPath for getGenerators got invalid value ${schemaPath}`);
    }
    if (!fs_1.default.existsSync(schemaPath)) {
        throw new Error(`${schemaPath} does not exist`);
    }
    const platform = await get_platform_1.getPlatform();
    let prismaPath = binaryPathsOverride === null || binaryPathsOverride === void 0 ? void 0 : binaryPathsOverride.queryEngine;
    // overwrite query engine if the version is provided
    if (version && !prismaPath) {
        const potentialPath = eval(`require('path').join(__dirname, '..')`);
        // for pkg we need to make an exception
        if (!potentialPath.startsWith('/snapshot/')) {
            const downloadParams = {
                binaries: {
                    'query-engine': potentialPath,
                },
                binaryTargets: [platform],
                showProgress: false,
                version,
                skipDownload,
            };
            const binaryPathsWithEngineType = await fetch_engine_1.download(downloadParams);
            prismaPath = binaryPathsWithEngineType['query-engine'][platform];
        }
    }
    const datamodel = fs_1.default.readFileSync(schemaPath, 'utf-8');
    const config = await engineCommands_1.getConfig({
        datamodel,
        datamodelPath: schemaPath,
        prismaPath,
        ignoreEnvVarErrors: true,
    });
    if (config.datasources.length === 0) {
        throw new Error(missingDatasource_1.missingDatasource);
    }
    printConfigWarnings_1.printConfigWarnings(config.warnings);
    // TODO: This needs a better abstraction, but we don't have any better right now
    const experimentalFeatures = mapPreviewFeatures_1.mapPreviewFeatures(extractPreviewFeatures_1.extractPreviewFeatures(config));
    const dmmf = await engineCommands_1.getDMMF({
        datamodel,
        datamodelPath: schemaPath,
        prismaPath,
        enableExperimental: experimentalFeatures,
    });
    if (dmmf.datamodel.models.length === 0) {
        throw new Error(missingGeneratorMessage_1.missingModelMessage);
    }
    const generatorConfigs = overrideGenerators || config.generators;
    await validateGenerators(generatorConfigs);
    const runningGenerators = [];
    try {
        // 1. Get all generators
        const generators = await p_map_1.default(generatorConfigs, async (generator, index) => {
            let generatorPath = generator.provider;
            let paths;
            // as of now mostly used by studio
            if (aliases && aliases[generator.provider]) {
                generatorPath = aliases[generator.provider].generatorPath;
                paths = aliases[generator.provider];
            }
            else if (predefinedGeneratorResolvers_1.predefinedGeneratorResolvers[generator.provider]) {
                paths = await predefinedGeneratorResolvers_1.predefinedGeneratorResolvers[generator.provider](baseDir, cliVersion);
                generatorPath = paths.generatorPath;
            }
            const generatorInstance = new Generator_1.Generator(generatorPath, generator, paths === null || paths === void 0 ? void 0 : paths.isNode);
            await generatorInstance.init();
            // resolve output path
            if (generator.output) {
                generator.output = path_1.default.resolve(baseDir, generator.output);
                generator.isCustomOutput = true;
            }
            else if (paths) {
                generator.output = paths.outputPath;
            }
            else {
                if (!generatorInstance.manifest ||
                    !generatorInstance.manifest.defaultOutput) {
                    throw new Error(`Can't resolve output dir for generator ${chalk_1.default.bold(generator.name)} with provider ${chalk_1.default.bold(generator.provider)}.
The generator needs to either define the \`defaultOutput\` path in the manifest or you need to define \`output\` in the datamodel.prisma file.`);
                }
                generator.output = await resolveOutput_1.resolveOutput({
                    defaultOutput: generatorInstance.manifest.defaultOutput,
                    baseDir,
                });
            }
            const options = {
                datamodel,
                datasources: config.datasources,
                generator,
                dmmf,
                otherGenerators: skipIndex(generatorConfigs, index),
                schemaPath,
                version: version || engines_1.enginesVersion, // this version makes no sense anymore and should be ignored
            };
            // we set the options here a bit later after instantiating the Generator,
            // as we need the generator manifest to resolve the `output` dir
            generatorInstance.setOptions(options);
            runningGenerators.push(generatorInstance);
            return generatorInstance;
        }, {
            stopOnError: false, // needed so we can first make sure all generators are created properly, then cleaned up properly
        });
        // 2. Check, if all required generators are there.
        // Generators can say in their "requiresGenerators" property in the manifest, which other generators they depend on
        // This has mostly been introduced for 3rd party generators, which rely on `prisma-client-js`.
        const generatorProviders = generatorConfigs.map((g) => g.provider);
        for (const g of generators) {
            if (((_a = g === null || g === void 0 ? void 0 : g.manifest) === null || _a === void 0 ? void 0 : _a.requiresGenerators) &&
                ((_b = g === null || g === void 0 ? void 0 : g.manifest) === null || _b === void 0 ? void 0 : _b.requiresGenerators.length) > 0) {
                for (const neededGenerator of (_c = g === null || g === void 0 ? void 0 : g.manifest) === null || _c === void 0 ? void 0 : _c.requiresGenerators) {
                    if (!generatorProviders.includes(neededGenerator)) {
                        throw new Error(`Generator "${g.manifest.prettyName}" requires generator "${neededGenerator}", but it is missing in your schema.prisma.
Please add it to your schema.prisma:

generator gen {
  provider = "${neededGenerator}"
}
`);
                    }
                }
            }
        }
        // 3. Download all binaries and binary targets needed
        const neededVersions = Object.create(null);
        for (const g of generators) {
            if (((_d = g.manifest) === null || _d === void 0 ? void 0 : _d.requiresEngines) &&
                Array.isArray((_e = g.manifest) === null || _e === void 0 ? void 0 : _e.requiresEngines) &&
                g.manifest.requiresEngines.length > 0) {
                const neededVersion = getEngineVersionForGenerator(g.manifest, version);
                if (!neededVersions[neededVersion]) {
                    neededVersions[neededVersion] = { engines: [], binaryTargets: [] };
                }
                for (const engine of (_f = g.manifest) === null || _f === void 0 ? void 0 : _f.requiresEngines) {
                    if (!neededVersions[neededVersion].engines.includes(engine)) {
                        neededVersions[neededVersion].engines.push(engine);
                    }
                }
                if (((_h = (_g = g.options) === null || _g === void 0 ? void 0 : _g.generator) === null || _h === void 0 ? void 0 : _h.binaryTargets) &&
                    ((_k = (_j = g.options) === null || _j === void 0 ? void 0 : _j.generator) === null || _k === void 0 ? void 0 : _k.binaryTargets.length) > 0) {
                    for (let binaryTarget of (_m = (_l = g.options) === null || _l === void 0 ? void 0 : _l.generator) === null || _m === void 0 ? void 0 : _m.binaryTargets) {
                        if (binaryTarget === 'native') {
                            binaryTarget = platform;
                        }
                        if (!neededVersions[neededVersion].binaryTargets.includes(binaryTarget)) {
                            neededVersions[neededVersion].binaryTargets.push(binaryTarget);
                        }
                    }
                }
            }
        }
        debug({ neededVersions });
        const binaryPathsByVersion = await getBinaryPathsByVersion({
            neededVersions,
            platform,
            version,
            printDownloadProgress,
            skipDownload,
            binaryPathsOverride,
        });
        for (const generator of generators) {
            if (generator.manifest && generator.manifest.requiresEngines) {
                const engineVersion = getEngineVersionForGenerator(generator.manifest, version);
                const binaryPaths = binaryPathsByVersion[engineVersion];
                // pick only the engines that we need for this generator
                const generatorBinaryPaths = pick_1.pick(binaryPaths, generator.manifest.requiresEngines);
                debug({ generatorBinaryPaths });
                generator.setBinaryPaths(generatorBinaryPaths);
                // in case cli engine version !== client engine version
                // we need to re-generate the dmmf and pass it in to the generator
                if (engineVersion !== version &&
                    generator.options &&
                    generator.manifest.requiresEngines.includes('queryEngine') &&
                    generatorBinaryPaths.queryEngine &&
                    generatorBinaryPaths.queryEngine[platform]) {
                    const customDmmf = await engineCommands_1.getDMMF({
                        datamodel,
                        datamodelPath: schemaPath,
                        prismaPath: generatorBinaryPaths.queryEngine[platform],
                        enableExperimental: experimentalFeatures,
                    });
                    const options = { ...generator.options, dmmf: customDmmf };
                    debug(generator.manifest.prettyName);
                    debug(options);
                    generator.setOptions(options);
                }
            }
        }
        return generators;
    }
    catch (e) {
        // make sure all generators that are already running are being stopped
        runningGenerators.forEach((g) => g.stop());
        throw e;
    }
}
exports.getGenerators = getGenerators;
async function getBinaryPathsByVersion({ neededVersions, platform, version, printDownloadProgress, skipDownload, binaryPathsOverride, }) {
    const binaryPathsByVersion = Object.create(null);
    // make sure, that at least the current platform is being fetched
    for (const currentVersion in neededVersions) {
        // ensure binaryTargets are set correctly
        const neededVersion = neededVersions[currentVersion];
        if (neededVersion.binaryTargets.length === 0) {
            neededVersion.binaryTargets.push(platform);
            if (neededVersion.binaryTargets.length === 0) {
                neededVersion.binaryTargets = [platform];
            }
        }
        if (process.env.NETLIFY &&
            !neededVersion.binaryTargets.includes('rhel-openssl-1.0.x')) {
            neededVersion.binaryTargets.push('rhel-openssl-1.0.x');
        }
        // download
        let binaryTargetBaseDir = eval(`require('path').join(__dirname, '..')`);
        if (version !== currentVersion) {
            binaryTargetBaseDir = path_1.default.join(binaryTargetBaseDir, `./engines/${currentVersion}/`);
            await make_dir_1.default(binaryTargetBaseDir).catch((e) => console.error(e));
        }
        const binariesConfig = neededVersion.engines.reduce((acc, curr) => {
            // only download the binary, of not already covered by the `binaryPathsOverride`
            if (!(binaryPathsOverride === null || binaryPathsOverride === void 0 ? void 0 : binaryPathsOverride[curr])) {
                acc[engineTypeToBinaryType(curr)] = binaryTargetBaseDir;
            }
            return acc;
        }, Object.create(null));
        binaryPathsByVersion[currentVersion] = {};
        if (Object.values(binariesConfig).length > 0) {
            const downloadParams = {
                binaries: binariesConfig,
                binaryTargets: neededVersion.binaryTargets,
                showProgress: typeof printDownloadProgress === 'boolean'
                    ? printDownloadProgress
                    : true,
                version: currentVersion && currentVersion !== 'latest'
                    ? currentVersion
                    : engines_1.enginesVersion,
                skipDownload,
            };
            const binaryPathsWithEngineType = await fetch_engine_1.download(downloadParams);
            const binaryPaths = mapKeys(binaryPathsWithEngineType, binaryTypeToEngineType);
            binaryPathsByVersion[currentVersion] = binaryPaths;
        }
        if (binaryPathsOverride) {
            const overrideBinaries = Object.keys(binaryPathsOverride);
            const binariesCoveredByOverride = neededVersion.engines.filter((e) => overrideBinaries.includes(e));
            if (binariesCoveredByOverride.length > 0) {
                for (const bin of binariesCoveredByOverride) {
                    binaryPathsByVersion[currentVersion][bin] = {
                        [platform]: binaryPathsOverride[bin],
                    };
                }
            }
        }
    }
    return binaryPathsByVersion;
}
/**
 * Shortcut for getGenerators, if there is only one generator defined. Useful for testing.
 * @param schemaPath path to schema.prisma
 * @param aliases Aliases like `photonjs` -> `node_modules/photonjs/gen.js`
 * @param version Version of the binary, commit hash of https://github.com/prisma/prisma-engine/commits/master
 * @param printDownloadProgress `boolean` to print download progress or not
 */
async function getGenerator(options) {
    const generators = await getGenerators(options);
    return generators[0];
}
exports.getGenerator = getGenerator;
function skipIndex(arr, index) {
    return [...arr.slice(0, index), ...arr.slice(index + 1)];
}
exports.skipIndex = skipIndex;
exports.knownBinaryTargets = [
    'native',
    'darwin',
    'debian-openssl-1.0.x',
    'debian-openssl-1.1.x',
    'linux-arm-openssl-1.0.x',
    'linux-arm-openssl-1.1.x',
    'rhel-openssl-1.0.x',
    'rhel-openssl-1.1.x',
    'linux-musl',
    'linux-nixos',
    'windows',
    'freebsd11',
    'freebsd12',
    'openbsd',
    'netbsd',
    'arm',
];
const oldToNewBinaryTargetsMapping = {
    'linux-glibc-libssl1.0.1': 'debian-openssl-1.0.x',
    'linux-glibc-libssl1.0.2': 'debian-openssl-1.0.x',
    'linux-glibc-libssl1.1.0': 'debian-openssl1.1.x',
};
async function validateGenerators(generators) {
    const platform = await get_platform_1.getPlatform();
    for (const generator of generators) {
        if (generator.provider === 'photonjs') {
            throw new Error(`Oops! Photon has been renamed to Prisma Client. Please make the following adjustments:
  1. Rename ${chalk_1.default.red('provider = "photonjs"')} to ${chalk_1.default.green('provider = "prisma-client-js"')} in your ${chalk_1.default.bold('schema.prisma')} file.
  2. Replace your ${chalk_1.default.bold('package.json')}'s ${chalk_1.default.red('@prisma/photon')} dependency to ${chalk_1.default.green('@prisma/client')}
  3. Replace ${chalk_1.default.red("import { Photon } from '@prisma/photon'")} with ${chalk_1.default.green("import { PrismaClient } from '@prisma/client'")} in your code.
  4. Run ${chalk_1.default.green('prisma generate')} again.
      `);
        }
        if (generator.config.platforms) {
            throw new Error(`The \`platforms\` field on the generator definition is deprecated. Please rename it to \`binaryTargets\`.`);
        }
        if (generator.config.pinnedBinaryTargets) {
            throw new Error(`The \`pinnedBinaryTargets\` field on the generator definition is deprecated.
Please use the PRISMA_QUERY_ENGINE_BINARY env var instead to pin the binary target.`);
        }
        if (generator.binaryTargets) {
            for (const binaryTarget of generator.binaryTargets) {
                if (oldToNewBinaryTargetsMapping[binaryTarget]) {
                    throw new Error(`Binary target ${chalk_1.default.red.bold(binaryTarget)} is deprecated. Please use ${chalk_1.default.green.bold(oldToNewBinaryTargetsMapping[binaryTarget])} instead.`);
                }
                if (!exports.knownBinaryTargets.includes(binaryTarget)) {
                    throw new Error(`Unknown binary target ${chalk_1.default.red(binaryTarget)} in generator ${chalk_1.default.bold(generator.name)}.
Possible binaryTargets: ${chalk_1.default.greenBright(exports.knownBinaryTargets.join(', '))}`);
                }
            }
            const binaryTargets = generator.binaryTargets && generator.binaryTargets.length > 0
                ? generator.binaryTargets
                : ['native'];
            const resolvedBinaryTargets = binaryTargets.map((p) => p === 'native' ? platform : p);
            if (!resolvedBinaryTargets.includes(platform)) {
                if (generator) {
                    console.log(`${chalk_1.default.yellow('Warning:')} Your current platform \`${chalk_1.default.bold(platform)}\` is not included in your generator's \`binaryTargets\` configuration ${JSON.stringify(generator.binaryTargets)}.
    To fix it, use this generator config in your ${chalk_1.default.bold('schema.prisma')}:
    ${chalk_1.default.greenBright(engine_core_1.printGeneratorConfig({
                        ...generator,
                        binaryTargets: engine_core_1.fixBinaryTargets(generator.binaryTargets, platform),
                    }))}
    ${chalk_1.default.gray(`Note, that by providing \`native\`, Prisma Client automatically resolves \`${platform}\`.
    Read more about deploying Prisma Client: ${chalk_1.default.underline('https://github.com/prisma/prisma/blob/master/docs/core/generators/prisma-client-js.md')}`)}\n`);
                }
                else {
                    console.log(`${chalk_1.default.yellow('Warning')} The binaryTargets ${JSON.stringify(binaryTargets)} don't include your local platform ${platform}, which you can also point to with \`native\`.
    In case you want to fix this, you can provide ${chalk_1.default.greenBright(`binaryTargets: ${JSON.stringify(['native', ...(binaryTargets || [])])}`)} in the schema.prisma file.`);
                }
            }
        }
    }
}
function engineTypeToBinaryType(engineType) {
    if (engineType === 'introspectionEngine') {
        return fetch_engine_1.EngineTypes.introspectionEngine;
    }
    if (engineType === 'migrationEngine') {
        return fetch_engine_1.EngineTypes.migrationEngine;
    }
    if (engineType === 'queryEngine') {
        return fetch_engine_1.EngineTypes.queryEngine;
    }
    if (engineType === 'libqueryEngineNapi') {
        return fetch_engine_1.EngineTypes.libqueryEngineNapi;
    }
    if (engineType === 'prismaFmt') {
        return fetch_engine_1.EngineTypes.prismaFmt;
    }
    throw new Error(`Could not convert engine type ${engineType}`);
}
function binaryTypeToEngineType(binaryType) {
    if (binaryType === fetch_engine_1.EngineTypes.introspectionEngine) {
        return 'introspectionEngine';
    }
    if (binaryType === fetch_engine_1.EngineTypes.migrationEngine) {
        return 'migrationEngine';
    }
    if (binaryType === fetch_engine_1.EngineTypes.libqueryEngineNapi) {
        return 'libqueryEngineNapi';
    }
    if (binaryType === fetch_engine_1.EngineTypes.queryEngine) {
        return 'queryEngine';
    }
    if (binaryType === fetch_engine_1.EngineTypes.prismaFmt) {
        return 'prismaFmt';
    }
    throw new Error(`Could not convert binary type ${binaryType}`);
}
function mapKeys(obj, mapper) {
    return Object.entries(obj).reduce((acc, [key, value]) => {
        acc[mapper(key)] = value;
        return acc;
    }, {});
}
function getEngineVersionForGenerator(manifest, defaultVersion) {
    let neededVersion = manifest.requiresEngineVersion;
    if ((manifest === null || manifest === void 0 ? void 0 : manifest.version) && getAllVersions_1.engineVersions[manifest === null || manifest === void 0 ? void 0 : manifest.version]) {
        neededVersion = getAllVersions_1.engineVersions[manifest === null || manifest === void 0 ? void 0 : manifest.version];
    }
    neededVersion = neededVersion !== null && neededVersion !== void 0 ? neededVersion : defaultVersion; // default to CLI version otherwise, if not provided
    return neededVersion !== null && neededVersion !== void 0 ? neededVersion : 'latest';
}
//# sourceMappingURL=getGenerators.js.map