"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.exists = exports.pathsEqual = exports.loadEnv = exports.tryLoadEnvs = void 0;
const chalk_1 = __importDefault(require("chalk"));
const debug_1 = __importDefault(require("@prisma/debug"));
const dotenv_1 = __importDefault(require("dotenv"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const dotenvExpand_1 = require("../dotenvExpand");
const debug = debug_1.default('prisma:tryLoadEnv');
function tryLoadEnvs({ rootEnvPath, schemaEnvPath, }, opts = {
    conflictCheck: 'none',
}) {
    var _a, _b;
    const rootEnvInfo = loadEnv(rootEnvPath);
    if (opts.conflictCheck !== 'none') {
        // This will throw an error if there are conflicts
        checkForConflicts(rootEnvInfo, schemaEnvPath, opts.conflictCheck);
    }
    // Only load the schema .env if it is not the same as root
    let schemaEnvInfo = null;
    if (!pathsEqual(rootEnvInfo === null || rootEnvInfo === void 0 ? void 0 : rootEnvInfo.path, schemaEnvPath)) {
        schemaEnvInfo = loadEnv(schemaEnvPath);
    }
    // We didn't find a .env file.
    if (!rootEnvInfo && !schemaEnvInfo) {
        debug('No Environment variables loaded');
    }
    // Print the error if any (if internal dotenv readFileSync throws)
    if (schemaEnvInfo === null || schemaEnvInfo === void 0 ? void 0 : schemaEnvInfo.dotenvResult.error) {
        return console.error(chalk_1.default.redBright.bold('Schema Env Error: ') +
            schemaEnvInfo.dotenvResult.error);
    }
    const messages = [rootEnvInfo === null || rootEnvInfo === void 0 ? void 0 : rootEnvInfo.message, schemaEnvInfo === null || schemaEnvInfo === void 0 ? void 0 : schemaEnvInfo.message].filter(Boolean);
    return {
        message: messages.join('\n'),
        parsed: {
            ...(_a = rootEnvInfo === null || rootEnvInfo === void 0 ? void 0 : rootEnvInfo.dotenvResult) === null || _a === void 0 ? void 0 : _a.parsed,
            ...(_b = schemaEnvInfo === null || schemaEnvInfo === void 0 ? void 0 : schemaEnvInfo.dotenvResult) === null || _b === void 0 ? void 0 : _b.parsed,
        },
    };
}
exports.tryLoadEnvs = tryLoadEnvs;
/**
 * Will throw an error if the file at `envPath` has env conflicts with `rootEnv`
 */
function checkForConflicts(rootEnvInfo, envPath, type) {
    const parsedRootEnv = rootEnvInfo === null || rootEnvInfo === void 0 ? void 0 : rootEnvInfo.dotenvResult.parsed;
    const areNotTheSame = !pathsEqual(rootEnvInfo === null || rootEnvInfo === void 0 ? void 0 : rootEnvInfo.path, envPath);
    if (parsedRootEnv && envPath && areNotTheSame && fs_1.default.existsSync(envPath)) {
        const envConfig = dotenv_1.default.parse(fs_1.default.readFileSync(envPath));
        const conflicts = [];
        for (const k in envConfig) {
            if (parsedRootEnv[k] === envConfig[k]) {
                conflicts.push(k);
            }
        }
        if (conflicts.length > 0) {
            // const message = `You are trying to load env variables which are already present in your project root .env
            const relativeRootEnvPath = path_1.default.relative(process.cwd(), rootEnvInfo.path);
            const relativeEnvPath = path_1.default.relative(process.cwd(), envPath);
            if (type === 'error') {
                const message = `There is a conflict between env var${conflicts.length > 1 ? 's' : ''} in ${chalk_1.default.underline(relativeRootEnvPath)} and ${chalk_1.default.underline(relativeEnvPath)}
Conflicting env vars:
${conflicts.map((conflict) => `  ${chalk_1.default.bold(conflict)}`).join('\n')}

We suggest to move the contents of ${chalk_1.default.underline(relativeEnvPath)} to ${chalk_1.default.underline(relativeRootEnvPath)} to consolidate your env vars.\n`;
                throw new Error(message);
            }
            else if (type === 'warn') {
                const message = `Conflict for env var${conflicts.length > 1 ? 's' : ''} ${conflicts
                    .map((c) => chalk_1.default.bold(c))
                    .join(', ')} in ${chalk_1.default.underline(relativeRootEnvPath)} and ${chalk_1.default.underline(relativeEnvPath)}
Env vars from ${chalk_1.default.underline(relativeEnvPath)} overwrite the ones from ${chalk_1.default.underline(relativeRootEnvPath)}
      `;
                console.warn(`${chalk_1.default.yellow('warn(prisma)')} ${message}`);
            }
        }
    }
}
function loadEnv(envPath) {
    if (exists(envPath)) {
        debug(`Environment variables loaded from ${envPath}`);
        const debugEnv = process.env.DEBUG;
        // Value needs to be null or undefined, false is truthy
        // https://github.com/motdotla/dotenv/blob/7301ac9be0b2c766f865bbe24280bf82586d25aa/lib/main.js#L89-L91
        let enableDebug = undefined;
        if (debugEnv && (debugEnv.startsWith('prisma') || debugEnv === '*')) {
            enableDebug = true;
        }
        return {
            dotenvResult: dotenvExpand_1.dotenvExpand(dotenv_1.default.config({
                path: envPath,
                debug: enableDebug,
            })),
            message: chalk_1.default.dim(`Environment variables loaded from ${path_1.default.relative(process.cwd(), envPath)}`),
            path: envPath,
        };
    }
    else {
        debug(`Environment variables not found at ${envPath}`);
    }
    return null;
}
exports.loadEnv = loadEnv;
function pathsEqual(path1, path2) {
    return path1 && path2 && path_1.default.resolve(path1) === path_1.default.resolve(path2);
}
exports.pathsEqual = pathsEqual;
function exists(p) {
    return Boolean(p && fs_1.default.existsSync(p));
}
exports.exists = exists;
//# sourceMappingURL=tryLoadEnvs.js.map