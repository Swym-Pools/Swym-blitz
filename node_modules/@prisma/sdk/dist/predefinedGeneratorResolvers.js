"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.predefinedGeneratorResolvers = void 0;
const debug_1 = __importDefault(require("@prisma/debug"));
const chalk_1 = __importDefault(require("chalk"));
const execa_1 = __importDefault(require("execa"));
const fs_1 = __importDefault(require("fs"));
const has_yarn_1 = __importDefault(require("has-yarn"));
const path_1 = __importDefault(require("path"));
const resolve_pkg_1 = __importDefault(require("resolve-pkg"));
const _1 = require(".");
const getCommandWithExecutor_1 = require("./getCommandWithExecutor");
const debugEnabled = debug_1.default.enabled('generator');
exports.predefinedGeneratorResolvers = {
    photonjs: () => {
        throw new Error(`Oops! Photon has been renamed to Prisma Client. Please make the following adjustments:
  1. Rename ${chalk_1.default.red('provider = "photonjs"')} to ${chalk_1.default.green('provider = "prisma-client-js"')} in your ${chalk_1.default.bold('schema.prisma')} file.
  2. Replace your ${chalk_1.default.bold('package.json')}'s ${chalk_1.default.red('@prisma/photon')} dependency to ${chalk_1.default.green('@prisma/client')}
  3. Replace ${chalk_1.default.red("import { Photon } from '@prisma/photon'")} with ${chalk_1.default.green("import { PrismaClient } from '@prisma/client'")} in your code.
  4. Run ${chalk_1.default.green(getCommandWithExecutor_1.getCommandWithExecutor('prisma generate'))} again.
      `);
    },
    'prisma-client-js': async (baseDir, version) => {
        let prismaClientDir = resolve_pkg_1.default('@prisma/client', { cwd: baseDir });
        checkYarnVersion();
        checkTypeScriptVersion();
        if (debugEnabled) {
            console.log({ prismaClientDir });
        }
        if (!prismaClientDir && !process.env.PRISMA_GENERATE_SKIP_AUTOINSTALL) {
            if (!fs_1.default.existsSync(path_1.default.join(process.cwd(), 'package.json')) &&
                !fs_1.default.existsSync(path_1.default.join(process.cwd(), '../package.json'))) {
                // Create default package.json
                const defaultPackageJson = `{
  "name": "my-prisma-project",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \\"Error: no test specified\\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
        `;
                fs_1.default.writeFileSync(path_1.default.join(process.cwd(), 'package.json'), defaultPackageJson);
                console.info(`‚úî Created ${chalk_1.default.bold.green('./package.json')}`);
            }
            await installPackage(baseDir, `-D prisma@${version !== null && version !== void 0 ? version : 'latest'}`);
            await installPackage(baseDir, `@prisma/client@${version !== null && version !== void 0 ? version : 'latest'}`);
            prismaClientDir = resolve_pkg_1.default('@prisma/client', { cwd: baseDir });
            if (!prismaClientDir) {
                throw new Error(`Could not resolve @prisma/client despite the installation that we just tried.
Please try to install it by hand with ${chalk_1.default.bold.greenBright('npm install @prisma/client')} and rerun ${chalk_1.default.bold(getCommandWithExecutor_1.getCommandWithExecutor('prisma generate'))} üôè.`);
            }
            console.info(`\n‚úî Installed the ${chalk_1.default.bold.green('@prisma/client')} and ${chalk_1.default.bold.green('prisma')} packages in your project`);
        }
        if (!prismaClientDir) {
            throw new Error(`Could not resolve @prisma/client. 
Please try to install it with ${chalk_1.default.bold.greenBright('npm install @prisma/client')} and rerun ${chalk_1.default.bold(getCommandWithExecutor_1.getCommandWithExecutor('prisma generate'))} üôè.`);
        }
        return {
            outputPath: prismaClientDir,
            generatorPath: path_1.default.resolve(prismaClientDir, 'generator-build/index.js'),
            isNode: true,
        };
    },
};
async function installPackage(baseDir, pkg) {
    const yarnUsed = has_yarn_1.default(baseDir) || has_yarn_1.default(path_1.default.join(baseDir, '..'));
    const cmdName = yarnUsed ? 'yarn add' : 'npm install';
    await execa_1.default.command(`${cmdName} ${pkg}`, {
        cwd: baseDir,
        stdio: 'inherit',
        env: {
            SKIP_GENERATE: 'true',
        },
    });
}
/**
 * Warn, if yarn is older than 1.19.2
 */
function checkYarnVersion() {
    if (process.env.npm_config_user_agent) {
        const match = parseUserAgentString(process.env.npm_config_user_agent);
        if (match) {
            const { agent, major, minor, patch } = match;
            if (agent === 'yarn' && major === 1) {
                const currentYarnVersion = `${major}.${minor}.${patch}`;
                const minYarnVersion = '1.19.2';
                if (semverLt(currentYarnVersion, minYarnVersion)) {
                    _1.logger.warn(`Your ${chalk_1.default.bold('yarn')} has version ${currentYarnVersion}, which is outdated. Please update it to ${chalk_1.default.bold(minYarnVersion)} or ${chalk_1.default.bold('newer')} in order to use Prisma.`);
                }
            }
        }
    }
}
/**
 * Warn, if typescript is below `4.1.0` or if it is not install locally or globally
 */
function checkTypeScriptVersion() {
    const minVersion = '4.1.0';
    try {
        const output = execa_1.default.sync('tsc', ['-v'], {
            preferLocal: true,
        });
        if (output.stdout) {
            const currentVersion = output.stdout.split(' ')[1];
            if (semverLt(currentVersion, minVersion)) {
                _1.logger.warn(`Your ${chalk_1.default.bold('typescript')} version is ${currentVersion}, which is outdated. Please update it to ${chalk_1.default.bold(minVersion)} or ${chalk_1.default.bold('newer')} in order to use Prisma Client.`);
            }
        }
    }
    catch (e) {
        // They do not have TS installed, we ignore (example: JS project)
    }
}
/**
 * Returns true, if semver version `a` is lower than `b`
 * Note: This obviously doesn't support the full semver spec.
 * @param {string} a
 * @param {string} b
 */
function semverLt(a, b) {
    const [major1, minor1, patch1] = a.split('.');
    const [major2, minor2, patch2] = b.split('.');
    if (major1 < major2) {
        return true;
    }
    if (major1 > major2) {
        return false;
    }
    if (minor1 < minor2) {
        return true;
    }
    if (minor1 > minor2) {
        return false;
    }
    if (patch1 < patch2) {
        return true;
    }
    if (patch1 > patch2) {
        return false;
    }
    return false;
}
function parseUserAgentString(str) {
    const userAgentRegex = /(\w+)\/(\d+)\.(\d+)\.(\d+)/;
    const match = userAgentRegex.exec(str);
    if (match) {
        const agent = match[1];
        const major = parseInt(match[2]);
        const minor = parseInt(match[3]);
        const patch = parseInt(match[4]);
        return { agent, major, minor, patch };
    }
    return null;
}
//# sourceMappingURL=predefinedGeneratorResolvers.js.map