"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPackedPackage = void 0;
const execa_1 = __importDefault(require("execa"));
const path_1 = __importDefault(require("path"));
const tempy_1 = __importDefault(require("tempy"));
const fs_1 = __importDefault(require("fs"));
const resolve_pkg_1 = __importDefault(require("resolve-pkg"));
const tar_1 = __importDefault(require("tar"));
const copy_1 = __importDefault(require("@timsuchanek/copy"));
const make_dir_1 = __importDefault(require("make-dir"));
const util_1 = require("util");
const rimraf_1 = __importDefault(require("rimraf"));
const read_pkg_up_1 = __importDefault(require("read-pkg-up"));
const hasYarn_1 = require("./utils/hasYarn");
// why not directly use Sindre's 'del'? Because it's not ncc-able :/
const del = util_1.promisify(rimraf_1.default);
const readdir = util_1.promisify(fs_1.default.readdir);
const rename = util_1.promisify(fs_1.default.rename);
async function getPackedPackage(name, target, packageDir) {
    packageDir =
        packageDir ||
            resolve_pkg_1.default(name, { cwd: __dirname }) ||
            resolve_pkg_1.default(name, { cwd: target });
    if (!packageDir) {
        const pkg = await read_pkg_up_1.default({
            cwd: target,
        });
        if (pkg && pkg.packageJson.name === name) {
            packageDir = path_1.default.dirname(pkg.path);
        }
    }
    if (!packageDir && fs_1.default.existsSync(path_1.default.join(process.cwd(), 'package.json'))) {
        packageDir = process.cwd();
    }
    if (!packageDir) {
        throw new Error(`Error in getPackage: Could not resolve package ${name} from ${__dirname}`);
    }
    const tmpDir = tempy_1.default.directory(); // thanks Sindre
    const archivePath = path_1.default.join(tmpDir, `package.tgz`);
    // Check if yarn is available.
    const isYarn = await hasYarn_1.hasYarn(packageDir);
    const packCMD = isYarn
        ? `yarn pack -f ${archivePath}`
        : `npm pack ${packageDir}`;
    // pack into a .tgz in a tmp dir
    await execa_1.default.command(packCMD, {
        shell: true,
        cwd: isYarn ? packageDir : tmpDir, // for npm pack it outputs a file to the cwd
    });
    if (!isYarn) {
        // since npm pack does not have option to specify a filename we change it here
        // find single tgz in temp folder
        const filename = (await readdir(tmpDir))[0];
        // rename it to match expected filename
        await rename(path_1.default.join(tmpDir, filename), archivePath);
    }
    // extract and delete the archive
    await tar_1.default.extract({
        cwd: tmpDir,
        file: archivePath,
    });
    await del(archivePath);
    /**
     * Only if a target is provided, perform the copy
     */
    if (target) {
        // make target dir
        await make_dir_1.default(target);
        // copy stuff over
        await copy_1.default({
            from: path_1.default.join(tmpDir, 'package'),
            to: target,
            recursive: true,
            parallelJobs: 20,
            overwrite: true,
        });
        // delete tmp dir
        await del(tmpDir);
    }
    return path_1.default.join(tmpDir, 'package');
}
exports.getPackedPackage = getPackedPackage;
//# sourceMappingURL=getPackedPackage.js.map