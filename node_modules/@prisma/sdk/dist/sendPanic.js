"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeErrorReportCompleted = exports.createErrorReport = exports.ErrorKind = exports.sendPanic = void 0;
const get_platform_1 = require("@prisma/get-platform");
const archiver_1 = __importDefault(require("archiver"));
const debug_1 = __importDefault(require("@prisma/debug"));
const fs_1 = __importDefault(require("fs"));
const globby_1 = __importDefault(require("globby"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const strip_ansi_1 = __importDefault(require("strip-ansi"));
const tmp_1 = __importDefault(require("tmp"));
const checkpoint = __importStar(require("checkpoint-client"));
const maskSchema_1 = require("./utils/maskSchema");
const panic_1 = require("./panic");
const fetch_engine_1 = require("@prisma/fetch-engine");
const IntrospectionEngine_1 = require("./IntrospectionEngine");
const debug = debug_1.default('prisma:sendPanic');
// cleanup the temporary files even when an uncaught exception occurs
tmp_1.default.setGracefulCleanup();
async function sendPanic(error, cliVersion, binaryVersion) {
    try {
        let schema;
        let maskedSchema;
        if (error.schemaPath) {
            schema = fs_1.default.readFileSync(error.schemaPath, 'utf-8');
        }
        if (error.schema) {
            schema = error.schema;
        }
        if (schema) {
            maskedSchema = maskSchema_1.maskSchema(schema);
        }
        let sqlDump;
        let dbVersion;
        // For a SQLite datasource like `url = "file:dev.db"` only error.schema will be defined
        const schemaOrUrl = error.schema || error.introspectionUrl;
        if (error.area === panic_1.ErrorArea.INTROSPECTION_CLI && schemaOrUrl) {
            let engine;
            try {
                engine = new IntrospectionEngine_1.IntrospectionEngine();
                sqlDump = await engine.getDatabaseDescription(schemaOrUrl);
                dbVersion = await engine.getDatabaseVersion(schemaOrUrl);
                engine.stop();
            }
            catch (e) {
                debug(e);
                if (engine && engine.isRunning) {
                    engine.stop();
                }
            }
        }
        const migrateRequest = error.request
            ? JSON.stringify(maskSchema_1.mapScalarValues(error.request, (value) => {
                if (typeof value === 'string') {
                    return maskSchema_1.maskSchema(value);
                }
                return value;
            }))
            : undefined;
        const params = {
            area: error.area,
            kind: ErrorKind.RUST_PANIC,
            cliVersion,
            binaryVersion,
            command: getCommand(),
            jsStackTrace: strip_ansi_1.default(error.stack || error.message),
            rustStackTrace: error.rustStack,
            operatingSystem: `${os_1.default.arch()} ${os_1.default.platform()} ${os_1.default.release()}`,
            platform: await get_platform_1.getPlatform(),
            liftRequest: migrateRequest,
            schemaFile: maskedSchema,
            fingerprint: await checkpoint.getSignature(),
            sqlDump: sqlDump,
            dbVersion: dbVersion,
        };
        const signedUrl = await createErrorReport(params);
        if (error.schemaPath) {
            const zip = await makeErrorZip(error);
            await uploadZip(zip, signedUrl);
        }
        const id = await makeErrorReportCompleted(signedUrl);
        return id;
    }
    catch (e) {
        debug(e);
    }
}
exports.sendPanic = sendPanic;
function getCommand() {
    // don't send url
    if (process.argv[2] === 'introspect') {
        return 'introspect';
    }
    else if (process.argv[2] === 'db' && process.argv[3] === 'pull') {
        return 'db pull';
    }
    return process.argv.slice(2).join(' ');
}
async function uploadZip(zip, url) {
    return await node_fetch_1.default(url, {
        method: 'PUT',
        agent: fetch_engine_1.getProxyAgent(url),
        headers: {
            'Content-Length': String(zip.byteLength),
        },
        body: zip,
    });
}
async function makeErrorZip(error) {
    if (!error.schemaPath) {
        throw new Error(`Can't make zip without schema path`);
    }
    const schemaDir = path_1.default.dirname(error.schemaPath);
    const tmpFileObj = tmp_1.default.fileSync();
    const outputFile = fs_1.default.createWriteStream(tmpFileObj.name);
    const zip = archiver_1.default('zip', { zlib: { level: 9 } });
    zip.pipe(outputFile);
    // add schema file
    const schemaFile = maskSchema_1.maskSchema(fs_1.default.readFileSync(error.schemaPath, 'utf-8'));
    zip.append(schemaFile, { name: path_1.default.basename(error.schemaPath) });
    if (fs_1.default.existsSync(schemaDir)) {
        const filePaths = await globby_1.default('migrations/**/*', {
            // globby doesn't have it in its types but it's part of mrmlnc/fast-glob
            // @ts-ignore
            cwd: schemaDir,
        });
        for (const filePath of filePaths) {
            let file = fs_1.default.readFileSync(path_1.default.resolve(schemaDir, filePath), 'utf-8');
            if (filePath.endsWith('schema.prisma') ||
                filePath.endsWith(path_1.default.basename(error.schemaPath))) {
                // Remove credentials from schema datasource url
                file = maskSchema_1.maskSchema(file);
            }
            zip.append(file, { name: path_1.default.basename(filePath) });
        }
    }
    zip.finalize();
    return new Promise((resolve, reject) => {
        outputFile.on('close', () => {
            const buffer = fs_1.default.readFileSync(tmpFileObj.name);
            resolve(buffer);
        });
        zip.on('error', (err) => {
            reject(err);
        });
    });
}
var ErrorKind;
(function (ErrorKind) {
    ErrorKind["JS_ERROR"] = "JS_ERROR";
    ErrorKind["RUST_PANIC"] = "RUST_PANIC";
})(ErrorKind = exports.ErrorKind || (exports.ErrorKind = {}));
async function createErrorReport(data) {
    const result = await request(`mutation ($data: CreateErrorReportInput!) {
    createErrorReport(data: $data)
  }`, { data });
    return result.createErrorReport;
}
exports.createErrorReport = createErrorReport;
async function makeErrorReportCompleted(signedUrl) {
    const result = await request(`mutation ($signedUrl: String!) {
  markErrorReportCompleted(signedUrl: $signedUrl)
}`, { signedUrl });
    return result.markErrorReportCompleted;
}
exports.makeErrorReportCompleted = makeErrorReportCompleted;
async function request(query, variables) {
    const url = 'https://error-reports.prisma.sh/';
    const body = JSON.stringify({
        query,
        variables,
    });
    return await node_fetch_1.default(url, {
        method: 'POST',
        agent: fetch_engine_1.getProxyAgent(url),
        body,
        headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json',
        },
    })
        .then((res) => res.json())
        .then((res) => {
        if (res.errors) {
            throw new Error(JSON.stringify(res.errors));
        }
        return res.data;
    });
}
//# sourceMappingURL=sendPanic.js.map