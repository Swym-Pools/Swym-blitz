"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeEngine = void 0;
const engines_1 = require("@prisma/engines");
const get_platform_1 = require("@prisma/get-platform");
const chalk_1 = __importDefault(require("chalk"));
const child_process_1 = require("child_process");
const debug_1 = __importDefault(require("@prisma/debug"));
const events_1 = __importDefault(require("events"));
const execa_1 = __importDefault(require("execa"));
const fs_1 = __importDefault(require("fs"));
const net_1 = __importDefault(require("net"));
const p_retry_1 = __importDefault(require("p-retry"));
const url_1 = require("url");
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const byline_1 = __importDefault(require("./byline"));
const errors_1 = require("./errors");
const log_1 = require("./log");
const omit_1 = require("./omit");
const printGeneratorConfig_1 = require("./printGeneratorConfig");
const undici_1 = require("./undici");
const util_2 = require("./util");
const debug = debug_1.default('prisma:engine');
const exists = util_1.promisify(fs_1.default.exists);
// eslint-disable-next-line
const logger = (...args) => {
    // console.log(chalk.red.bold('logger '), ...args)
};
/**
 * Node.js based wrapper to run the Prisma binary
 */
const knownPlatforms = [...get_platform_1.platforms, 'native'];
const engines = [];
const socketPaths = [];
const MAX_STARTS = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
const MAX_REQUEST_RETRIES = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
class NodeEngine {
    /**
     * exiting is used to tell the .on('exit') hook, if the exit came from our script.
     * As soon as the Prisma binary returns a correct return code (like 1 or 0), we don't need this anymore
     */
    constructor({ cwd, datamodelPath, prismaPath, generator, datasources, showColors, logLevel, logQueries, env, flags, clientVersion, enableExperimental, engineEndpoint, enableDebugLogs, enableEngineDebugMode, dirname, useUds, activeProvider, }) {
        var _a;
        this.startCount = 0;
        this.enableExperimental = [];
        this.useUds = false;
        this.stderrLogs = '';
        this.handleRequestError = async (error, graceful = false) => {
            var _a, _b;
            debug({ error });
            // if we are starting, wait for it before we handle any error
            if (this.startPromise) {
                await this.startPromise;
            }
            this.throwAsyncErrorIfExists();
            // A currentRequestPromise is only being canceled by the sendPanic function
            if ((_a = this.currentRequestPromise) === null || _a === void 0 ? void 0 : _a.isCanceled) {
                this.throwAsyncErrorIfExists();
            }
            else if (
            // matching on all relevant error codes from
            // https://github.com/nodejs/undici/blob/2.x/lib/core/errors.js
            error.code === 'ECONNRESET' ||
                error.code === 'ECONNREFUSED' ||
                error.code === 'UND_ERR_CLOSED' ||
                error.code === 'UND_ERR_SOCKET' ||
                error.code === 'UND_ERR_DESTROYED' ||
                error.code === 'UND_ERR_ABORTED' ||
                error.message.toLowerCase().includes('client is destroyed') ||
                error.message.toLowerCase().includes('other side closed') ||
                error.message.toLowerCase().includes('the client is closed')) {
                if (this.globalKillSignalReceived && !((_b = this.child) === null || _b === void 0 ? void 0 : _b.connected)) {
                    throw new errors_1.PrismaClientUnknownRequestError(`The Node.js process already received a ${this.globalKillSignalReceived} signal, therefore the Prisma query engine exited
and your request can't be processed.
You probably have some open handle that prevents your process from exiting.
It could be an open http server or stream that didn't close yet.
We recommend using the \`wtfnode\` package to debug open handles.`, this.clientVersion);
                }
                this.throwAsyncErrorIfExists();
                if (this.startCount > MAX_STARTS) {
                    // if we didn't throw yet, which is unlikely, we want to poll on stderr / stdout here
                    // to get an error first
                    for (let i = 0; i < 5; i++) {
                        await new Promise((r) => setTimeout(r, 50));
                        this.throwAsyncErrorIfExists(true);
                    }
                    throw new Error(`Query engine is trying to restart, but can't.
Please look into the logs or turn on the env var DEBUG=* to debug the constantly restarting query engine.`);
                }
            }
            if (!graceful) {
                this.throwAsyncErrorIfExists(true);
                throw error;
            }
            return false;
        };
        this.dirname = dirname;
        this.useUds = useUds !== null && useUds !== void 0 ? useUds : false; // === undefined ? process.platform !== 'win32' : useUds
        this.env = env;
        this.cwd = this.resolveCwd(cwd);
        this.enableDebugLogs = enableDebugLogs !== null && enableDebugLogs !== void 0 ? enableDebugLogs : false;
        this.enableEngineDebugMode = enableEngineDebugMode !== null && enableEngineDebugMode !== void 0 ? enableEngineDebugMode : false;
        this.datamodelPath = datamodelPath;
        this.prismaPath = (_a = process.env.PRISMA_QUERY_ENGINE_BINARY) !== null && _a !== void 0 ? _a : prismaPath;
        this.generator = generator;
        this.datasources = datasources;
        this.logEmitter = new events_1.default();
        this.logEmitter.on('error', () => {
            // to prevent unhandled error events
        });
        this.showColors = showColors !== null && showColors !== void 0 ? showColors : false;
        this.logLevel = logLevel;
        this.logQueries = logQueries !== null && logQueries !== void 0 ? logQueries : false;
        this.clientVersion = clientVersion;
        this.flags = flags !== null && flags !== void 0 ? flags : [];
        this.enableExperimental = enableExperimental !== null && enableExperimental !== void 0 ? enableExperimental : [];
        this.activeProvider = activeProvider;
        const removedFlags = [
            'middlewares',
            'aggregateApi',
            'distinct',
            'aggregations',
            'insensitiveFilters',
            'atomicNumberOperations',
            'transactionApi',
            'transaction',
            'connectOrCreate',
            'uncheckedScalarInputs',
            'nativeTypes',
        ];
        const removedFlagsUsed = this.enableExperimental.filter((e) => removedFlags.includes(e));
        if (removedFlagsUsed.length > 0 &&
            !process.env.PRISMA_HIDE_PREVIEW_FLAG_WARNINGS) {
            console.log(`${chalk_1.default.blueBright('info')} The preview flags \`${removedFlagsUsed.join('`, `')}\` were removed, you can now safely remove them from your schema.prisma.`);
        }
        this.enableExperimental = this.enableExperimental.filter((e) => !removedFlags.includes(e));
        this.engineEndpoint = engineEndpoint;
        if (engineEndpoint) {
            const url = new url_1.URL(engineEndpoint);
            this.port = Number(url.port);
        }
        if (this.platform) {
            if (!knownPlatforms.includes(this.platform) &&
                !fs_1.default.existsSync(this.platform)) {
                throw new errors_1.PrismaClientInitializationError(`Unknown ${chalk_1.default.red('PRISMA_QUERY_ENGINE_BINARY')} ${chalk_1.default.redBright.bold(this.platform)}. Possible binaryTargets: ${chalk_1.default.greenBright(knownPlatforms.join(', '))} or a path to the query engine binary.
You may have to run ${chalk_1.default.greenBright('prisma generate')} for your changes to take effect.`, this.clientVersion);
            }
        }
        else {
            void this.getPlatform();
        }
        if (this.enableDebugLogs) {
            debug_1.default.enable('*');
        }
        engines.push(this);
        this.checkForTooManyEngines();
    }
    setError(err) {
        var _a;
        if (log_1.isRustError(err)) {
            this.lastRustError = err;
            this.logEmitter.emit('error', new errors_1.PrismaClientRustError({
                clientVersion: this.clientVersion,
                error: err,
            }));
            if (err.is_panic) {
                this.handlePanic();
            }
        }
        else if (log_1.isRustErrorLog(err)) {
            this.lastErrorLog = err;
            this.logEmitter.emit('error', new errors_1.PrismaClientRustError({
                clientVersion: this.clientVersion,
                log: err,
            }));
            if (((_a = err.fields) === null || _a === void 0 ? void 0 : _a.message) === 'PANIC') {
                this.handlePanic();
            }
        }
        else {
            this.logEmitter.emit('error', err);
        }
    }
    checkForTooManyEngines() {
        if (engines.length >= 10) {
            const runningEngines = engines.filter((e) => e.child);
            if (runningEngines.length === 10) {
                console.warn(`${chalk_1.default.yellow('warn(prisma-client)')} Already 10 Prisma Clients are actively running.`);
            }
        }
    }
    resolveCwd(cwd) {
        if (cwd && fs_1.default.existsSync(cwd) && fs_1.default.lstatSync(cwd).isDirectory()) {
            return cwd;
        }
        return process.cwd();
    }
    on(event, listener) {
        if (event === 'beforeExit') {
            this.beforeExitListener = listener;
        }
        else {
            this.logEmitter.on(event, listener);
        }
    }
    async emitExit() {
        if (this.beforeExitListener) {
            try {
                await this.beforeExitListener();
            }
            catch (e) {
                console.error(e);
            }
        }
    }
    async getPlatform() {
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        if (this.platformPromise) {
            return this.platformPromise;
        }
        this.platformPromise = get_platform_1.getPlatform();
        return this.platformPromise;
    }
    getQueryEnginePath(platform, prefix = __dirname) {
        let queryEnginePath = path_1.default.join(prefix, `query-engine-${platform}`);
        if (platform === 'windows') {
            queryEnginePath = `${queryEnginePath}.exe`;
        }
        return queryEnginePath;
    }
    handlePanic() {
        var _a;
        (_a = this.child) === null || _a === void 0 ? void 0 : _a.kill();
        if (this.currentRequestPromise) {
            this.currentRequestPromise.cancel();
        }
    }
    async resolvePrismaPath() {
        var _a, _b;
        const searchedLocations = [];
        let enginePath;
        if (this.prismaPath) {
            return { prismaPath: this.prismaPath, searchedLocations };
        }
        const platform = await this.getPlatform();
        if (this.platform && this.platform !== platform) {
            this.incorrectlyPinnedBinaryTarget = this.platform;
        }
        this.platform = this.platform || platform;
        if (__filename.includes('NodeEngine')) {
            enginePath = this.getQueryEnginePath(this.platform, engines_1.getEnginesPath());
            return { prismaPath: enginePath, searchedLocations };
        }
        const searchLocations = [
            eval(`require('path').join(__dirname, '../../../.prisma/client')`),
            (_b = (_a = this.generator) === null || _a === void 0 ? void 0 : _a.output) !== null && _b !== void 0 ? _b : eval('__dirname'),
            path_1.default.join(eval('__dirname'), '..'),
            path_1.default.dirname(this.datamodelPath),
            this.cwd, //cwdPath
        ];
        if (this.dirname) {
            searchLocations.push(this.dirname);
        }
        for (const location of searchLocations) {
            searchedLocations.push(location);
            debug(`Search for Query Engine in ${location}`);
            enginePath = this.getQueryEnginePath(this.platform, location);
            if (fs_1.default.existsSync(enginePath)) {
                return { prismaPath: enginePath, searchedLocations };
            }
        }
        enginePath = this.getQueryEnginePath(this.platform);
        return { prismaPath: enginePath !== null && enginePath !== void 0 ? enginePath : '', searchedLocations };
    }
    // get prisma path
    async getPrismaPath() {
        const { prismaPath, searchedLocations } = await this.resolvePrismaPath();
        const platform = await this.getPlatform();
        // If path to query engine doesn't exist, throw
        if (!(await exists(prismaPath))) {
            const pinnedStr = this.incorrectlyPinnedBinaryTarget
                ? `\nYou incorrectly pinned it to ${chalk_1.default.redBright.bold(`${this.incorrectlyPinnedBinaryTarget}`)}\n`
                : '';
            let errorText = `Query engine binary for current platform "${chalk_1.default.bold(platform)}" could not be found.${pinnedStr}
This probably happens, because you built Prisma Client on a different platform.
(Prisma Client looked in "${chalk_1.default.underline(prismaPath)}")

Searched Locations:

${searchedLocations
                .map((f) => {
                let msg = `  ${f}`;
                if (process.env.DEBUG === 'node-engine-search-locations' &&
                    fs_1.default.existsSync(f)) {
                    const dir = fs_1.default.readdirSync(f);
                    msg += dir.map((d) => `    ${d}`).join('\n');
                }
                return msg;
            })
                .join('\n' + (process.env.DEBUG === 'node-engine-search-locations' ? '\n' : ''))}\n`;
            // The generator should always be there during normal usage
            if (this.generator) {
                // The user already added it, but it still doesn't work 🤷‍♀️
                // That means, that some build system just deleted the files 🤔
                if (this.generator.binaryTargets.includes(this.platform) ||
                    this.generator.binaryTargets.includes('native')) {
                    errorText += `
You already added the platform${this.generator.binaryTargets.length > 1 ? 's' : ''} ${this.generator.binaryTargets
                        .map((t) => `"${chalk_1.default.bold(t)}"`)
                        .join(', ')} to the "${chalk_1.default.underline('generator')}" block
in the "schema.prisma" file as described in https://pris.ly/d/client-generator,
but something went wrong. That's suboptimal.

Please create an issue at https://github.com/prisma/prisma/issues/new`;
                    errorText += ``;
                }
                else {
                    // If they didn't even have the current running platform in the schema.prisma file, it's easy
                    // Just add it
                    errorText += `\n\nTo solve this problem, add the platform "${this.platform}" to the "${chalk_1.default.underline('generator')}" block in the "schema.prisma" file:
${chalk_1.default.greenBright(this.getFixedGenerator())}

Then run "${chalk_1.default.greenBright('prisma generate')}" for your changes to take effect.
Read more about deploying Prisma Client: https://pris.ly/d/client-generator`;
                }
            }
            else {
                errorText += `\n\nRead more about deploying Prisma Client: https://pris.ly/d/client-generator\n`;
            }
            throw new errors_1.PrismaClientInitializationError(errorText, this.clientVersion);
        }
        if (this.incorrectlyPinnedBinaryTarget) {
            console.error(`${chalk_1.default.yellow('Warning:')} You pinned the platform ${chalk_1.default.bold(this.incorrectlyPinnedBinaryTarget)}, but Prisma Client detects ${chalk_1.default.bold(await this.getPlatform())}.
This means you should very likely pin the platform ${chalk_1.default.greenBright(await this.getPlatform())} instead.
${chalk_1.default.dim("In case we're mistaken, please report this to us 🙏.")}`);
        }
        if (process.platform !== 'win32') {
            util_2.plusX(prismaPath);
        }
        return prismaPath;
    }
    getFixedGenerator() {
        const fixedGenerator = {
            ...this.generator,
            binaryTargets: util_2.fixBinaryTargets(this.generator.binaryTargets, this.platform),
        };
        return printGeneratorConfig_1.printGeneratorConfig(fixedGenerator);
    }
    printDatasources() {
        if (this.datasources) {
            return JSON.stringify(this.datasources);
        }
        return '[]';
    }
    /**
     * Starts the engine, returns the url that it runs on
     */
    async start() {
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        if (!this.startPromise) {
            this.startCount++;
            this.startPromise = this.internalStart();
        }
        return this.startPromise;
    }
    getEngineEnvVars() {
        const env = {
            PRISMA_DML_PATH: this.datamodelPath,
            RUST_BACKTRACE: '1',
            RUST_LOG: 'info',
        };
        if (this.logQueries || this.logLevel === 'info') {
            env.RUST_LOG = 'info';
            if (this.logQueries) {
                env.LOG_QUERIES = 'true';
            }
        }
        if (this.datasources) {
            env.OVERWRITE_DATASOURCES = this.printDatasources();
        }
        if (!process.env.NO_COLOR && this.showColors) {
            env.CLICOLOR_FORCE = '1';
        }
        return {
            ...this.env,
            ...process.env,
            ...env,
        };
    }
    internalStart() {
        // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor
        return new Promise(async (resolve, reject) => {
            var _a, _b, _c;
            await new Promise((r) => process.nextTick(r));
            if (this.stopPromise) {
                await this.stopPromise;
            }
            if (this.engineEndpoint) {
                try {
                    await p_retry_1.default(() => this.undici.status(), {
                        retries: 10,
                    });
                }
                catch (e) {
                    return reject(e);
                }
                return resolve();
            }
            try {
                if (((_a = this.child) === null || _a === void 0 ? void 0 : _a.connected) || (this.child && !((_b = this.child) === null || _b === void 0 ? void 0 : _b.killed))) {
                    debug(`There is a child that still runs and we want to start again`);
                }
                // reset last panic
                this.lastRustError = undefined;
                this.lastErrorLog = undefined;
                this.lastPanic = undefined;
                logger('startin & resettin');
                this.globalKillSignalReceived = undefined;
                if (this.useUds) {
                    this.socketPath = `/tmp/prisma-${util_2.getRandomString()}.sock`;
                    socketPaths.push(this.socketPath);
                }
                debug({ cwd: this.cwd });
                const prismaPath = await this.getPrismaPath();
                const experimentalFlags = this.enableExperimental &&
                    Array.isArray(this.enableExperimental) &&
                    this.enableExperimental.length > 0
                    ? [`--enable-experimental=${this.enableExperimental.join(',')}`]
                    : [];
                const debugFlag = this.enableEngineDebugMode ? ['--debug'] : [];
                const flags = [
                    ...experimentalFlags,
                    ...debugFlag,
                    '--enable-raw-queries',
                    ...this.flags,
                ];
                if (this.useUds) {
                    flags.push('--unix-path', this.socketPath);
                }
                else {
                    this.port = await this.getFreePort();
                    flags.push('--port', String(this.port));
                }
                debug({ flags });
                const env = this.getEngineEnvVars();
                this.child = child_process_1.spawn(prismaPath, flags, {
                    env,
                    cwd: this.cwd,
                    windowsHide: true,
                    stdio: ['ignore', 'pipe', 'pipe'],
                });
                byline_1.default(this.child.stderr).on('data', (msg) => {
                    const data = String(msg);
                    debug('stderr', data);
                    try {
                        const json = JSON.parse(data);
                        if (typeof json.is_panic !== 'undefined') {
                            debug(json);
                            this.setError(json);
                            if (this.engineStartDeferred) {
                                const err = new errors_1.PrismaClientInitializationError(json.message, this.clientVersion);
                                this.engineStartDeferred.reject(err);
                            }
                        }
                    }
                    catch (e) {
                        if (!data.includes('Printing to stderr') &&
                            !data.includes('Listening on ')) {
                            this.stderrLogs += '\n' + data;
                        }
                    }
                });
                byline_1.default(this.child.stdout).on('data', (msg) => {
                    var _a, _b;
                    const data = String(msg);
                    try {
                        const json = JSON.parse(data);
                        debug('stdout', log_1.getMessage(json));
                        if (this.engineStartDeferred &&
                            json.level === 'INFO' &&
                            json.target === 'query_engine::server' &&
                            ((_b = (_a = json.fields) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.startsWith('Started http server'))) {
                            if (this.useUds) {
                                this.undici = new undici_1.Undici('http://localhost', {
                                    socketPath: this.socketPath,
                                });
                            }
                            else {
                                this.undici = new undici_1.Undici(`http://localhost:${this.port}`);
                            }
                            this.engineStartDeferred.resolve();
                            this.engineStartDeferred = undefined;
                        }
                        // only emit logs, if they're in the from of a log
                        // they could also be a RustError, which has is_panic
                        // these logs can still include error logs
                        if (typeof json.is_panic === 'undefined') {
                            const log = log_1.convertLog(json);
                            // boolean cast needed, because of TS. We return ` is RustLog`, useful in other context, but not here
                            const logIsRustErrorLog = log_1.isRustErrorLog(log);
                            if (logIsRustErrorLog) {
                                this.setError(log);
                            }
                            else {
                                this.logEmitter.emit(log.level, log);
                            }
                        }
                        else {
                            this.setError(json);
                        }
                    }
                    catch (e) {
                        debug(e, data);
                    }
                });
                this.child.on('exit', (code) => {
                    var _a, _b;
                    logger('removing startPromise');
                    this.startPromise = undefined;
                    if (this.engineStopDeferred) {
                        this.engineStopDeferred.resolve(code);
                        return;
                    }
                    (_a = this.undici) === null || _a === void 0 ? void 0 : _a.close();
                    // don't error in restarts
                    if (code !== 0 && this.engineStartDeferred && this.startCount === 1) {
                        let err;
                        let msg = this.stderrLogs;
                        if (this.lastRustError) {
                            msg = log_1.getMessage(this.lastRustError);
                        }
                        else if (this.lastErrorLog) {
                            msg = log_1.getMessage(this.lastErrorLog);
                        }
                        if (code !== null) {
                            err = new errors_1.PrismaClientInitializationError(`Query engine exited with code ${code}\n` + msg, this.clientVersion);
                        }
                        else if ((_b = this.child) === null || _b === void 0 ? void 0 : _b.signalCode) {
                            err = new errors_1.PrismaClientInitializationError(`Query engine process killed with signal ${this.child.signalCode} for unknown reason.
Make sure that the engine binary at ${prismaPath} is not corrupt.\n` + msg, this.clientVersion);
                        }
                        else {
                            err = new errors_1.PrismaClientInitializationError(msg, this.clientVersion);
                        }
                        this.engineStartDeferred.reject(err);
                    }
                    if (!this.child) {
                        return;
                    }
                    if (this.lastRustError) {
                        return;
                    }
                    if (code === 126) {
                        this.setError({
                            timestamp: new Date(),
                            target: 'exit',
                            level: 'error',
                            fields: {
                                message: `Couldn't start query engine as it's not executable on this operating system.
You very likely have the wrong "binaryTarget" defined in the schema.prisma file.`,
                            },
                        });
                    }
                });
                this.child.on('error', (err) => {
                    this.setError({
                        message: err.message,
                        backtrace: 'Could not start query engine',
                        is_panic: false,
                    });
                    reject(err);
                });
                this.child.on('close', (code, signal) => {
                    var _a, _b;
                    (_a = this.undici) === null || _a === void 0 ? void 0 : _a.close();
                    if (code === null && signal === 'SIGABRT' && this.child) {
                        const error = new errors_1.PrismaClientRustPanicError(this.getErrorMessageWithLink('Panic in Query Engine with SIGABRT signal'), this.clientVersion);
                        this.logEmitter.emit('error', error);
                    }
                    else if (code === 255 &&
                        signal === null &&
                        // if there is a "this.lastPanic", the panic has already been handled, so we don't need
                        // to look into it anymore
                        ((_b = this.lastErrorLog) === null || _b === void 0 ? void 0 : _b.fields.message) === 'PANIC' &&
                        !this.lastPanic) {
                        const error = new errors_1.PrismaClientRustPanicError(this.getErrorMessageWithLink(`${this.lastErrorLog.fields.message}: ${this.lastErrorLog.fields.reason} in ${this.lastErrorLog.fields.file}:${this.lastErrorLog.fields.line}:${this.lastErrorLog.fields.column}`), this.clientVersion);
                        this.setError(error);
                    }
                });
                if (this.lastRustError) {
                    return reject(new errors_1.PrismaClientInitializationError(log_1.getMessage(this.lastRustError), this.clientVersion));
                }
                if (this.lastErrorLog) {
                    return reject(new errors_1.PrismaClientInitializationError(log_1.getMessage(this.lastErrorLog), this.clientVersion));
                }
                try {
                    await new Promise((resolve, reject) => {
                        this.engineStartDeferred = { resolve, reject };
                    });
                }
                catch (err) {
                    (_c = this.child) === null || _c === void 0 ? void 0 : _c.kill();
                    throw err;
                }
                // don't wait for this
                void (async () => {
                    try {
                        const engineVersion = await this.version(true);
                        debug(`Client Version: ${this.clientVersion}`);
                        debug(`Engine Version: ${engineVersion}`);
                        debug(`Active provider: ${this.activeProvider}`);
                    }
                    catch (e) {
                        debug(e);
                    }
                })();
                this.stopPromise = undefined;
                resolve();
            }
            catch (e) {
                reject(e);
            }
        });
    }
    async stop() {
        if (!this.stopPromise) {
            this.stopPromise = this._stop();
        }
        return this.stopPromise;
    }
    /**
     * If Prisma runs, stop it
     */
    async _stop() {
        var _a, _b;
        if (this.startPromise) {
            await this.startPromise;
        }
        // not sure yet if this is a good idea
        await new Promise((resolve) => process.nextTick(resolve));
        if (this.currentRequestPromise) {
            try {
                await this.currentRequestPromise;
            }
            catch (e) {
                //
            }
        }
        this.getConfigPromise = undefined;
        let stopChildPromise;
        if (this.child) {
            debug(`Stopping Prisma engine4`);
            if (this.startPromise) {
                debug(`Waiting for start promise`);
                await this.startPromise;
            }
            debug(`Done waiting for start promise`);
            stopChildPromise = new Promise((resolve, reject) => {
                this.engineStopDeferred = { resolve, reject };
            });
            (_a = this.undici) === null || _a === void 0 ? void 0 : _a.close();
            (_b = this.child) === null || _b === void 0 ? void 0 : _b.kill();
            this.child = undefined;
        }
        if (stopChildPromise) {
            await stopChildPromise;
        }
        await new Promise((r) => process.nextTick(r));
        this.startPromise = undefined;
        this.engineStopDeferred = undefined;
    }
    kill(signal) {
        var _a, _b;
        this.getConfigPromise = undefined;
        this.globalKillSignalReceived = signal;
        (_a = this.child) === null || _a === void 0 ? void 0 : _a.kill();
        (_b = this.undici) === null || _b === void 0 ? void 0 : _b.close();
    }
    /**
     * Use the port 0 trick to get a new port
     */
    getFreePort() {
        return new Promise((resolve, reject) => {
            const server = net_1.default.createServer((s) => s.end(''));
            server.unref();
            server.on('error', reject);
            server.listen(0, () => {
                const address = server.address();
                const port = typeof address === 'string'
                    ? parseInt(address.split(':').slice(-1)[0], 10)
                    : address.port;
                server.close((e) => {
                    if (e) {
                        reject(e);
                    }
                    resolve(port);
                });
            });
        });
    }
    async getConfig() {
        if (!this.getConfigPromise) {
            this.getConfigPromise = this._getConfig();
        }
        return this.getConfigPromise;
    }
    async _getConfig() {
        const prismaPath = await this.getPrismaPath();
        const env = await this.getEngineEnvVars();
        const result = await execa_1.default(prismaPath, ['cli', 'get-config'], {
            env: omit_1.omit(env, ['PORT']),
            cwd: this.cwd,
        });
        return JSON.parse(result.stdout);
    }
    async version(forceRun = false) {
        if (this.versionPromise && !forceRun) {
            return this.versionPromise;
        }
        this.versionPromise = this.internalVersion();
        return this.versionPromise;
    }
    async internalVersion() {
        const prismaPath = await this.getPrismaPath();
        const result = await execa_1.default(prismaPath, ['--version']);
        this.lastVersion = result.stdout;
        return this.lastVersion;
    }
    async request(query, headers, numTry = 1) {
        if (this.stopPromise) {
            await this.stopPromise;
        }
        await this.start();
        if (!this.child && !this.engineEndpoint) {
            throw new errors_1.PrismaClientUnknownRequestError(`Can't perform request, as the Engine has already been stopped`, this.clientVersion);
        }
        this.currentRequestPromise = this.undici.request(stringifyQuery(query), headers);
        this.lastQuery = query;
        try {
            const { data, headers } = await this.currentRequestPromise;
            if (data.errors) {
                if (data.errors.length === 1) {
                    throw this.graphQLToJSError(data.errors[0]);
                }
                // this case should not happen, as the query engine only returns one error
                throw new errors_1.PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.clientVersion);
            }
            // Rust engine returns time in microseconds and we want it in miliseconds
            const elapsed = parseInt(headers['x-elapsed']) / 1000;
            // reset restart count after successful request
            if (this.startCount > 0) {
                this.startCount = 0;
            }
            this.currentRequestPromise = undefined;
            return { data, elapsed };
        }
        catch (error) {
            logger('req - e', error);
            if (error instanceof errors_1.PrismaClientKnownRequestError) {
                throw error;
            }
            await this.handleRequestError(error, numTry <= MAX_REQUEST_RETRIES);
            // retry
            if (numTry <= MAX_REQUEST_RETRIES) {
                logger('trying a retry now');
                return this.request(query, headers, numTry + 1);
            }
        }
        return null; // needed to make TS happy
    }
    async requestBatch(queries, transaction = false, numTry = 1) {
        await this.start();
        if (!this.child && !this.engineEndpoint) {
            throw new errors_1.PrismaClientUnknownRequestError(`Can't perform request, as the Engine has already been stopped`, this.clientVersion);
        }
        const variables = {};
        const body = {
            batch: queries.map((query) => ({ query, variables })),
            transaction,
        };
        const stringifiedQuery = JSON.stringify(body);
        this.currentRequestPromise = this.undici.request(stringifiedQuery);
        this.lastQuery = stringifiedQuery;
        return this.currentRequestPromise
            .then(({ data, headers }) => {
            // Rust engine returns time in microseconds and we want it in miliseconds
            const elapsed = parseInt(headers['x-elapsed']) / 1000;
            const { batchResult, errors } = data;
            if (Array.isArray(batchResult)) {
                return batchResult.map((result) => {
                    if (result.errors) {
                        return this.graphQLToJSError(result.errors[0]);
                    }
                    return {
                        data: result,
                        elapsed,
                    };
                });
            }
            else {
                if (errors && errors.length === 1) {
                    throw new Error(errors[0].error);
                }
                throw new Error(JSON.stringify(data));
            }
        })
            .catch(async (e) => {
            const isError = await this.handleRequestError(e, numTry < 3);
            if (!isError) {
                // retry
                if (numTry <= MAX_REQUEST_RETRIES) {
                    return this.requestBatch(queries, transaction, numTry + 1);
                }
            }
            throw isError;
        });
    }
    get hasMaxRestarts() {
        return this.startCount >= MAX_STARTS;
    }
    /**
     * If we have request errors like "ECONNRESET", we need to get the error from a
     * different place, not the request itself. This different place can either be
     * this.lastRustError or this.lastErrorLog
     */
    throwAsyncErrorIfExists(forceThrow = false) {
        var _a, _b;
        logger('throwAsyncErrorIfExists', this.startCount, this.hasMaxRestarts);
        if (this.lastRustError) {
            const err = new errors_1.PrismaClientRustPanicError(this.getErrorMessageWithLink(log_1.getMessage(this.lastRustError)), this.clientVersion);
            if (this.lastRustError.is_panic) {
                this.lastPanic = err;
            }
            if (this.hasMaxRestarts || forceThrow) {
                throw err;
            }
        }
        if (this.lastErrorLog && log_1.isRustErrorLog(this.lastErrorLog)) {
            const err = new errors_1.PrismaClientUnknownRequestError(this.getErrorMessageWithLink(log_1.getMessage(this.lastErrorLog)), this.clientVersion);
            if (((_b = (_a = this.lastErrorLog) === null || _a === void 0 ? void 0 : _a.fields) === null || _b === void 0 ? void 0 : _b.message) === 'PANIC') {
                this.lastPanic = err;
            }
            if (this.hasMaxRestarts || forceThrow) {
                throw err;
            }
        }
    }
    getErrorMessageWithLink(title) {
        return errors_1.getErrorMessageWithLink({
            platform: this.platform,
            title,
            version: this.clientVersion,
            engineVersion: this.lastVersion,
            database: this.lastActiveProvider,
            query: this.lastQuery,
        });
    }
    graphQLToJSError(error) {
        if (error.user_facing_error.error_code) {
            return new errors_1.PrismaClientKnownRequestError(error.user_facing_error.message, error.user_facing_error.error_code, this.clientVersion, error.user_facing_error.meta);
        }
        return new errors_1.PrismaClientUnknownRequestError(error.user_facing_error.message, this.clientVersion);
    }
}
exports.NodeEngine = NodeEngine;
// faster than creating a new object and JSON.stringify it all the time
function stringifyQuery(q) {
    return `{"variables":{},"query":${JSON.stringify(q)}}`;
}
function hookProcess(handler, exit = false) {
    process.once(handler, async () => {
        for (const engine of engines) {
            await engine.emitExit();
            engine.kill(handler);
        }
        engines.splice(0, engines.length);
        if (socketPaths.length > 0) {
            for (const socketPath of socketPaths) {
                try {
                    fs_1.default.unlinkSync(socketPath);
                }
                catch (e) {
                    //
                }
            }
        }
        // only exit, if only we are listening
        // if there is another listener, that other listener is responsible
        if (exit && process.listenerCount(handler) === 0) {
            process.exit();
        }
    });
}
hookProcess('beforeExit');
hookProcess('exit');
hookProcess('SIGINT', true);
hookProcess('SIGUSR1', true);
hookProcess('SIGUSR2', true);
hookProcess('SIGTERM', true);
//# sourceMappingURL=NodeEngine.js.map